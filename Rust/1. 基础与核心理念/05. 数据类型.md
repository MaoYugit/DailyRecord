现在，我们正式进入 Rust 编程的基石——**数据类型 (Data Types)**。

在 Rust 中，类型系统是其**内存安全**和**性能**保证的核心。Rust 是一种**静态类型 (Statically Typed)** 语言，这意味着编译器**必须**在编译时知道所有变量的类型。这消除了许多在动态类型语言中会在运行时才出现的错误。

---

Rust 的数据类型主要分为两大类：

1.  **标量类型 (Scalar Types)**：表示单个值。
2.  **复合类型 (Compound Types)**：将多个值组合成一个类型。

---

### Part 1: 标量类型 (Scalar Types)

标量类型是 Rust 中最基本的数据单元。

#### 1.1 整型 (Integer Types)

整型是没有小数部分的数字。Rust 提供了非常精细的整型分类，让你能根据需求选择最合适的类型，从而精确控制内存使用。

| 长度 (Bits) | 有符号 (Signed) | 无符号 (Unsigned) |
| :---------- | :-------------- | :---------------- |
| 8-bit       | `i8`            | `u8`              |
| 16-bit      | `i16`           | `u16`             |
| 32-bit      | `i32`           | `u32`             |
| 64-bit      | `i64`           | `u64`             |
| 128-bit     | `i128`          | `u128`            |
| 架构相关    | `isize`         | `usize`           |

*   **有符号 (`i`) vs. 无符号 (`u`) (面试重点)**
    *   **有符号 (`i` for integer)**: 可以存储正数、负数和零。例如，`i8` 的范围是 -128 到 127。
    *   **无符号 (`u` for unsigned)**: 只能存储正数和零。例如，`u8` 的范围是 0 到 255。
    *   **实战选择**: 如果你确定一个值永远不会是负数（比如，计数器、长度、ID），请优先使用无符号类型 (`u32`, `u64`, `usize`)，这能更清晰地表达你的意图。

*   **`isize` 和 `usize` (极其重要)**
    *   这两个类型的长度取决于你的计算机架构：在 32 位架构上是 32 位，在 64 位架构上是 64 位。
    *   **`usize` 的核心用途**: **用于索引集合**。当你需要引用一个集合（如数组、切片、向量）中的某个位置时，应该总是使用 `usize`。这是因为内存地址是非负的，并且其大小与系统的指针大小相关。

**示例：整型和数字字面量**

```rust
fn main() {
    // 编译器通常可以推断类型
    let a = 98_222; // 十进制，下划线可作为视觉分隔符

    // 你也可以显式指定类型
    let b: i32 = -100;
    let c: u64 = 50000;

    // 不同进制的字面量
    let hex = 0xff;      // 十六进制
    let octal = 0o77;    // 八进制
    let binary = 0b1111_0000; // 二进制
    let byte: u8 = b'A'; // 字节 (仅限 u8)

    // 使用 usize 来索引
    let numbers = [10, 20, 30];
    let index: usize = 1;
    let value = numbers[index];

    println!("Decimal: {}, Hex: {}, Value at index {}: {}", a, hex, index, value);
}
```

*   **整型溢出 (Integer Overflow) (面试重点)**
    *   当你试图给一个整型变量赋予一个超出其范围的值时，就会发生溢出。
    *   **Debug 模式下**: Rust 会 `panic!` (程序崩溃)。这是为了在开发时立刻帮你发现 bug。
    *   **Release 模式下 (`--release`)**: Rust **不会** `panic`。它会执行一种称为“二进制补码环绕 (two's complement wrapping)”的行为。例如，一个 `u8` 变量的值是 255，你给它加 1，它会变成 0。
    *   **实战建议**: 如果你期望发生环绕行为，请使用 `wrapping_*` 系列方法，例如 `wrapping_add`。如果你想处理溢出，可以使用 `checked_*` 方法，它会返回一个 `Option`。

#### 1.2 浮点型 (Floating-Point Types)

浮点型是带小数部分的数字。Rust 有两种浮点类型：

*   `f32`: 单精度浮点数 (32-bit)。
*   `f64`: 双精度浮点数 (64-bit)。

**实战选择**:
*   `f64` 是默认类型，因为它提供了更高的精度。在现代 CPU 上，`f64` 和 `f32` 的计算速度几乎没有差别。
*   除非你有特殊需求（例如，需要节省大量浮点数数组的内存空间，且对精度要求不高），否则**总是优先使用 `f64`**。

```rust
fn main() {
    let x = 2.0; // 默认为 f64
    let y: f32 = 3.1; // 显式指定 f32
    println!("x = {}, y = {}", x, y);
}
```

#### 1.3布尔型 (Boolean Type)

*   类型为 `bool`。
*   只有两个可能的值：`true` 或 `false`。
*   占用一个字节的内存空间。

```rust
fn main() {
    let is_active = true;
    let is_admin: bool = false;

    if is_active {
        println!("User is active!");
    }
}
```

#### 1.4 字符型 (Character Type)

*   类型为 `char`。
*   **面试核心**: Rust 的 `char` 类型**不是**像 C 语言那样的 8 位 ASCII 字符。它是 **32 位 (4 字节)** 的 **Unicode 标量值 (Unicode Scalar Value)**。
*   这意味着一个 `char` 可以表示比 ASCII 多得多的字符，包括各种语言的字母、符号，甚至是表情符号 (emoji)。
*   `char` 字面量用**单引号** `' '` 表示。

```rust
fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // 数学符号
    let heart_eyed_cat = '😻'; // 表情符号

    println!("{}, {}, {}", c, z, heart_eyed_cat);
}
```

---

### Part 2: 复合类型 (Compound Types)

复合类型可以将多个值组合成一个类型。Rust 内置了两种主要的复合类型：元组和数组。

#### 2.1 元组 (Tuple)

元组是一个可以将多种不同类型的值组合进一个复合类型的方式。元组的长度是固定的：一旦声明，其长度不能增加或缩小。

**何时使用**: 当你想从一个函数返回多个不同类型的值时，元组特别有用。或者当你需要一个临时的、简单的、包含不同类型元素的集合时。

**创建与访问**:
1.  使用圆括号 `()` 创建。
2.  使用模式匹配进行**解构 (Destructuring)**。
3.  使用点号 `.` 和索引来直接访问元素。

```rust
fn calculate_stats(numbers: &[i32]) -> (i32, i32, f64) {
    let sum: i32 = numbers.iter().sum();
    let count = numbers.len();
    let average = sum as f64 / count as f64;
    (sum, count as i32, average) // 返回一个元组
}

fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);

    // 1. 通过解构来访问
    let (x, y, z) = tup;
    println!("The value of y is: {}", y);

    // 2. 通过点号和索引来访问
    let five_hundred = tup.0;
    let six_point_four = tup.1;
    println!("Direct access: {}, {}", five_hundred, six_point_four);
    
    // 使用元组作为函数返回值
    let data = [10, 20, 30, 40, 50];
    let (total, num_items, avg) = calculate_stats(&data);
    println!("Sum: {}, Count: {}, Average: {:.2}", total, num_items, avg);

    // 特殊元组：单元类型 ()
    // () 是一种特殊的元组，没有任何元素。它代表一个空值或空的返回类型。
    // 我们在函数教学中已经见过它了。
}
```

#### 2.2 数组 (Array)

数组允许你将多个**相同类型**的值存储在一起。与元组一样，数组的长度也是固定的。

**何时使用 (面试重点)**:
*   当你确定集合的长度**永远不会改变**时。
*   当你希望数据分配在**栈 (Stack)** 上而不是**堆 (Heap)** 上时（数组是栈分配的）。这可以带来更高的性能，因为访问速度更快。
*   例如：一周中的天数、月份名称、棋盘格子等。

**创建与访问**:
1.  使用方括号 `[]` 创建。
2.  类型签名为 `[T; N]`，其中 `T` 是元素类型，`N` 是编译时已知的长度。
3.  使用 `[]` 和索引来访问元素。

```rust
fn main() {
    // 显式声明类型和长度
    let a: [i32; 5] = [1, 2, 3, 4, 5];

    // 编译器也可以推断
    let b = [6, 7, 8];

    // 初始化一个包含 10 个相同元素的数组
    let c = [0; 10]; // c = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

    // 访问数组元素
    let first_element = a[0];
    let second_element = a[1];
    println!("First: {}, Second: {}", first_element, second_element);

    // 索引越界
    // 下面的代码会在运行时 panic，因为数组 a 只有 5 个元素（索引 0-4）
    // let invalid_element = a[10]; 
    // Rust 的这种边界检查是其内存安全的关键保证之一。
}
```
**数组 vs. 向量 (Vector)**：在实际开发中，你可能会更多地使用**向量 (`Vec<T>`)**。向量是一种可增长的、存储在堆上的集合类型。如果你的集合长度需要在运行时改变，请使用向量。我们将在后续课程中详细学习它。

### 总结

你现在已经掌握了 Rust 的基础数据类型。关键要点是：
*   **静态类型**：所有类型在编译时都必须可知。
*   **类型注解**：虽然编译器很强大，但在必要时（如函数签名、常量）需要你显式标注类型。
*   **安全性**：Rust 的类型系统设计（如 `usize` 用于索引、整型溢出检查、数组边界检查）都是为了在编译时或运行时尽早发现错误，防止未定义行为。
