我们现在来学习 Rust 中一个极其重要的概念：**结构体 (Structs)**。

如果你有其他语言的背景，可以将 `struct` 看作是 C/C++ 中的 `struct`，或者是类 (Class) 的数据部分。它允许你将多个相关的值组合在一起，形成一个有意义的、新的自定义数据类型。

---

### 1. 为什么需要 Struct？

想象一下，你想表示一个用户。一个用户有用户名、邮箱、登录次数和激活状态。在没有 `struct` 的情况下，你可能会这样做：

```rust
let username = "Alice";
let email = "alice@example.com";
let sign_in_count = 1;
let active = true;
```
这些数据是相互关联的，但代码本身并没有体现这一点。`struct` 就是用来解决这个问题的，它将这些数据打包成一个内聚的单元。

---

### 2. "C 语言风格" 的经典 Struct

这是最常见、最常用的一种结构体。它有一个名字，以及一组带名字和类型的字段 (fields)。

#### 定义 Struct

我们使用 `struct` 关键字来定义它。按照约定，`struct` 的名字使用**大驼峰命名法 (PascalCase)**。

```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
```

#### 实例化 Struct

一旦定义了 `struct`，我们就可以像使用其他数据类型一样创建它的实例。

```rust
fn main() {
    // 创建一个可变的 User 实例
    let mut user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    // 访问和修改字段 (使用点号)
    user1.email = String::from("anotheremail@example.com");

    println!("User email is: {}", user1.email);
}
```**注意**：整个实例必须是可变的 (`mut`) 才能修改其中的字段。Rust 不允许将单个字段标记为可变。

#### 实用技巧 (实战 & 面试重点)

**a) 字段初始化简写 (Field Init Shorthand)**

如果你的函数参数或局部变量与 `struct` 的字段同名，你可以使用这种简写语法，非常方便。

```rust
fn build_user(email: String, username: String) -> User {
    User {
        email, // 等同于 email: email,
        username, // 等同于 username: username,
        active: true,
        sign_in_count: 1,
    }
}
```

**b) 结构体更新语法 (Struct Update Syntax)**

当你想要基于一个旧实例创建一个新实例，并且大部分字段都相同时，这个语法非常有用。

```rust
fn main() {
    let user1 = build_user(
        String::from("user1@example.com"), 
        String::from("user1")
    );

    // user2 继承了 user1 的 active 和 sign_in_count 字段
    let user2 = User {
        email: String::from("user2@example.com"),
        ..user1 // '..' 必须在最后
    };

    // **所有权注意 (面试核心)**
    // 因为 user1 的 email 和 username 字段 (String类型) 的所有权
    // 没有被 user2 继承，而 String 类型没有实现 `Copy` trait，
    // 所以 user1 的这两个字段的所有权被移动了。
    // 此时，user1 作为一个整体不再有效。
    // println!("{}", user1.username); // 这行代码会编译失败！
}
```
如果 `user1` 的所有字段都实现了 `Copy` trait (比如都是 `i32`, `bool`)，那么 `user1` 在此之后仍然是有效的。

---

### 3. 元组结构体 (Tuple Structs)

当你希望给一个元组起一个名字，但又觉得为里面的每个字段命名过于繁琐时，元组结构体就很有用。

```rust
// 定义元组结构体
struct Color(i32, i32, i32); // RGB
struct Point(f64, f64, f64); // x, y, z

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0.0, 0.0, 0.0);

    // 访问方式和元组一样，使用点号和索引
    println!("The red value of black is: {}", black.0);

    // 也可以通过解构
    let Point(x, y, z) = origin;
    println!("The y coordinate is: {}", y);
}
```
**何时使用**: 当字段的含义清晰，无需命名时。例如，一个 `Point` 结构体，大家都知道里面的元素是坐标 `x, y, z`。

---

### 4. 单元结构体 (Unit-Like Structs)

这种结构体没有任何字段。它本身不存储任何数据，但它在你需要在一个类型上实现某些行为 (Trait) 时非常有用。

```rust
// 定义一个单元结构体
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
    // subject 变量不持有任何数据
}
```
**何时使用**: 主要用于泛型编程和 Trait 实现。例如，你可以定义一个 `Marker` 类型，它不持有数据，但它的存在本身就携带了某种类型信息。

---

### 5. 为 Struct 添加行为：方法 (Methods)

到目前为止，我们的 `struct` 只包含了数据。为了让它们能做事情，我们需要定义**方法**。这通过 **`impl`** (implementation 的缩写) 块来完成。

**核心理念 (面试重点)**: Rust 有意将 **数据定义 (`struct`)** 和 **行为定义 (`impl`)** 分开。这有助于保持代码的组织性。

#### 定义方法

方法和函数类似，但它们总是在 `impl` 块中定义，并且它们的第一个参数**永远是 `self`**，代表调用该方法的 `struct` 实例。

有三种常见的 `self`：
1.  **`&self`**: **不可变地借用**实例。用于只读操作。
2.  **`&mut self`**: **可变地借用**实例。用于修改实例的字段。
3.  **`self`**: **获取**实例的**所有权**。用于消耗实例的操作。

**示例：`Rectangle`**
```rust
#[derive(Debug)] // 稍后解释这个
struct Rectangle {
    width: u32,
    height: u32,
}

// 在 impl 块中为 Rectangle 定义方法
impl Rectangle {
    // 方法 1: 使用 &self，只读取数据
    fn area(&self) -> u32 {
        self.width * self.height
    }

    // 方法 2: 也可以使用 &self，进行判断
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }

    // 方法 3: 使用 &mut self，修改自身数据
    fn scale(&mut self, factor: f64) {
        self.width = (self.width as f64 * factor) as u32;
        self.height = (self.height as f64 * factor) as u32;
    }
}

fn main() {
    let mut rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 10, height: 40 };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area() // Rust 的自动引用和解引用: rect1.area() 等同于 (&rect1).area()
    );

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    
    rect1.scale(1.5);
    println!("After scaling, rect1 is: {:?}", rect1);
}
```

---

### 6. 关联函数 (Associated Functions)

`impl` 块中还可以定义**不**以 `self` 作为第一个参数的函数。这些被称为**关联函数**，因为它们与 `struct` 相关联，但它们不是方法（因为它们不操作实例）。

最常见的关联函数是**构造函数 (constructors)**，在 Rust 中通常命名为 `new`。

```rust
impl Rectangle {
    // 这是一个关联函数，因为它没有 &self 参数
    // 通常用作构造函数
    fn new(width: u32, height: u32) -> Self { // `Self` 是 impl 块对应类型的别名，即 Rectangle
        Self { width, height }
    }

    // 另一个例子：创建一个正方形
    fn square(size: u32) -> Self {
        Self { width: size, height: size }
    }
}

fn main() {
    // 使用 `::` 语法调用关联函数
    let rect_from_new = Rectangle::new(20, 40);
    let square = Rectangle::square(25);
}
```

### 7. 派生 Trait (Derived Traits)

你可能注意到了 `#[derive(Debug)]`。这是 Rust 的一个强大特性。默认情况下，你的自定义 `struct` 很多基本操作都做不了，比如打印出来看。

通过 `derive` 属性，你可以让编译器自动为你的 `struct` 实现一些通用的、标准化的行为 (Traits)。

**最常用的派生 Trait (实战必备)**:
*   `#[derive(Debug)]`: 允许你使用 `{:?}` 或 `{:#?}` (美化) 格式化打印 `struct`，用于调试。
*   `#[derive(Clone, Copy)]`: 允许 `struct` 被复制。`Copy` 要求所有字段本身也是 `Copy` 类型（如 `i32`, `bool`，但不包括 `String`）。
*   `#[derive(PartialEq, Eq, PartialOrd, Ord)]`: 实现比较操作符 (`==`, `!=`, `<`, `>` 等)。
*   `#[derive(Default)]`: 为 `struct` 提供一个默认值。

```rust
#[derive(Debug, Clone, Copy, PartialEq)]
struct Point2D {
    x: f32,
    y: f32,
}

fn main() {
    let p1 = Point2D { x: 1.0, y: 2.0 };
    let p2 = p1.clone(); // 因为实现了 Clone，所以可以克隆

    // 因为实现了 Debug，所以可以打印
    println!("Point p1 is: {:?}", p1);

    // 因为实现了 PartialEq，所以可以比较
    if p1 == p2 {
        println!("p1 and p2 are equal!");
    }
}
```

### 总结

*   **Structs** 是你创建自定义数据类型的核心工具，用于将相关数据捆绑在一起。
*   **`impl`** 块用于为 `struct` 添加行为，实现数据和逻辑的分离。
*   **方法** 的第一个参数是 `self`, `&self`, 或 `&mut self`，用于操作实例。
*   **关联函数** 没有 `self` 参数，通常用作构造函数 (如 `::new()`)。
*   **`#[derive]`** 是你的好朋友，能为你自动实现许多有用的标准行为。
