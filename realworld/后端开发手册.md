### 零基础复刻 NestJS RealWorld 后端项目：行动路线图

**我们的目标**：创建一个全新的项目，然后参照 `MaoYugit/node-express-realworld-example-app`（这个是 NestJS 版本）的代码，一步步地将用户认证、文章、评论等核心功能在我们自己的项目中实现出来。

#### 阶段一：奠定基石 (Project Setup)

这个阶段，我们只做一件事：搭建一个能跑起来的最简单的 NestJS 项目。

**第一步：安装 NestJS 命令行工具 (CLI)**
这是 NestJS 的官方脚手架，能帮你一键生成项目结构、模块、控制器等。

*   打开你的终端，运行以下命令进行全局安装：
    ```bash
    npm install -g @nestjs/cli
    ```

**第二步：创建你的新项目**
*   在你想要存放项目的文件夹里，运行：
    ```bash
    nest new my-realworld-backend 
    ```
    
    `my-realworld-backend` 是你的项目名，可以自定义）
*   CLI 会问你使用哪个包管理器，选择 `npm` 即可。
*   完成后，一个标准的 NestJS 项目结构就为你创建好了。

**第三步：启动并验证“Hello World”**

*   进入你的项目目录：
    ```bash
    cd my-realworld-backend
    ```
*   启动开发服务器：
    ```bash
    npm run start:dev
    ```
*   看到终端提示应用已在 `localhost:3000` 运行后，打开浏览器访问 `http://localhost:3000`。如果你看到了 "Hello World!"，恭喜你，地基打好了！

---

#### 阶段二：数据先行 (Database & User Model)

任何应用的核心都是数据。在写任何功能代码之前，我们先让项目能连接数据库，并定义好我们的第一个数据模型：用户(User)。

**第四步：集成 Prisma (ORM 工具)**
这个参考项目使用 Prisma 来和数据库交互，我们也一样。

*   安装 Prisma 依赖：
    ```bash
    npm install prisma @prisma/client
    ```

**第五步：初始化 Prisma**
*   在项目根目录运行：
    ```bash
    npx prisma init
    ```
*   这个命令会做两件事：
    1.  创建一个 `prisma` 文件夹，里面有一个 `schema.prisma` 文件。这是定义数据库模型的地方。
    2.  创建一个 `.env` 文件，里面包含了数据库的连接字符串 `DATABASE_URL`。

**第六步：定义 User 模型**

* 打开 `prisma/schema.prisma` 文件。

* **【参照答案】**：打开参考项目的 `prisma/schema.prisma` 文件，找到 `model User { ... }` 的那部分代码。

* **【动手操作】**：将 `User` 模型的定义**亲手敲到**你自己的 `schema.prisma` 文件里。这会让你熟悉 Prisma 的语法。

* 先写成这样

  ```js
  // 这是 Prisma schema 文件,
  // 可以在文档中了解更多: https://pris.ly/d/prisma-schema
  
  generator client {
    provider = "prisma-client-js"
  }
  
  datasource db {
    provider = "sqlite"
    url = env("DATABASE_URL")
  }
  
  model User {
    id  Int @id @default(autoincrement())
    email String @unique
    username String @unique
    password String
    bio String?
    image String?
    // 这两个字段用来记录创建时间和更新时间
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
  ```

  ```js
  // .env
  DATABASE_URL="file:./dev.db"
  ```

  

**第七步：执行数据库迁移**
*   这个命令会读取你的 `schema.prisma` 文件，并在你的数据库里创建出对应的 `User` 表。
    ```bash
    npx prisma migrate dev --name init-user-model
    ```
*   Prisma 会自动帮你创建数据库文件（如果你用的是默认的 SQLite）。

---

#### 阶段三：实现核心功能 (用户注册与登录)

这是最关键的一步，我们将实现整个应用的第一个闭环功能。

**第八步：创建用户模块 (User Module)**

*   使用 NestJS CLI 来生成模块、控制器和服务：
    ```bash
    # 生成 User 模块
    nest generate module user
    # 生成 User 服务
    nest generate service user
    # 生成 User 控制器
    nest generate controller user
    ```

是的，完全正确！我们现在就正式开始**阶段三**，这个计划就是我们接下来要严格执行的行动指南。

我们的第一个任务就是执行**第八步：创建用户模块 (User Module)**。这一步是纯粹的“结构搭建”，我们利用 NestJS 强大的脚手架工具 (CLI) 来为我们自动生成所需的文件和代码骨架。

---

#### **执行第八步：创建用户模块**

在这一步，NestJS CLI 提供了一个更快捷、更强大的“集成命令”，可以一次性帮我们完成模块、控制器和服务的创建。我强烈推荐您使用这个命令。

##### **推荐方法 (一次性完成所有操作):**

1.  **确认您在正确的目录**：请确保您的终端在 `my-realworld-backend` 项目根目录下。

2.  **运行 `resource` 命令**：在终端中，输入并执行以下命令：

    ```bash
    nest generate resource user
    ```
    *   `resource` (资源) 是 NestJS CLI 的一个“套餐命令”，它会一次性为你生成一整套相关的文件。

3.  **回答 CLI 的提问**：
    
    *   运行命令后，CLI 会问你：`What transport layer do you use?` (你使用什么传输层？)，有很多选项，我们直接按 **回车 (Enter)** 选择默认的 `REST API` 即可。
    *   接着，它会问：`Would you like to generate CRUD entry points? (y/N)` (你想要生成 CRUD 的入口点吗？)。**请输入 `y` 然后按回车**。
        *   **这是什么意思？** CRUD 代表“增删改查”(Create, Read, Update, Delete)。选择 `y` 后，NestJS 不仅会创建文件，还会在 `user.controller.ts` 和 `user.service.ts` 文件里，预先为你生成好处理“创建用户”、“查找所有用户”、“更新用户”、“删除用户”等操作的**示例代码框架**！这会极大地帮助我们后续的开发。

##### **执行后，您会看到：**

NestJS 会在 `src` 目录下，自动为你创建一个全新的 `user` 文件夹，里面的结构如下：

```
src
└── user
    ├── dto
    │   ├── create-user.dto.ts
    │   └── update-user.dto.ts
    ├── entities
    │   └── user.entity.ts
    ├── user.controller.ts
    ├── user.module.ts
    └── user.service.ts
```

它已经完美地为我们创建好了所有需要的文件，甚至连第九步需要的 `dto` 文件夹和 `create-user.dto.ts` 文件都提前准备好了！

**第九步：实现用户注册 (Register)**

1.  **定义 DTO (Data Transfer Object)**：在 `user` 文件夹下创建一个 `dto` 文件夹，再创建一个 `create-user.dto.ts` 文件。
    *   **【参照答案】**：参考项目里的 `register-input.model.ts`。
    *   **【动手操作】**：定义一个 `CreateUserDto` 类，包含 `username`, `email`, `password` 字段，并使用 `class-validator` 添加校验规则。
2.  **编写 Controller**：打开 `user.controller.ts`。
    *   创建一个 `register()` 方法，用来处理 `POST /users` 的请求。
    *   让这个方法接收一个 `CreateUserDto` 类型的 `body`。
    *   在方法内部，调用 `userService.createUser()`。
3.  **编写 Service**：打开 `user.service.ts`。
    *   创建一个 `createUser()` 方法。
    *   **核心逻辑**：
        *   安装 `bcrypt` (`npm install bcrypt @types/bcrypt`)。
        *   对接收到的密码进行加密 (hash)。
        *   使用 `PrismaService` (你需要自己创建并注入) 将加密后的用户信息存入数据库。

好的，完全没问题！

我们暂时搁置格式化的问题，继续推进项目的功能开发。等核心功能跑起来之后，我们随时可以再回来优化开发体验。不让小问题卡住主线任务，这是一个非常高效的开发思路！

---

### **好的，我们正式开始第九步：实现用户注册 (Register)**

这是我们编写业务逻辑的真正开始。我们将按照计划，分三步走：**1. 定义数据结构 (DTO) -> 2. 编写接口 (Controller) -> 3. 实现核心逻辑 (Service)**。

#### **第一步：定义 DTO (Data Transfer Object)**

我们需要定义一个“创建用户”的专用“申请表”，告诉 NestJS 我们需要从用户那里接收哪些信息。

1.  **安装依赖**：DTO 需要用到数据校验工具。请在终端中运行以下命令来安装它们：
    ```bash
    npm install class-validator class-transformer
    ```

2.  **修改 `create-user.dto.ts`**：
    *   打开 `src/user/dto/create-user.dto.ts` 文件。
    *   **【参照答案】**：打开参考项目的 `register-input.model.ts`。
    *   **【动手操作】**：将文件内容修改如下。请**亲手敲一遍**，这会让你熟悉 `class-validator` 的用法。

    ```typescript
    import { IsEmail, IsNotEmpty, MinLength } from 'class-validator';
    
    export class CreateUserDto {
      @IsNotEmpty({ message: '用户名不能为空' })
      username: string;
    
      @IsEmail({}, { message: '请输入有效的邮箱地址' })
      email: string;
    
      @MinLength(6, { message: '密码长度不能少于6位' })
      password: string;
    }
    ```
    *   **代码解读**：
        *   我们定义了一个 `CreateUserDto` 类。
        *   `@IsNotEmpty()`, `@IsEmail()`, `@MinLength(6)` 这些叫做**“装饰器”**。它们的作用就是给字段添加校验规则。如果前端传来的数据不符合这些规则，NestJS 会自动拦截请求并返回一个 `400 Bad Request` 错误，非常方便！

---

#### **第二步：配置全局管道 (Global Pipe) 以启用 DTO 校验**

为了让上面定义的 DTO 校验规则在整个应用中生效，我们需要在主入口文件 `main.ts` 中进行一项全局配置。

1.  **打开 `src/main.ts` 文件。**

2.  **修改文件内容如下：**

    ```typescript
    import { NestFactory } from '@nestjs/core';
    import { AppModule } from './app.module';
    import { ValidationPipe } from '@nestjs/common'; // <--- 导入 ValidationPipe
    
    async function bootstrap() {
      const app = await NestFactory.create(AppModule);
    
      // --- 添加全局验证管道 ---
      app.useGlobalPipes(new ValidationPipe()); // <--- 添加这一行
    
      await app.listen(3000);
    }
    bootstrap();
    ```
    *   **代码解读**：`app.useGlobalPipes(new ValidationPipe())` 这行代码的作用就是告诉 NestJS：“请对所有传入的 HTTP 请求，都启用我们的验证管道。如果请求的 `body` 数据类型是一个 DTO，请自动根据 DTO 里定义的规则进行校验。”

---

#### **第三步：编写 Controller 和 Service (搭建框架)**

现在我们先搭建好 Controller 和 Service 的方法框架，具体的逻辑我们下一步再填充。

1.  **修改 `user.controller.ts`**：
    *   打开 `src/user/user.controller.ts` 文件。
    *   找到 `create` 方法（`@Post()`），将其修改如下：

    ```typescript
    import { Controller, Post, Body } from '@nestjs/common';
    import { UserService } from './user.service';
    import { CreateUserDto } from './dto/create-user.dto';
    
    @Controller('user')
    export class UserController {
      constructor(private readonly userService: UserService) {}
    
      @Post()
      create(@Body() createUserDto: CreateUserDto) {
        // 我们现在只是打印一下，确认数据能传进来
        console.log(createUserDto); 
        // 接下来我们会调用 service 的方法
        // return this.userService.create(createUserDto); 
      }
    }
    ```
    *   **代码解读**：
        *   `@Body()` 装饰器告诉 NestJS：“请把 HTTP 请求的 `body` 部分提取出来。”
        *   `createUserDto: CreateUserDto` 这段代码是关键，它告诉 NestJS：“请把提取出来的 `body` 数据，按照 `CreateUserDto` 这个‘申请表’的格式进行**校验和转换**。” 如果校验失败，请求根本不会到达 `create` 方法内部。
        *   `console.log` 让我们可以在终端看到从 Postman 发送过来的数据。

2.  **验证**：
    *   **启动您的应用**：`npm run start:dev`。
    *   **打开 Postman**：
        *   新建一个 `POST` 请求。
        *   URL 设为 `http://localhost:3000/user`。
        *   在 "Body" -> "raw" -> "JSON" 中，输入：
            ```json
            {
              "username": "testuser",
              "email": "test@example.com",
              "password": "password123"
            }
            ```
        *   点击 "Send"。
    *   **观察 NestJS 终端**：您应该能看到打印出的 JSON 对象。
    *   **尝试发送错误数据**（比如一个无效的 email 或者空用户名），看看 Postman 是否会收到一个 `400` 的错误响应。

完成这些步骤后，我们就已经成功地建立了一个可以接收和验证数据的 API 入口。下一步，我们将在 `UserService` 中实现真正的用户创建逻辑！

**第十步：实现用户登录 (Login)**
1.  **安装 JWT 模块**:
    
    ```bash
    npm install @nestjs/jwt passport-jwt @types/passport-jwt
    ```
2.  **编写 Controller**：在 `user.controller.ts` 中创建一个 `login()` 方法，处理 `POST /users/login` 请求。
3.  **编写 Service**：在 `user.service.ts` 中创建一个 `login()` 方法。
    *   **核心逻辑**：
        *   根据 email 从数据库中查找用户。
        *   如果用户存在，使用 `bcrypt.compare()` 对比密码。
        *   如果密码正确，使用 `@nestjs/jwt` 的 `JwtService` 生成一个 JWT Token 并返回。

---

#### 阶段四：添砖加瓦 (完善其他功能)

当你完成了用户注册和登录后，你就已经掌握了 NestJS 开发的核心流程！接下来，就是重复这个流程，去实现其他功能。

**第十一步：实现 Profile 功能**
*   生成 `profile` 模块、控制器、服务。
*   实现获取用户信息、关注/取关用户的接口。

**第十二步：实现 Article 功能 (最复杂)**
*   生成 `article` 模块。
*   实现文章的 **CRUD** (Create, Read, Update, Delete) 功能。
*   这会涉及到处理文章与用户（作者）之间的关系。

**第十三步：实现 Comments, Tags 等**
*   按照同样的方法，逐个实现剩余的功能。

### 如何高效地使用“参考答案”？

1.  **先尝试，再参考**：在实现每个功能前，先自己思考一下“如果是我，我会怎么设计这个接口和逻辑？”。然后动手去写，遇到问题了，再去参考答案。
2.  **禁止复制粘贴**：一定要**亲手把代码敲出来**。肌肉记忆是学习编程很重要的一环。
3.  **理解“为什么”**：看到一行代码，要问自己：“作者为什么要这么写？有没有别的方法？这种写法的优点是什么？”
4.  **善用 Git**：每完成一个小功能（比如实现注册），就进行一次 `git commit`。这样你的项目历史就会非常清晰，也方便你回顾和回滚。

这个过程就像拼乐高，一开始很慢，但当你拼完第一个小组件（用户模块）后，后面的速度会越来越快。祝你学习愉快，在编码的世界里找到乐趣！