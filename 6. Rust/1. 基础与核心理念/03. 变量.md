变量是任何编程语言的基石，而 Rust 对待变量的方式是其**安全性和高性能**理念的第一个集中体现。

### 核心原则：默认不可变 (Immutable by Default)

在绝大多数编程语言中，当你声明一个变量后，你可以随时改变它的值。Rust 反其道而行之：**变量一旦绑定了值，默认情况下就不能再改变**。

这个设计决策是经过深思熟虑的，旨在从根本上提升代码的安全性和可预测性。

*   **安全性**：防止你代码的某一部分意外地修改了另一部分依赖的值，这类 bug 在大型或并发程序中极难追踪。
*   **并发性**：如果数据不能被随意改变，那么在多线程之间共享数据就变得简单得多，极大地减少了数据竞争的风险。
*   **易于推理**：当你看到一个变量时，你可以在大脑中确信它的值不会在你不知道的情况下发生变化，让代码逻辑更清晰。

#### 示例：不可变变量

使用 `let` 关键字来声明变量。

```rust
fn main() {
    // 声明一个不可变的变量 'x' 并绑定值 5
    let x = 5;
    println!("The value of x is: {}", x);

    // 尝试改变 'x' 的值，这会导致编译错误！
    // x = 6; // 取消这行代码的注释，然后运行 `cargo run`
    
    println!("The value of x is now: {}", x);
}
```

如果你尝试编译以上代码（取消注释后），编译器会立刻报错，并给出清晰的提示：`cannot assign twice to immutable variable x`。它甚至会友好地建议你：“`help: consider making this binding mutable: `mut x`”。

### 需要改变时：使用 `mut` 关键字

当然，我们总是需要可以改变状态的变量。Rust 提供了 `mut` (mutable的缩写) 关键字来让你**显式地**选择可变性。

通过在变量名前添加 `mut`，你就向自己和代码的后续阅读者明确表示：“这个变量的值在未来是会改变的”。

#### 示例：可变变量

```rust
fn main() {
    // 声明一个可变的变量 'y'
    let mut y = 10;
    println!("The initial value of y is: {}", y);

    // 因为 'y' 是可变的，所以这次赋值是完全合法的
    y = 20;

    println!("The new value of y is: {}", y);
}
```
**实战思考**：在实际开发中，应始终优先使用不可变变量。只有当你确定一个变量的状态必须改变时（例如，循环中的计数器、累加器），才使用 `mut`。这是一种编程纪律，也是 Rust 鼓励的思维方式。

### 隐藏 (Shadowing)：一个强大且独特的特性

Rust 有一个叫做“隐藏”的特性，它常常让初学者与 `mut` 混淆，但它们是完全不同的概念。

隐藏允许我们使用 `let` 关键字**重新声明**一个同名的新变量。这个新变量会“隐藏”掉前一个变量，在当前作用域的剩余部分，该变量名指向的是这个新变量。

#### 示例：隐藏

```rust
fn main() {
    let spaces = "   "; // spaces 是一个字符串切片
    
    // 使用隐藏，重新声明 spaces，并绑定一个新的值
    // 注意，我们改变了变量的类型！从 &str 变成了 usize
    let spaces = spaces.len(); // spaces 现在是一个数字

    println!("The number of spaces is: {}", spaces);
}
```

### `mut` 与 `Shadowing` 的核心区别（面试重点）

这是面试中几乎必问的问题，因为它直接反映了你是否理解 Rust 的核心设计。

| 特性         | `let mut` (可变性)                   | `let` (隐藏)                                     |
| :----------- | :----------------------------------- | :----------------------------------------------- |
| **操作**     | 改变**同一个**内存地址上存储的**值** | 创建一个**全新的**变量，只是恰好使用了相同的名字 |
| **类型**     | **不能**改变变量的类型               | **可以**改变变量的类型，这是其最强大的用途之一   |
| **不可变性** | 变量在声明后一直是可变的             | 新变量本身是不可变的（除非也用了 `let mut`）     |

#### 示例对比

```rust
fn main() {
    // 使用 mut
    let mut a = "initial value";
    println!("a is: {}", a);
    // a = 123; // 编译错误！因为 a 的类型是 &str，不能赋值为整数
    a = "new value"; // 正确，值改变，类型不变
    println!("a is now: {}", a);

    // 使用 shadowing
    let b = "initial value";
    println!("b is: {}", b);
    let b = 123; // 完全正确！b 现在是一个全新的 i32 类型变量
    println!("b is now: {}", b);
}
```

**实战场景**：当你需要对一个值进行一系列转换，但又不希望这个值在转换完成后还能被修改时，隐藏非常有用。比如，你从用户输入中读取一个字符串，然后想把它转换成数字。使用隐藏可以让你重用变量名，使代码更简洁。

### 常量 (Constants)

常量与不可变变量类似，但有更严格的规定。它们用于程序中硬编码的、永远不会改变的值。

*   使用 `const` 关键字声明，并且**必须**显式注明类型。
*   命名约定是**全部大写，并用下划线分隔** (SCREAMING_SNAKE_CASE)。
*   只能被设置为常量表达式，不能是函数调用或任何只能在运行时计算出的值。
*   可以在任何作用域中声明，包括全局作用域。

#### 示例：常量

```rust
// 在全局作用域声明一个常量
const MAX_LOGIN_ATTEMPTS: u32 = 3;

fn main() {
    println!("Maximum login attempts allowed: {}", MAX_LOGIN_ATTEMPTS);
}
```

### `const` 与 `let` (不可变) 的区别 (面试重点)

| 特性         | `const` (常量)                           | `let` (不可变变量)                          |
| :----------- | :--------------------------------------- | :------------------------------------------ |
| **可变性**   | 永远不可变，不能与 `mut` 一起使用        | 默认不可变，但可以在声明时与 `mut` 结合使用 |
| **类型注解** | **必须**注明类型                         | 通常可以由编译器进行类型推断，非必需        |
| **求值时机** | 在**编译时**求值，值会被直接内联到代码中 | 在**运行时**求值，值存储在内存中            |
| **作用域**   | 可以在任何作用域声明，包括全局作用域     | 只能在函数内部等作用域中声明                |

---

### 命名约定

最后，良好的代码风格很重要。Rust 社区有统一的命名约定：

*   **变量和函数名**：使用蛇形命名法 (`snake_case`)，即全小写，单词间用下划线分隔。
    *   `let user_name = "Alice";`
    *   `fn calculate_score() {}`
*   **常量名**：使用尖叫蛇形命名法 (`SCREAMING_SNAKE_CASE`)，即全大写，单词间用下划线分隔。
    *   `const SECONDS_IN_HOUR: u32 = 3600;`
