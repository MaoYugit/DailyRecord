好的，我们继续学习。在掌握了通用树结构和二叉搜索树之后，我们将焦点转向一种特殊的、非常高效的树形结构——堆。堆在实现优先队列和堆排序等算法中扮演着至关重要的角色。

---

### **第八章：堆 (Heaps)**

堆常常与“优先队列”这一抽象数据类型联系在一起。虽然名字里有“堆”，但它与内存管理中的“堆内存”是完全不同的两个概念。

#### **8.1 堆的定义：特殊的完全二叉树**

**定义**：堆 (Heap) 是一种基于树的特殊数据结构，它首先必须是一个**完全二叉树 (Complete Binary Tree)**，并且满足**堆属性 (Heap Property)**。

让我们分解这个定义：

1.  **完全二叉树 (Complete Binary Tree)**：回顾第七章，完全二叉树是指一棵二叉树，除了最底层之外，其他各层都被完全填满，并且最底层的节点都尽可能地靠左排列。这个结构特性非常重要，因为它使得我们可以用**数组**来高效地表示堆，而无需使用指针和节点对象。

    **用数组表示完全二叉树**:
    *   我们将树的节点按层序遍历的顺序存入一个数组中。
    *   对于数组中索引为 `i` 的节点：
        *   其父节点的索引是 `floor((i - 1) / 2)`
        *   其左子节点的索引是 `2 * i + 1`
        *   其右子节点的索引是 `2 * i + 2`
    *   这种表示法消除了指针的开销，并利用了数组的缓存友好性。

2.  **堆属性 (Heap Property)**：这是堆的核心逻辑规则，它规定了父节点与子节点之间的值的大小关系。堆属性有两种形式：

#### **8.2 最大堆 (Max-Heap) 与最小堆 (Min-Heap) 的性质**

1.  **最大堆 (Max-Heap)**：
    *   **属性**：对于堆中的任意节点 `i`，其值 `A[i]` 必须**大于或等于**其所有子节点的值。
    *   **推论**：堆的根节点（数组的第一个元素 `A[0]`）必然是整个堆中的**最大值**。

    ```
        100
       /   \
      19    36
     / \   / \
    17  3 25  1
    / \
   2   7
    
    Array: [100, 19, 36, 17, 3, 25, 1, 2, 7]
   ```

2.  **最小堆 (Min-Heap)**：
    *   **属性**：对于堆中的任意节点 `i`，其值 `A[i]` 必须**小于或等于**其所有子节点的值。
    *   **推论**：堆的根节点（数组的第一个元素 `A[0]`）必然是整个堆中的**最小值**。

    ```
          1
         / \
        2   3
       / \ / \
      17 19 36 7
     / \
    25 100
    
    Array: [1, 2, 3, 17, 19, 36, 7, 25, 100]
    ```
    **重要提示**：堆属性只保证了父子节点间的关系，它**不保证**兄弟节点之间或同一层不同子树节点之间的大小关系。例如，在上面的最大堆中，`19` 比 `36` 小，这是完全允许的。因此，堆**不是**一个完全排序的结构。

---

#### **8.3 堆的核心操作：插入 (heapify-up) 与删除/提取 (heapify-down)**

为了维护堆属性，堆的插入和删除操作都涉及到一系列的调整，这些调整被称为“堆化 (heapify)”。

##### **插入 (Insertion)**

插入操作总是将新元素添加到堆的末尾，然后通过一个称为“上浮 (sift-up / heapify-up)”的过程来恢复堆属性。我们以最小堆为例：

1.  **添加到末尾**：将新元素添加到数组的末尾（即完全二叉树的下一个可用位置）。这保持了完全二叉树的结构。
2.  **上浮 (Sift-up)**：
    a. 比较新添加的节点与其父节点。
    b. 如果新节点的值**小于**其父节点的值（违反了最小堆属性），则将它们**交换**。
    c. 重复此过程，让该节点不断“上浮”，直到它不再小于其父节点，或者它已经到达了根的位置。

*   **复杂度**：由于完全二叉树的高度为 O(log n)，上浮过程最多需要交换 `log n` 次。因此，插入操作的时间复杂度为 **O(log n)**。

##### **提取根节点 (Extract-Min / Extract-Max)**

在最小堆中，提取最小值（即根节点）的操作是堆最常用的功能。这个操作通过一个称为“下沉 (sift-down / heapify-down)”的过程来完成。

1.  **保存并替换**：
    a. 保存根节点（数组的第一个元素）的值，这是我们要返回的最小值。
    b. 将数组的**最后一个元素**移动到根的位置。这破坏了堆属性，但保持了完全二叉树的结构。
2.  **下沉 (Sift-down)**：
    a. 比较新的根节点与其子节点。
    b. 从它的左、右子节点中，找出**值较小**的那个。
    c. 如果新的根节点的值**大于**这个较小的子节点（违反了最小堆属性），则将它们**交换**。
    d. 重复此过程，让该节点不断“下沉”，直到它的值小于或等于其所有子节点，或者它已成为叶子节点。

*   **复杂度**：与插入类似，下沉过程最多需要交换 `log n` 次。因此，提取根节点操作的时间复杂度为 **O(log n)**。

---

#### **8.4 基于数组的堆实现**

我们将从零开始，用数组实现一个最小堆。

##### **Python 实现**

```python
class MinHeap:
    """
    基于数组实现的最小堆。
    """
    def __init__(self):
        self._heap = []

    def _get_parent_index(self, i):
        return (i - 1) // 2

    def _get_left_child_index(self, i):
        return 2 * i + 1

    def _get_right_child_index(self, i):
        return 2 * i + 2

    def _has_parent(self, i):
        return self._get_parent_index(i) >= 0

    def _has_left_child(self, i):
        return self._get_left_child_index(i) < len(self._heap)

    def _has_right_child(self, i):
        return self._get_right_child_index(i) < len(self._heap)

    def _swap(self, i, j):
        self._heap[i], self._heap[j] = self._heap[j], self._heap[i]

    def _sift_up(self):
        """上浮操作，用于插入"""
        index = len(self._heap) - 1
        while self._has_parent(index) and self._heap[index] < self._heap[self._get_parent_index(index)]:
            parent_index = self._get_parent_index(index)
            self._swap(index, parent_index)
            index = parent_index

    def _sift_down(self):
        """下沉操作，用于提取根"""
        index = 0
        while self._has_left_child(index):
            smaller_child_index = self._get_left_child_index(index)
            if self._has_right_child(index) and self._heap[self._get_right_child_index(index)] < self._heap[smaller_child_index]:
                smaller_child_index = self._get_right_child_index(index)

            if self._heap[index] < self._heap[smaller_child_index]:
                break
            else:
                self._swap(index, smaller_child_index)
            
            index = smaller_child_index

    def insert(self, value):
        """
        向堆中插入一个新值。
        时间复杂度: O(log n)
        """
        self._heap.append(value)
        self._sift_up()

    def extract_min(self):
        """
        提取并返回堆中的最小值（根）。
        时间复杂度: O(log n)
        """
        if not self._heap:
            raise IndexError("extract_min from an empty heap")
        
        if len(self._heap) == 1:
            return self._heap.pop()

        min_value = self._heap[0]
        self._heap[0] = self._heap.pop() # 用最后一个元素替换根
        self._sift_down()
        return min_value

    def peek(self):
        """
        查看最小值，不提取。
        时间复杂度: O(1)
        """
        if not self._heap:
            return None
        return self._heap[0]

# --- 使用示例 ---
min_heap = MinHeap()
min_heap.insert(5)
min_heap.insert(3)
min_heap.insert(8)
min_heap.insert(1)
min_heap.insert(10)
# 内部数组此时应为 [1, 3, 8, 5, 10] (或类似，取决于实现细节)

print(f"Min value: {min_heap.peek()}") # 1
print(f"Extracted: {min_heap.extract_min()}") # 1
print(f"New min value: {min_heap.peek()}") # 3
print(f"Extracted: {min_heap.extract_min()}") # 3
print(f"New min value: {min_heap.peek()}") # 5
```

##### **JavaScript 实现**

```javascript
class MinHeap {
    /**
     * 基于数组实现的最小堆。
     */
    constructor() {
        this._heap = [];
    }

    _getParentIndex(i) { return Math.floor((i - 1) / 2); }
    _getLeftChildIndex(i) { return 2 * i + 1; }
    _getRightChildIndex(i) { return 2 * i + 2; }

    _hasParent(i) { return this._getParentIndex(i) >= 0; }
    _hasLeftChild(i) { return this._getLeftChildIndex(i) < this._heap.length; }
    _hasRightChild(i) { return this._getRightChildIndex(i) < this._heap.length; }

    _swap(i, j) {
        [this._heap[i], this._heap[j]] = [this._heap[j], this._heap[i]];
    }

    _siftUp() {
        let index = this._heap.length - 1;
        while (this._hasParent(index) && this._heap[index] < this._heap[this._getParentIndex(index)]) {
            const parentIndex = this._getParentIndex(index);
            this._swap(index, parentIndex);
            index = parentIndex;
        }
    }

    _siftDown() {
        let index = 0;
        while (this._hasLeftChild(index)) {
            let smallerChildIndex = this._getLeftChildIndex(index);
            if (this._hasRightChild(index) && this._heap[this._getRightChildIndex(index)] < this._heap[smallerChildIndex]) {
                smallerChildIndex = this._getRightChildIndex(index);
            }

            if (this._heap[index] < this._heap[smallerChildIndex]) {
                break;
            } else {
                this._swap(index, smallerChildIndex);
            }
            index = smallerChildIndex;
        }
    }

    /**
     * 向堆中插入一个新值。
     * 时间复杂度: O(log n)
     */
    insert(value) {
        this._heap.push(value);
        this._siftUp();
    }

    /**
     * 提取并返回堆中的最小值（根）。
     * 时间复杂度: O(log n)
     */
    extractMin() {
        if (this._heap.length === 0) {
            throw new Error("extractMin from an empty heap");
        }
        if (this._heap.length === 1) {
            return this._heap.pop();
        }

        const minValue = this._heap[0];
        this._heap[0] = this._heap.pop();
        this._siftDown();
        return minValue;
    }
    
    /**
     * 查看最小值，不提取。
     * 时间复杂度: O(1)
     */
    peek() {
        return this._heap.length === 0 ? null : this._heap[0];
    }
}

// --- 使用示例 ---
const minHeap = new MinHeap();
minHeap.insert(5);
minHeap.insert(3);
minHeap.insert(8);
minHeap.insert(1);
minHeap.insert(10);

console.log(`Min value: ${minHeap.peek()}`); // 1
console.log(`Extracted: ${minHeap.extractMin()}`); // 1
console.log(`New min value: ${minHeap.peek()}`); // 3
console.log(`Extracted: ${minHeap.extractMin()}`); // 3
console.log(`New min value: ${minHeap.peek()}`); // 5
```
*(注：Python 的 `heapq` 模块提供了高效的最小堆实现。)*

---

#### **8.5 堆排序 (Heap Sort)**

堆排序是一种高效的、基于比较的排序算法。它利用了堆的特性。

**算法步骤**：
1.  **建堆 (Build Heap)**：将一个无序的数组原地转换成一个最大堆。这可以通过从最后一个非叶子节点开始，向前对每个节点执行 `sift-down` 操作来高效完成。这个过程的时间复杂度是 **O(n)**，而非 O(n log n)。
2.  **排序 (Sort Down)**：
    a. 将堆顶元素（最大值）与堆的最后一个元素交换。此时，数组的末尾就是已排序好的最大元素。
    b. 将堆的大小减一，并将新的堆顶元素执行 `sift-down` 操作，以恢复最大堆的属性。
    c. 重复此过程，直到堆的大小变为 1。

**性能分析**：
*   **时间复杂度**：建堆是 O(n)，之后进行 `n-1` 次 `extract-max` 操作（每次都是 O(log n)）。所以总时间复杂度是 O(n) + O(n log n) = **O(n log n)**。
*   **空间复杂度**：它是一个原地排序算法，只需要常数级别的额外空间，即 **O(1)**。

#### **8.6 应用：优先队列 (Priority Queue)**

优先队列是一种抽象数据类型，它像普通队列一样可以存取数据，但每个元素都有一个关联的“优先级”。当从优先队列中 `dequeue` 时，总是优先级最高的元素先出队（而不是最早入队的元素）。

**实现**：
*   **堆是实现优先队列最理想的数据结构**。
*   如果需要“最大值优先”，就使用最大堆。`insert` 对应堆的 `insert`，`extract-max` 对应 `extract_max`。
*   如果需要“最小值优先”，就使用最小堆。`insert` 对应堆的 `insert`，`extract-min` 对应 `extract_min`。

由于堆的 `insert` 和 `extract` 操作都是 O(log n)，因此基于堆实现的优先队列，其入队和出队操作的复杂度也都是 **O(log n)**。

**其他应用**：
*   在图算法中（如 Dijkstra 算法和 Prim 算法）用于高效地找到下一个要处理的、具有最小权重的顶点或边。
*   在操作系统中用于任务调度。
*   任何需要动态地、高效地找到一个集合中的最大/最小值并处理它的场景。

**本章小结:**

*   你掌握了堆是基于**完全二叉树**并满足**堆属性**的特殊数据结构。
*   你理解了**最大堆**和**最小堆**的区别及其核心性质。
*   你学会了用**数组**来高效表示堆，并能进行父子索引的计算。
*   你深刻理解并能实现堆的核心操作：基于**上浮 (sift-up)** 的插入和基于**下沉 (sift-down)** 的提取，时间复杂度均为 **O(log n)**。
*   你了解了**堆排序**的原理，以及**优先队列**这一重要 ADT 是如何通过堆来高效实现的。

我们已经完成了对主要树形结构的探讨。接下来，我们将进入本课程最后一个主要的数据结构类型，也是最泛化的结构。

如果对堆有任何疑问，请提出。否则，我们将进入 **第九章：图 (Graphs)**。