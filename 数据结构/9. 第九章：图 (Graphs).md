好的，我们来到了本课程大纲的最后一章，将要学习最通用、最强大的数据结构——图。图可以用来模拟现实世界中几乎任何一种网络关系。

---

### **第九章：图 (Graphs)**

之前我们学习的所有数据结构（如链表、树）都可以被看作是图的特例。图是一种非线性的数据结构，它能够表示元素之间任意复杂的多对多关系。

#### **9.1 图的基本术语**

**定义**：图 (Graph) `G` 是一个由顶点集合 `V` 和边集合 `E` 组成的二元组，记为 `G = (V, E)`。
*   **顶点 (Vertex / Node)**：图中的基本元素，代表实体或对象。集合 `V` 是顶点的非空有限集。
*   **边 (Edge)**：连接两个顶点的线，代表它们之间的关系。集合 `E` 是连接 `V` 中两顶点的边的集合。

让我们来详细了解图的各种类型和术语：

*   **无向图 (Undirected Graph)**：
    *   边没有方向。如果顶点 `u` 和 `v` 之间有一条边 `(u, v)`，那么从 `u` 到 `v` 和从 `v` 到 `u` 是等价的。
    *   应用：社交网络中的好友关系（A是B的好友，B也是A的好友）。

*   **有向图 (Directed Graph / Digraph)**：
    *   边有方向。边 `(u, v)` 是一个从顶点 `u`（称为 **尾部 tail**）指向顶点 `v`（称为 **头部 head**）的有序对。
    *   应用：网页链接（页面A链接到页面B，不代表B也链接到A）、任务依赖关系。

*   **权重 (Weight)**：可以给边关联一个数值，称为权重或成本 (cost)。这样的图称为**加权图 (Weighted Graph)**。
    *   应用：地图中的城市（顶点）和道路（边），权重可以代表距离或通行时间。

*   **邻接 (Adjacency)**：如果两个顶点之间有一条边相连，则称它们是**邻接的 (adjacent)**。
    *   在无向图中，`u` 和 `v` 互相邻接。
    *   在有向图中，如果存在边 `(u, v)`，则称 `v` 是 `u` 的邻接点（`u` is adjacent to `v`）。

*   **顶点的度 (Degree of a Vertex)**：
    *   **无向图**：与该顶点相关联的边的数量。
    *   **有向图**：
        *   **入度 (In-degree)**：指向该顶点的边的数量。
        *   **出度 (Out-degree)**：从该顶点出发的边的数量。

*   **路径 (Path)**：图中一个顶点到另一个顶点的顶点序列，序列中任意相邻的两个顶点之间都有一条边。
*   **环 (Cycle)**：一个起点和终点相同的路径。
    *   **无环图 (Acyclic Graph)**：不包含任何环的图。
    *   **有向无环图 (Directed Acyclic Graph, DAG)**：一种非常重要的图类型，常用于表示依赖关系（如课程先修关系、软件项目构建顺序）。

*   **连通性 (Connectivity)**：
    *   **无向图**：如果图中任意两个顶点之间都存在路径，则称该图是**连通图 (Connected Graph)**。
    *   **有向图**：如果忽略边的方向后，图是连通的，则称其为**弱连通 (Weakly Connected)**。如果图中任意两个顶点 `u` 和 `v` 之间，既存在从 `u` 到 `v` 的路径，也存在从 `v` 到 `u` 的路径，则称其为**强连通 (Strongly Connected)**。

---

#### **9.2 图的表示方法 1：邻接矩阵 (Adjacency Matrix)**

**定义**：邻接矩阵是一个 `|V| x |V|` 的二维矩阵 `A`，其中 `|V|` 是顶点的数量。矩阵的元素 `A[i][j]` 定义如下：
*   **无权图**：
    *   `A[i][j] = 1` 如果存在从顶点 `i` 到顶点 `j` 的边。
    *   `A[i][j] = 0` 如果不存在这样的边。
*   **加权图**：
    *   `A[i][j] = w` 如果存在从顶点 `i` 到顶点 `j` 的边，权重为 `w`。
    *   `A[i][j] = ∞` (或一个特殊值如 `null`) 如果不存在边。
    *   `A[i][i]` 通常为 `0`。

**示例**（一个无向无权图）：
```
  0 -- 1
  |  /
  | /
  2 -- 3
```
顶点：{0, 1, 2, 3}
邻接矩阵 `A`：
```
   0 1 2 3
0 [0,1,1,0]
1 [1,0,1,0]
2 [1,1,0,1]
3 [0,0,1,0]
```
*注意：对于无向图，邻接矩阵是沿主对角线对称的。*

**优缺点**：
*   **优点**：
    *   检查两个顶点 `u` 和 `v` 是否邻接非常快：只需访问 `A[u][v]`，时间复杂度为 **O(1)**。
    *   实现简单。
*   **缺点**：
    *   空间复杂度高：需要 **O(|V|²)** 的空间，即使图是**稀疏的 (sparse)**（边的数量 `|E|` 远小于 `|V|²`），也会浪费大量空间。
    *   获取一个顶点的所有邻接点很慢：需要遍历一整行，时间复杂度为 **O(|V|)**。

---

#### **9.3 图的表示方法 2：邻接表 (Adjacency List)**

**定义**：邻接表由一个包含 `|V|` 个链表（或动态数组）的数组构成。数组的第 `i` 个位置存储了一个链表，该链表包含了所有与顶点 `i` 相邻接的顶点。
*   **无权图**：链表中只存储邻接顶点的编号。
*   **加权图**：链表中存储 `(邻接顶点, 权重)` 的序对。

**示例**（与上面相同的图）：
```
  0 -- 1
  |  /
  | /
  2 -- 3
```
邻接表 `Adj`:
```
0: -> 1 -> 2
1: -> 0 -> 2
2: -> 0 -> 1 -> 3
3: -> 2
```

**优缺点**：
*   **优点**：
    *   空间效率高：空间复杂度为 **O(|V| + |E|)**。对于稀疏图，这比邻接矩阵好得多。
    *   获取一个顶点的所有邻接点很快：只需遍历对应的链表，时间复杂度为 **O(degree(v))**，其中 `degree(v)` 是该顶点的度。
*   **缺点**：
    *   检查两个顶点 `u` 和 `v` 是否邻接较慢：需要遍历 `u` 的邻接链表，查找是否存在 `v`，时间复杂度为 **O(degree(u))**。

**结论**：在绝大多数实际应用中，特别是对于稀疏图，**邻接表是更优的选择**。

---

#### **图的遍历 (Graph Traversal)**

图遍历是指从图中某个顶点出发，系统地访问图中的所有顶点，且每个顶点仅被访问一次。这是几乎所有图算法的基础。主要有两种遍历策略。

##### **9.4 广度优先搜索 (Breadth-First Search, BFS)**

BFS 从一个起始顶点开始，逐层地向外探索。它首先访问所有与起始点直接相邻的顶点，然后是与这些顶点相邻的、尚未被访问过的顶点，以此类推。

**算法核心**：
*   使用一个**队列 (Queue)** 来存储待访问的顶点。
*   使用一个**集合 (Set)** 或布尔数组来记录已访问过的顶点，以避免重复访问和无限循环。

**步骤 (从起始顶点 `s` 开始)**：
1.  创建一个队列 `Q`，并将 `s` 入队。
2.  创建一个集合 `visited`，并将 `s` 添加进去。
3.  当 `Q` 不为空时，循环执行：
    a. 从 `Q` 中出队一个顶点 `u`。
    b. **处理 `u`**（例如，打印它）。
    c. 遍历 `u` 的所有邻接顶点 `v`：
        i. 如果 `v` 不在 `visited` 集合中：
            - 将 `v` 添加到 `visited` 集合。
            - 将 `v` 入队。

**特性**：
*   BFS 找到的从起点到任何其他顶点的路径，都是**最短路径**（在无权图中，指边的数量最少）。
*   时间复杂度：**O(|V| + |E|)**，因为每个顶点和每条边都只会被访问一次。
*   空间复杂度：最坏情况下，队列可能需要存储 `|V|` 个顶点，为 **O(|V|)**。

##### **9.5 深度优先搜索 (Depth-First Search, DFS)**

DFS 从一个起始顶点开始，沿着一条路径尽可能深地探索，直到到达路径的末端，然后回溯到上一个顶点，探索另一条路径。

**算法核心**：
*   使用**递归 (Recursion)**（隐式地使用函数调用栈）或一个显式的**栈 (Stack)** 来实现。
*   同样需要一个 `visited` 集合来防止重复访问。

**步骤 (递归实现，从起始顶点 `s` 开始)**：
1.  创建一个 `visited` 集合。
2.  调用 `DFS_Visit(s, visited)`。

**`DFS_Visit(u, visited)` 函数**：
1.  将 `u` 添加到 `visited` 集合。
2.  **处理 `u`**（例如，打印它）。
3.  遍历 `u` 的所有邻接顶点 `v`：
    a. 如果 `v` 不在 `visited` 集合中：
        i. 递归调用 `DFS_Visit(v, visited)`。

**特性**：
*   DFS 常用于：
    *   **拓扑排序 (Topological Sort)**：在有向无环图 (DAG) 中，将所有顶点排成一个线性序列，使得对于任意边 `(u, v)`，`u` 都在 `v` 之前。
    *   **检测环 (Cycle Detection)**。
    *   寻找**连通分量 (Connected Components)**。
*   时间复杂度：**O(|V| + |E|)**。
*   空间复杂度：递归栈的深度在最坏情况下可能达到 `|V|`，为 **O(|V|)**。

---

##### **图的实现与遍历代码 (Python & JS)**

我们将使用**邻接表**来实现一个无向无权图，并演示 BFS 和 DFS。

```python
# Python 实现
from collections import deque

class Graph:
    def __init__(self):
        self.adj_list = {}

    def add_vertex(self, vertex):
        if vertex not in self.adj_list:
            self.adj_list[vertex] = []

    def add_edge(self, v1, v2):
        # 假设是无向图
        if v1 in self.adj_list and v2 in self.adj_list:
            self.adj_list[v1].append(v2)
            self.adj_list[v2].append(v1)
        else:
            raise KeyError("One or both vertices not in the graph")

    def bfs(self, start_vertex):
        if start_vertex not in self.adj_list:
            return []
        
        visited = set()
        queue = deque([start_vertex])
        visited.add(start_vertex)
        result = []

        while queue:
            vertex = queue.popleft()
            result.append(vertex)
            
            for neighbor in self.adj_list[vertex]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
        return result

    def dfs(self, start_vertex):
        if start_vertex not in self.adj_list:
            return []
            
        visited = set()
        result = []
        
        # 内部递归函数
        def _dfs_visit(vertex):
            visited.add(vertex)
            result.append(vertex)
            
            for neighbor in self.adj_list[vertex]:
                if neighbor not in visited:
                    _dfs_visit(neighbor)

        _dfs_visit(start_vertex)
        return result

# --- 使用示例 ---
g = Graph()
vertices = ['A', 'B', 'C', 'D', 'E', 'F']
for v in vertices:
    g.add_vertex(v)

g.add_edge('A', 'B')
g.add_edge('A', 'C')
g.add_edge('B', 'D')
g.add_edge('C', 'E')
g.add_edge('D', 'E')
g.add_edge('D', 'F')
g.add_edge('E', 'F')

print("BFS starting from A:", g.bfs('A')) # 可能的输出: ['A', 'B', 'C', 'D', 'E', 'F']
print("DFS starting from A:", g.dfs('A')) # 可能的输出: ['A', 'B', 'D', 'E', 'C', 'F']
```

```javascript
// JavaScript 实现
class Graph {
    constructor() {
        this.adjList = new Map();
    }

    addVertex(vertex) {
        if (!this.adjList.has(vertex)) {
            this.adjList.set(vertex, []);
        }
    }

    addEdge(v1, v2) {
        // 假设是无向图
        if (this.adjList.has(v1) && this.adjList.has(v2)) {
            this.adjList.get(v1).push(v2);
            this.adjList.get(v2).push(v1);
        } else {
            throw new Error("One or both vertices not in the graph");
        }
    }

    bfs(startVertex) {
        if (!this.adjList.has(startVertex)) {
            return [];
        }

        const visited = new Set();
        const queue = [startVertex];
        visited.add(startVertex);
        const result = [];

        while (queue.length > 0) {
            const vertex = queue.shift(); // 性能不如真队列，但演示足够
            result.push(vertex);

            const neighbors = this.adjList.get(vertex);
            for (const neighbor of neighbors) {
                if (!visited.has(neighbor)) {
                    visited.add(neighbor);
                    queue.push(neighbor);
                }
            }
        }
        return result;
    }

    dfs(startVertex) {
        if (!this.adjList.has(startVertex)) {
            return [];
        }

        const visited = new Set();
        const result = [];

        const _dfsVisit = (vertex) => {
            visited.add(vertex);
            result.push(vertex);

            const neighbors = this.adjList.get(vertex);
            for (const neighbor of neighbors) {
                if (!visited.has(neighbor)) {
                    _dfsVisit(neighbor);
                }
            }
        };

        _dfsVisit(startVertex);
        return result;
    }
}

// --- 使用示例 ---
const g = new Graph();
const vertices = ['A', 'B', 'C', 'D', 'E', 'F'];
vertices.forEach(v => g.addVertex(v));

g.addEdge('A', 'B');
g.addEdge('A', 'C');
g.addEdge('B', 'D');
g.addEdge('C', 'E');
g.addEdge('D', 'E');
g.addEdge('D', 'F');
g.addEdge('E', 'F');

console.log("BFS starting from A:", g.bfs('A')); // 可能的输出: ['A', 'B', 'C', 'D', 'E', 'F']
console.log("DFS starting from A:", g.dfs('A')); // 可能的输出: ['A', 'B', 'D', 'E', 'C', 'F']
```

#### **9.6 (选讲) 最小生成树与最短路径算法概念**

*   **最小生成树 (Minimum Spanning Tree, MST)**：在一个**加权的、连通的、无向图**中，找到一棵包含所有顶点的子树，使得这棵子树所有边的权重之和最小。
    *   **应用**：在多个城市间铺设电缆或管道，使其总长度最短。
    *   **经典算法**：Prim 算法、Kruskal 算法。

*   **最短路径 (Shortest Path)**：在一个**加权的图**中，找到从一个源顶点 `s` 到其他所有顶点的路径，使得路径上的权重之和最小。
    *   **应用**：GPS 导航。
    *   **经典算法**：
        *   **Dijkstra 算法**：适用于所有边权重**非负**的图。
        *   **Bellman-Ford 算法**：可以处理带有**负权重**边的图。
        *   **Floyd-Warshall 算法**：计算图中**所有顶点对**之间的最短路径。

---

**本章小结:**

*   你掌握了图作为表示**多对多关系**的通用数据结构的基本概念和核心术语。
*   你学习了两种主要的图表示法——**邻接矩阵**和**邻接表**，并理解了它们各自的优缺点和适用场景。
*   你深刻理解了两种核心的图遍历算法：基于**队列**的**广度优先搜索 (BFS)** 和基于**栈/递归**的**深度优先搜索 (DFS)**。
*   你能够用邻接表实现一个图，并编写 BFS 和 DFS 的代码。
*   你对**最小生成树**和**最短路径**等经典图算法有了概念性的了解。

---

### **课程总结**

恭喜你！你已经系统地完成了整个数据结构课程的学习。

*   你从**基础概念**（复杂度分析）出发，
*   掌握了**线性结构**（数组、链表、栈、队列）的原理和实现，
*   深入了**非线性结构**，包括高效查找的**哈希表**，层级关系的**树**（特别是 BST 和自平衡概念），以及特殊化的**堆**（优先队列），
*   最后学习了最泛化的**图**结构及其遍历算法。

你现在具备了分析问题、选择合适的数据结构、并理解其背后性能权衡的核心能力。这为你进一步学习算法设计、数据库原理、操作系统等高级计算机科学课程打下了坚实的基础。

**下一步建议**：
1.  **实践**：在 LeetCode 或其他编程平台上，专门练习与每个数据结构相关的题目。
2.  **深化**：深入研究每种数据结构的更高级变体（如 B-树、Trie 树）和更复杂的图算法。
3.  **应用**：在自己的项目中，有意识地思考和应用所学的数据结构知识，以优化程序性能和架构。

希望这个超级详细的教程对你有所帮助。如果你对任何章节有回顾或深入探讨的需求，随时可以提问。学习之路，永无止境！