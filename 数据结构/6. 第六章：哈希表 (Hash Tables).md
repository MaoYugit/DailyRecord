好的，我们正式进入课程的第三部分：非线性数据结构。

这一部分将介绍组织和访问数据的新范式。与线性结构的一对一关系不同，非线性结构中的元素可以与零个、一个或多个其他元素相关联。我们将从一个性能极其出色、应用极为广泛的数据结构——哈希表开始。

---

### **第六章：哈希表 (Hash Tables)**

哈希表（也称为散列表）是一种能够提供**平均 O(1) 复杂度**的插入、删除和查找操作的数据结构。这种卓越的性能使其成为许多编程语言内置字典或映射类型（如 Python 的 `dict` 和 JavaScript 的 `Map`/`Object`）的实现基础。

#### **6.1 哈希表的原理：键值对映射与哈希函数**

**定义**：哈希表是一种使用**哈希函数 (Hash Function)** 将**键 (Key)** 映射到存储桶 (Bucket) 或槽 (Slot) 索引的数据结构，用于高效地存储和检索**键值对 (Key-Value Pair)**。

让我们分解这个定义的核心组件：

1.  **键值对 (Key-Value Pair)**：哈希表存储的是成对的数据。**键**是用于唯一标识数据的索引，**值**是与该键关联的实际数据。例如，在一个电话簿中，姓名是键，电话号码是值。

2.  **底层数组 (Underlying Array)**：哈希表的物理基础是一个数组，这个数组的每个位置被称为一个**桶 (Bucket)** 或**槽 (Slot)**。

3.  **哈希函数 (Hash Function)**：这是哈希表魔法的核心。
    *   **功能**：一个哈希函数接受一个任意大小的输入（键），并将其转换为一个固定大小的输出，这个输出通常是一个整数，我们称之为**哈希码 (Hash Code)**。
    *   **作用**：哈希码经过进一步处理（通常是取模运算），被用来计算键值对应当存放在底层数组中的哪个索引位置。
    *   **公式**：`index = hash_function(key) % array_size`

**理想工作流程 (无冲突情况)**：
1.  **插入 (Insert)**：
    *   `hash_code = hash_function(key)`
    *   `index = hash_code % array_size`
    *   将 `value` 存储在数组的 `index` 位置。
2.  **查找 (Search)**：
    *   `hash_code = hash_function(key)`
    *   `index = hash_code % array_size`
    *   直接去数组的 `index` 位置取回 `value`。
3.  **删除 (Delete)**：
    *   `hash_code = hash_function(key)`
    *   `index = hash_code % array_size`
    *   删除或标记数组 `index` 位置的数据。

在理想情况下，由于哈希函数的计算和数组的索引访问都是 O(1) 操作，所以哈希表的插入、查找和删除也都是 **O(1)** 操作。

然而，现实并不总是那么理想。

#### **6.2 哈希冲突 (Hash Collisions) 的成因**

**定义**：哈希冲突是指两个或多个不同的键，经过哈希函数计算后，得到了相同的数组索引。
`hash_function(key1) % array_size == hash_function(key2) % array_size`，但 `key1 != key2`。

冲突是不可避免的，原因有二：
1.  **输入空间远大于输出空间**：键的可能取值范围（例如，所有可能的字符串）是近乎无限的，而哈希表底层数组的大小是有限的。根据鸽巢原理，必然会有多个键映射到同一个索引。
2.  **哈希函数的不完美**：即使是一个好的哈希函数，也无法保证对所有输入都产生唯一的输出。

当冲突发生时，如果我们不加处理，后来的数据就会覆盖先来的数据，导致数据丢失。因此，**解决哈希冲突**是实现一个可用哈希表的关键。

#### **6.3 冲突解决方法 1：链地址法 (Separate Chaining)**

这是最常用也是最容易理解的冲突解决方法。

**原理**：
*   底层数组的每个桶不再直接存储单个值，而是存储一个指向**链表 (或其他数据结构) 头部**的指针。
*   当多个键映射到同一个索引时，它们的键值对会被作为节点，**依次追加到这个索引对应的链表中**。

**工作流程 (使用链地址法)**：
1.  **插入 (Insert `(key, value)`)**：
    *   计算索引 `index = hash_function(key) % array_size`。
    *   访问数组 `index` 位置的链表。
    *   **遍历**这个链表，检查 `key` 是否已经存在。
        *   如果存在，则更新对应的 `value`。
        *   如果不存在，则创建一个新的 `(key, value)` 节点，并将其添加到链表的末尾（或头部）。
2.  **查找 (Search `key`)**：
    *   计算索引 `index = hash_function(key) % array_size`。
    *   访问数组 `index` 位置的链表。
    *   **遍历**这个链表，逐个比较节点的键是否与目标 `key` 匹配。
        *   如果找到匹配的键，返回其 `value`。
        *   如果遍历完整个链表都未找到，说明该键不存在。
3.  **删除 (Delete `key`)**：
    *   与查找类似，先定位到正确的链表。
    *   遍历链表找到包含目标 `key` 的节点，并将其从链表中删除（需要处理头节点、中间节点的情况）。

**性能分析**：
*   在理想情况下（哈希函数分布均匀，链表很短），操作仍然接近 O(1)。
*   **最坏情况**：如果哈希函数设计极差，导致所有键都映射到同一个索引，那么哈希表就退化成了一个**链表**。此时，插入、查找、删除操作的时间复杂度都变成了 **O(n)**，其中 n 是哈希表中的元素总数。
*   **平均情况**：为了保持高效，我们需要控制链表的平均长度。这通过一个叫做**负载因子 (Load Factor)** 的指标来衡量。
    *   `Load Factor (α) = n / m`，其中 `n` 是元素数量，`m` 是数组大小（桶的数量）。
    *   一个好的哈希表实现会监控负载因子。当 `α` 超过某个阈值（通常是 0.7 或 0.75）时，会进行**扩容 (rehash)**：创建一个更大的新数组（通常是原大小的2倍），并将所有旧的键值对重新计算哈希值，放入新数组中。这个过程代价昂贵 (O(n))，但能保证后续操作的平均 O(1) 性能。

#### **6.4 冲突解决方法 2：开放地址法 (Open Addressing)**

**原理**：
*   所有键值对都直接存储在底层数组中，不使用任何外部数据结构（如链表）。
*   当发生冲突时（即目标索引 `index` 已被占用），我们通过一个**探测序列 (Probing Sequence)** 来寻找数组中下一个可用的空槽。

**常见的探测策略**：
1.  **线性探测 (Linear Probing)**：如果索引 `i` 被占用，就尝试 `i+1`, `i+2`, `i+3`, ... (都需对数组大小取模)。
    *   **缺点**：容易产生**“聚集 (Clustering)”**现象，即被占用的槽会连成一片，导致后续冲突的概率增加，查找效率下降。
2.  **二次探测 (Quadratic Probing)**：如果索引 `i` 被占用，就尝试 `i+1²`, `i+2²`, `i+3²`, ...。
    *   **优点**：可以更好地分散元素，缓解线性探测的聚集问题。
3.  **双重哈希 (Double Hashing)**：使用第二个哈希函数来计算探测的步长。`index = (hash1(key) + i * hash2(key)) % array_size`。
    *   **优点**：提供了最好的元素分布，是开放地址法中性能较好的一种。

**性能分析**：
*   开放地址法对 CPU 缓存更友好（因为数据更集中），但实现更复杂，尤其是在删除操作时。
*   **删除操作**：不能简单地将槽位清空，因为这会中断探测序列，导致后续查找失败。通常需要使用一个特殊的“已删除”标记来占据该槽位。
*   对负载因子更敏感，通常要求负载因子保持在较低水平（如 0.5）。

---

#### **6.6 哈希表的从零实现 (Python & JS)**

我们将使用更常见和直观的**链地址法**来实现一个哈希表。

##### **Python 实现**

```python
class HashTable:
    """
    使用链地址法实现的哈希表。
    """
    def __init__(self, size=16):
        if size <= 0:
            raise ValueError("Size must be positive")
        self._size = size
        self._buckets = [[] for _ in range(self._size)] # 初始化每个桶为一个空列表（模拟链表）

    def _hash(self, key):
        """
        一个简单的哈希函数。
        注意：对于字符串，Python内置的hash()是为每次运行随机化的，不适用于此。
        我们自己实现一个简单的、确定性的哈希函数。
        """
        hash_code = 0
        for char in str(key):
            hash_code = (hash_code * 31 + ord(char)) & 0xFFFFFFFF # 31是常见的乘数
        return hash_code

    def _get_bucket_index(self, key):
        """
        获取键对应的桶索引。
        """
        hash_code = self._hash(key)
        return hash_code % self._size

    def set(self, key, value):
        """
        设置键值对（插入或更新）。
        时间复杂度: 平均 O(1)，最坏 O(n)。
        """
        index = self._get_bucket_index(key)
        bucket = self._buckets[index]

        # 遍历桶（链表）查找键是否存在
        for i, (k, v) in enumerate(bucket):
            if k == key:
                # 键已存在，更新值
                bucket[i] = (key, value)
                return
        
        # 键不存在，在链表末尾添加新节点
        bucket.append((key, value))

    def get(self, key):
        """
        根据键获取值。
        时间复杂度: 平均 O(1)，最坏 O(n)。
        """
        index = self._get_bucket_index(key)
        bucket = self._buckets[index]

        for k, v in bucket:
            if k == key:
                return v
        
        # 键不存在
        raise KeyError(f"Key '{key}' not found")

    def delete(self, key):
        """
        根据键删除键值对。
        时间复杂度: 平均 O(1)，最坏 O(n)。
        """
        index = self._get_bucket_index(key)
        bucket = self._buckets[index]

        for i, (k, v) in enumerate(bucket):
            if k == key:
                # 找到并删除
                del bucket[i]
                return
        
        # 键不存在
        raise KeyError(f"Key '{key}' not found")

# --- 使用示例 ---
ht = HashTable(size=4)
ht.set("name", "Alice")
ht.set("age", 30)
ht.set("city", "New York") # 假设 'age' 和 'city' 发生冲突
ht.set("country", "USA")

print(f"Name: {ht.get('name')}")   # Alice
print(f"Age: {ht.get('age')}")     # 30

ht.set("age", 31) # 更新
print(f"New Age: {ht.get('age')}") # 31

ht.delete("city")
try:
    ht.get("city")
except KeyError as e:
    print(e) # Key 'city' not found
```

##### **JavaScript 实现**

```javascript
class HashTable {
    /**
     * 使用链地址法实现的哈希表。
     */
    constructor(size = 16) {
        if (size <= 0) {
            throw new Error("Size must be positive");
        }
        this._size = size;
        this._buckets = Array.from({ length: this._size }, () => []); // 初始化每个桶为空数组（模拟链表）
    }

    _hash(key) {
        /**
         * 一个简单的、确定性的哈希函数。
         */
        let hashCode = 0;
        const keyStr = String(key);
        for (let i = 0; i < keyStr.length; i++) {
            hashCode = (hashCode * 31 + keyStr.charCodeAt(i)) | 0; // | 0 确保是32位有符号整数
        }
        return hashCode;
    }
    
    _getBucketIndex(key) {
        const hashCode = this._hash(key);
        // JS的 % 对负数行为不同，确保索引非负
        return ((hashCode % this._size) + this._size) % this._size;
    }

    set(key, value) {
        /**
         * 设置键值对（插入或更新）。
         * 时间复杂度: 平均 O(1)，最坏 O(n)。
         */
        const index = this._getBucketIndex(key);
        const bucket = this._buckets[index];

        for (let i = 0; i < bucket.length; i++) {
            if (bucket[i][0] === key) {
                // 键已存在，更新值
                bucket[i][1] = value;
                return;
            }
        }
        // 键不存在，在链表末尾添加新节点
        bucket.push([key, value]);
    }

    get(key) {
        /**
         * 根据键获取值。
         * 时间复杂度: 平均 O(1)，最坏 O(n)。
         */
        const index = this._getBucketIndex(key);
        const bucket = this._buckets[index];

        for (const [k, v] of bucket) {
            if (k === key) {
                return v;
            }
        }
        // 键不存在
        return undefined; // 或 throw new Error
    }

    delete(key) {
        /**
         * 根据键删除键值对。
         * 时间复杂度: 平均 O(1)，最坏 O(n)。
         */
        const index = this._getBucketIndex(key);
        const bucket = this._buckets[index];
        
        for (let i = 0; i < bucket.length; i++) {
            if (bucket[i][0] === key) {
                // 找到并删除
                bucket.splice(i, 1);
                return true; // 表示删除成功
            }
        }
        return false; // 表示未找到，删除失败
    }
}

// --- 使用示例 ---
const ht = new HashTable(4);
ht.set("name", "Alice");
ht.set("age", 30);
ht.set("city", "New York");
ht.set("country", "USA");

console.log(`Name: ${ht.get("name")}`); // Alice
console.log(`Age: ${ht.get("age")}`);   // 30

ht.set("age", 31); // 更新
console.log(`New Age: ${ht.get("age")}`); // 31

ht.delete("city");
console.log(`City: ${ht.get("city")}`); // undefined
```

#### **6.5 良好哈希函数的设计原则**
一个好的哈希函数至关重要，它应该具备：
1.  **确定性 (Deterministic)**：对相同的输入，总是产生相同的输出。
2.  **高效性 (Efficient)**：计算速度快。
3.  **均匀性 (Uniformity)**：能将输入尽可能均匀地分布到输出空间中，以最小化冲突。

#### **6.7 内置哈希表：Python 的 `dict` 和 JavaScript 的 `Map`**
Python 的 `dict` 和 JS 的 `Map` 都是高度优化的哈希表实现。它们内部处理了所有复杂性，如哈希函数的设计、冲突解决、动态扩容等。在实际应用中，我们应直接使用这些内置类型。

**本章小结:**

*   你掌握了哈希表通过**哈希函数**将**键**映射到**数组索引**，以实现**平均 O(1)** 性能的核心原理。
*   你理解了**哈希冲突**的必然性，并学习了两种主要的解决方法：**链地址法**和**开放地址法**。
*   你亲手用链地址法实现了一个基础的哈希表，并理解了其 `set`, `get`, `delete` 操作的内部流程。
*   你了解了**负载因子**和**动态扩容 (rehash)** 对维持哈希表高性能的重要性。
*   你认识到在实际编程中应优先使用语言内置的高度优化的哈希表实现。

哈希表为我们提供了近乎完美的快速查找能力。接下来，我们将学习另一种重要的非线性结构——树，它在提供高效查找的同时，还能维持数据的有序性。

如果对哈希表有任何疑问，请提出。否则，我们将进入 **第七章：树 (Trees)**。