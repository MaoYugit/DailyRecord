好的，我们继续课程，进入第七章。在这一章，我们将探索一种能够模拟层级关系、支持高效搜索和排序的强大数据结构——树。

---

### **第七章：树 (Trees)**

与之前学习的线性结构（数组、链表、栈、队列）不同，树是一种**非线性**的数据结构。它专门用于表示具有**层级 (hierarchical)** 或**父子 (parent-child)** 关系的数据。

**定义**：树 (Tree) 是一个由 `n` (`n ≥ 0`) 个有限节点组成的集合。当 `n=0` 时，称为空树。在任意非空树中：
1.  有且仅有一个特定的节点称为**根 (Root)**。
2.  当 `n > 1` 时，其余节点可分为 `m` (`m > 0`) 个互不相交的有限集合 `T₁, T₂, ..., Tₘ`，其中每一个集合本身又是一棵树，并称为根的**子树 (Subtree)**。

这个定义是递归的，它完美地描述了树的层级特性。

#### **7.1 树的基本术语**

理解树的术语是学习后续内容的基础。让我们用下图作为例子：

```
      A  <-- 根 (Root)
     /|\
    / | \
   B  C  D  <-- A的孩子, B,C,D是兄弟节点
  / \   / \
 E   F G   H <-- 叶子节点 (Leaf)
 \
  I         <-- E的孩子, I是叶子节点
```

*   **节点 (Node)**：树的基本组成部分，如 A, B, C...
*   **根 (Root)**：树的最顶层节点，没有父节点（如 A）。
*   **父节点 (Parent)**：一个节点的直接上层节点（如 A 是 B 的父节点）。
*   **子节点 (Child)**：一个节点的直接下层节点（如 B, C, D 是 A 的子节点）。
*   **兄弟节点 (Siblings)**：拥有相同父节点的节点（如 B, C, D 是兄弟节点）。
*   **叶子节点 (Leaf / Terminal Node)**：没有子节点的节点（如 F, G, H, I）。
*   **内部节点 (Internal / Non-terminal Node)**：至少有一个子节点的节点（如 A, B, C, D, E）。
*   **边的度 (Degree of a Node)**：一个节点拥有的子树数量（即子节点的数量）。例如，A 的度是 3，E 的度是 1。
*   **树的度 (Degree of a Tree)**：树中所有节点度的最大值。上图中树的度是 3。
*   **路径 (Path)**：从一个节点到另一个节点所经过的节点序列。例如，A -> B -> E -> I 是一条路径。
*   **祖先 (Ancestor)**：从根到某节点路径上的所有节点都是该节点的祖先。
*   **后代 (Descendant)**：某节点子树中的所有节点都是该节点的后代。
*   **节点的层 (Level)**：根节点在第 1 层，其子节点在第 2 层，以此类推。
*   **节点的深度 (Depth)**：从根节点到该节点的路径长度（边的数量）。根的深度为 0。
*   **节点的高度 (Height)**：从该节点到其最远叶子节点的路径长度。叶子节点的高度为 0。
*   **树的高度 (Height of a Tree)**：根节点的高度，也等于树中所有节点深度的最大值。

#### **7.2 二叉树 (Binary Tree)**

在所有树的类型中，二叉树是最重要、研究最广泛的一种。

**定义**：二叉树是每个节点**最多**有两个子节点的树。这两个子节点通常被称为**左子节点 (Left Child)** 和**右子节点 (Right Child)**。

**关键特性**：
*   节点的度最大为 2。
*   左子树和右子树是有序的，不能互换。一个节点的左子树为空而右子树不为空，与右子树为空而左子树不为空是两种不同的二叉树。

**特殊类型的二叉树**：
*   **满二叉树 (Full Binary Tree)**：每个节点要么是叶子节点，要么恰好有两个子节点。
*   **完全二叉树 (Complete Binary Tree)**：除了最后一层外，其他各层节点数都达到最大，并且最后一层的节点都连续集中在左侧。堆（Heap）就是一种完全二叉树。
*   **完美二叉树 (Perfect Binary Tree)**：所有内部节点都有两个子节点，且所有叶子节点都在同一层。它是满二叉树和完全二叉树的特例。

---

#### **7.3 二叉树的遍历 (Traversal)**

遍历是指按照某种特定顺序访问树中的所有节点，且每个节点仅访问一次。这是树结构最核心的操作之一。主要分为两大类：深度优先搜索 (DFS) 和广度优先搜索 (BFS)。

##### **深度优先搜索 (Depth-First Search, DFS)**

DFS 会尽可能深地探索树的分支。根据访问根节点的时机，DFS 分为三种主要方式：

1.  **前序遍历 (Pre-order Traversal)**: **根 -> 左 -> 右**
    *   步骤：访问当前节点 -> 递归遍历左子树 -> 递归遍历右子树。
    *   应用：常用于复制树结构。

2.  **中序遍历 (In-order Traversal)**: **左 -> 根 -> 右**
    *   步骤：递归遍历左子树 -> 访问当前节点 -> 递归遍历右子树。
    *   应用：在二叉搜索树中，中序遍历会得到一个有序的节点序列。

3.  **后序遍历 (Post-order Traversal)**: **左 -> 右 -> 根**
    *   步骤：递归遍历左子树 -> 递归遍历右子树 -> 访问当前节点。
    *   应用：常用于计算目录大小或安全地删除树节点（先删除子节点，再删除父节点）。

##### **广度优先搜索 (Breadth-First Search, BFS) / 层序遍历 (Level-order Traversal)**

BFS 会逐层访问树的节点，从上到下，从左到右。

*   **步骤**：使用一个**队列**来实现。
    1.  将根节点入队。
    2.  当队列不为空时，循环执行：
        a. 将队头节点出队并访问。
        b. 如果该节点有左子节点，则将其左子节点入队。
        c. 如果该节点有右子节点，则将其右子节点入队。
*   **应用**：常用于寻找最短路径问题。

##### **遍历实现 (Python & JS)**

首先，我们需要一个二叉树节点类和一些示例树结构。

```python
# Python 二叉树节点
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

# 创建一个示例树
#      F
#     / \
#    B   G
#   / \   \
#  A   D   I
#     / \
#    C   E
root = TreeNode('F')
root.left = TreeNode('B')
root.right = TreeNode('G')
root.left.left = TreeNode('A')
root.left.right = TreeNode('D')
root.left.right.left = TreeNode('C')
root.left.right.right = TreeNode('E')
root.right.right = TreeNode('I')
```

```javascript
// JavaScript 二叉树节点
class TreeNode {
    constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
    }
}

// 创建一个示例树
const root = new TreeNode('F');
root.left = new TreeNode('B');
root.right = new TreeNode('G');
root.left.left = new TreeNode('A');
root.left.right = new TreeNode('D');
root.left.right.left = new TreeNode('C');
root.left.right.right = new TreeNode('E');
root.right.right = new TreeNode('I');
```

**实现遍历函数:**

```python
# Python 遍历实现
def preorder_traversal(node):
    if node is None: return []
    return [node.value] + preorder_traversal(node.left) + preorder_traversal(node.right)

def inorder_traversal(node):
    if node is None: return []
    return inorder_traversal(node.left) + [node.value] + inorder_traversal(node.right)

def postorder_traversal(node):
    if node is None: return []
    return postorder_traversal(node.left) + postorder_traversal(node.right) + [node.value]

from collections import deque
def levelorder_traversal(root):
    if not root: return []
    result = []
    q = deque([root])
    while q:
        node = q.popleft()
        result.append(node.value)
        if node.left:
            q.append(node.left)
        if node.right:
            q.append(node.right)
    return result

print("Pre-order:", preorder_traversal(root)) # F, B, A, D, C, E, G, I
print("In-order:", inorder_traversal(root))   # A, B, C, D, E, F, G, I
print("Post-order:", postorder_traversal(root))# A, C, E, D, B, I, G, F
print("Level-order:", levelorder_traversal(root))# F, B, G, A, D, I, C, E
```

```javascript
// JavaScript 遍历实现
function preorderTraversal(node) {
    if (node === null) return [];
    return [node.value, ...preorderTraversal(node.left), ...preorderTraversal(node.right)];
}

function inorderTraversal(node) {
    if (node === null) return [];
    return [...inorderTraversal(node.left), node.value, ...inorderTraversal(node.right)];
}

function postorderTraversal(node) {
    if (node === null) return [];
    return [...postorderTraversal(node.left), ...postorderTraversal(node.right), node.value];
}

function levelorderTraversal(root) {
    if (!root) return [];
    const result = [];
    const queue = [root]; // 使用数组模拟队列
    while (queue.length > 0) {
        const node = queue.shift(); // shift() 是 O(n), 性能不如真队列, 但演示足够
        result.push(node.value);
        if (node.left) {
            queue.push(node.left);
        }
        if (node.right) {
            queue.push(node.right);
        }
    }
    return result;
}

console.log("Pre-order:", preorderTraversal(root));   // F, B, A, D, C, E, G, I
console.log("In-order:", inorderTraversal(root));     // A, B, C, D, E, F, G, I
console.log("Post-order:", postorderTraversal(root)); // A, C, E, D, B, I, G, F
console.log("Level-order:", levelorderTraversal(root));// F, B, G, A, D, I, C, E
```

---

#### **7.4 二叉搜索树 (Binary Search Tree, BST)**

普通二叉树在查找时效率不高，需要遍历所有节点 (O(n))。二叉搜索树通过添加一个约束，极大地提高了查找效率。

**定义**：一棵二叉搜索树（或为空树）必须满足以下性质：
1.  若其左子树不空，则左子树上所有节点的值均**小于**其根节点的值。
2.  若其右子树不空，则右子树上所有节点的值均**大于**其根节点的值。
3.  其左、右子树也分别为二叉搜索树。
4.  树中没有键值相等的节点（这是一个常见的基本定义，也可以扩展为支持重复值）。

这个性质使得我们每次比较都可以排除掉一半的节点，类似于二分查找。

#### **7.5 BST 的核心操作与复杂度分析**

##### **搜索 (Search)**
*   **步骤**：从根节点开始。
    1.  若当前节点为空，则查找失败。
    2.  若目标值等于当前节点值，则查找成功。
    3.  若目标值小于当前节点值，则在左子树中继续搜索。
    4.  若目标值大于当前节点值，则在右子树中继续搜索。
*   **复杂度**：操作路径的长度等于树的高度 `h`。所以时间复杂度为 **O(h)**。

##### **插入 (Insert)**
*   **步骤**：与搜索类似。从根节点开始查找待插入值应该在的位置。当查找到一个空链接（`null` 或 `None`）时，就在该位置创建新节点。
*   **复杂度**：同样为 **O(h)**。

##### **删除 (Delete)**
删除是 BST 中最复杂的操作，需要分三种情况讨论：
1.  **待删除节点是叶子节点**：直接删除即可。
2.  **待删除节点只有一个子节点**：将其父节点直接链接到其唯一的子节点上，绕过该节点。
3.  **待删除节点有两个子节点**：这是最复杂的情况。
    *   **策略**：不能直接删除，否则会断开其两棵子树。我们需要在它的子树中找到一个节点来“顶替”它的位置。这个“顶替者”必须满足 BST 的性质。通常有两种选择：
        a. **中序前驱 (In-order Predecessor)**：其左子树中的最大值节点。
        b. **中序后继 (In-order Successor)**：其右子树中的最小值节点。
    *   **步骤（以后继为例）**：
        i. 找到待删除节点的右子树中的最小节点（一路向左走到底）。
        ii. 将这个最小节点的值复制到待删除节点的位置。
        iii. 现在问题转化为删除那个最小节点（它必然是叶子节点或只有一个右子节点），这就可以用情况 1 或 2 来解决了。
*   **复杂度**：查找和调整都需要 O(h) 时间，所以总复杂度为 **O(h)**。

#### **7.6 BST 的问题：退化现象**

BST 的所有操作复杂度都是 O(h)。那么树的高度 `h` 是多少？
*   **最佳情况（平衡树）**：当树大致平衡时，`n` 个节点的树高度 `h` 约等于 `log₂(n)`。此时 BST 的性能非常好，所有操作都是 **O(log n)**。
*   **最坏情况（退化树）**：如果我们按顺序（如 1, 2, 3, 4, 5）插入节点，每个新节点都会成为前一个节点的右子节点。这棵树会退化成一个**链表**。此时，树的高度 `h` 等于节点数 `n`。所有操作的复杂度都退化为 **O(n)**。

#### **7.7 (选讲) 平衡二叉搜索树：AVL树或红黑树的概念介绍**

为了解决 BST 的退化问题，计算机科学家们发明了**自平衡二叉搜索树 (Self-Balancing Binary Search Tree)**。

这类树在每次插入和删除操作后，都会通过一系列称为**“旋转 (Rotations)”** 的操作来自动调整树的结构，确保树的高度始终保持在 O(log n) 的量级，从而保证了所有核心操作的性能。

*   **AVL 树**：最早的自平衡 BST。它要求任何节点的左、右子树高度差（平衡因子）不能超过 1。这个条件非常严格，导致其查询性能极高，但插入和删除时可能需要多次旋转，维护成本较高。

*   **红黑树 (Red-Black Tree)**：另一种更常见的自平衡 BST（是 C++ `std::map` 和 Java `TreeMap` 的实现基础）。它的平衡条件比 AVL 树宽松，通过节点颜色（红或黑）和五条规则来维持大致的平衡。其插入和删除操作的旋转次数有常数上界，因此在写操作频繁的场景下，其综合性能通常优于 AVL 树。

**本章小结:**

*   你掌握了树作为一种**层级数据结构**的基本概念和核心术语。
*   你学习了二叉树的定义，并能熟练实现其四种主要的**遍历方式**（前序、中序、后序、层序）。
*   你深刻理解了**二叉搜索树 (BST)** 的关键性质，及其如何实现高效的**搜索、插入、删除**操作，复杂度均为 **O(h)**。
*   你认识到了 BST 在最坏情况下会**退化成链表**，导致性能下降到 **O(n)**。
*   你对 **AVL 树**和**红黑树**等自平衡 BST 有了初步的概念，知道它们是通过**旋转**操作来解决退化问题，从而保证 **O(log n)** 的性能。

树是计算机科学的基石之一。接下来，我们将学习一种特殊的、基于树的结构——堆。

如果对树有任何疑问，请提出。否则，我们将进入 **第八章：堆 (Heaps)**。