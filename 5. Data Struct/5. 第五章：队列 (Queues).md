好的，我们继续学习。在掌握了“后进先出”的栈之后，我们来学习它的“兄弟”——队列，它遵循完全相反的原则。

---

### **第五章：队列 (Queues)**

队列是另一种基础且重要的线性抽象数据类型。它的行为模式与我们在日常生活中排队的经验完全一致，这使得它非常直观。

#### **5.1 队列的定义：先进先出 (FIFO) 的抽象数据类型**

**定义**：队列 (Queue) 是一种遵循**先进先出 (First-In, First-Out, FIFO)** 原则的线性数据集合。

让我们精确解析这个定义：
*   **线性数据集合**：与栈一样，队列中的元素也具有逻辑上的线性顺序。
*   **先进先出 (FIFO)**：这是队列最核心、最根本的特性。它规定了数据的存取行为：最早被添加到队列中的元素，必须是第一个被移除的元素。
*   **两端操作**：与栈只在一端（栈顶）操作不同，队列的操作在两端进行。新元素从队列的一端加入，这一端被称为**队尾 (Rear / Tail)**。元素从另一端被移除，这一端被称为**队头 (Front / Head)**。

因此，队列的操作逻辑可以被严格地限定：新元素“入队”到队尾，而移除元素时是从队头“出队”。

#### **5.2 核心操作**

一个标准的队列 ADT 定义了以下几个核心操作：

1.  **`enqueue(element)`** (或 `add`)
    *   **功能**：向队尾添加一个新元素。
    *   **参数**：`element` - 要被添加到队列中的数据。
    *   **返回值**：无。

2.  **`dequeue()`** (或 `remove`)
    *   **功能**：移除并返回队头的元素。
    *   **参数**：无。
    *   **返回值**：被移除的队头元素。
    *   **前置条件**：该操作不能在空队列上执行。在一个空队列上调用 `dequeue()` 会导致**“队下溢 (Queue Underflow)”**的错误。

3.  **`front()`** (或 `peek`)
    *   **功能**：返回队头的元素，但**不**移除它。
    *   **参数**：无。
    *   **返回值**：队头元素。
    *   **前置条件**：该操作不能在空队列上执行。

4.  **`isEmpty()`**
    *   **功能**：检查队列是否为空。
    *   **参数**：无。
    *   **返回值**：如果队列中没有任何元素，返回 `true`；否则返回 `false`。

5.  **`size()`**
    *   **功能**：返回队列中元素的数量。
    *   **参数**：无。
    *   **返回值**：一个表示队列大小的非负整数。

接下来，我们将探讨如何使用数组和链表来实现这个队列 ADT。

---

#### **5.3 基于数组实现的队列 (及其效率问题)**

使用数组实现队列比实现栈要复杂一些，因为操作发生在数组的两端。

**初步尝试与问题分析**
一个天真的想法是：
*   `enqueue`: 使用数组的 `append` / `push` 方法在末尾添加元素（O(1) 摊还时间）。
*   `dequeue`: 从数组的开头移除元素（例如 Python 的 `list.pop(0)` 或 JavaScript 的 `Array.shift()`）。

问题在哪里？我们回顾第二章的知识，从数组的开头删除一个元素，需要将其后的所有元素都向左移动一位以填补空缺。这是一个 **O(n)** 操作。这意味着，如果队列非常大，每次 `dequeue` 都会非常耗时，这违背了我们对高效数据结构的要求。

**结论**：直接使用动态数组并在一端入队、另一端出队的简单实现是**低效的**。为了解决这个问题，有两种主流方案：使用链表，或者使用一种更高级的数组技巧——**循环队列**。

---

#### **5.4 基于链表实现的队列**

使用链表是实现高效队列的理想方式。它能为所有核心操作提供 O(1) 的时间复杂度。

**实现策略**：
*   **`enqueue`**: 在链表的**尾部**添加新节点。
*   **`dequeue`**: 从链表的**头部**移除节点。

为了让 `enqueue` 操作也是 O(1)，我们必须维护两个指针：一个 `head` 指针指向队头，一个 `tail` 指针指向队尾。这样，我们就可以在不遍历整个链表的情况下，直接在尾部添加新节点。

##### **Python 实现**

```python
# 同样需要 Node 类
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class QueueLinkedList:
    """
    基于链表实现的高效队列。
    所有核心操作都是 O(1)。
    """
    def __init__(self):
        self._head = None  # 指向队头节点
        self._tail = None  # 指向队尾节点
        self._size = 0

    def enqueue(self, item):
        """
        向队尾添加元素。
        时间复杂度: O(1)
        """
        new_node = Node(item)
        if self.is_empty():
            # 如果队列为空，新节点既是头也是尾
            self._head = new_node
            self._tail = new_node
        else:
            # 否则，将当前尾节点的next指向新节点，并更新尾指针
            self._tail.next = new_node
            self._tail = new_node
        self._size += 1

    def dequeue(self):
        """
        从队头移除元素。
        时间复杂度: O(1)
        """
        if self.is_empty():
            raise IndexError("dequeue from an empty queue")
        
        data_to_return = self._head.data
        self._head = self._head.next
        self._size -= 1
        
        # 如果出队后队列变空，需要额外更新尾指针
        if self.is_empty():
            self._tail = None
            
        return data_to_return

    def front(self):
        """
        查看队头元素。
        时间复杂度: O(1)
        """
        if self.is_empty():
            raise IndexError("front from an empty queue")
        return self._head.data

    def is_empty(self):
        """
        检查队列是否为空。
        时间复杂度: O(1)
        """
        return self._size == 0

    def size(self):
        """
        返回队列的大小。
        时间复杂度: O(1)
        """
        return self._size

# --- 使用示例 ---
q_ll = QueueLinkedList()
q_ll.enqueue('Job1')
q_ll.enqueue('Job2')
q_ll.enqueue('Job3')

print(f"Queue size: {q_ll.size()}")           # 3
print(f"Front of queue: {q_ll.front()}")      # 'Job1'

dequeued_item = q_ll.dequeue()
print(f"Dequeued item: {dequeued_item}")      # 'Job1'
print(f"New front: {q_ll.front()}")           # 'Job2'

q_ll.dequeue()
q_ll.dequeue()
print(f"Is queue empty? {q_ll.is_empty()}")   # True
# q_ll.dequeue() # 这会引发 IndexError
```

##### **JavaScript 实现**

```javascript
// 需要 Node 类
class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

class QueueLinkedList {
    /**
     * 基于链表实现的高效队列。
     * 所有核心操作都是 O(1)。
     */
    constructor() {
        this._head = null; // 指向队头节点
        this._tail = null; // 指向队尾节点
        this._size = 0;
    }

    /**
     * 向队尾添加元素。
     * 时间复杂度: O(1)
     * @param {*} item
     */
    enqueue(item) {
        const newNode = new Node(item);
        if (this.isEmpty()) {
            // 如果队列为空，新节点既是头也是尾
            this._head = newNode;
            this._tail = newNode;
        } else {
            // 否则，将当前尾节点的next指向新节点，并更新尾指针
            this._tail.next = newNode;
            this._tail = newNode;
        }
        this._size++;
    }

    /**
     * 从队头移除元素。
     * 时间复杂度: O(1)
     * @returns {*}
     */
    dequeue() {
        if (this.isEmpty()) {
            throw new Error("dequeue from an empty queue");
        }
        const dataToReturn = this._head.data;
        this._head = this._head.next;
        this._size--;
        
        // 如果出队后队列变空，需要额外更新尾指针
        if (this.isEmpty()) {
            this._tail = null;
        }
        
        return dataToReturn;
    }

    /**
     * 查看队头元素。
     * 时间复杂度: O(1)
     * @returns {*}
     */
    front() {
        if (this.isEmpty()) {
            throw new Error("front from an empty queue");
        }
        return this._head.data;
    }

    /**
     * 检查队列是否为空。
     * 时间复杂度: O(1)
     * @returns {boolean}
     */
    isEmpty() {
        return this._size === 0;
    }

    /**
     * 返回队列的大小。
     * 时间复杂度: O(1)
     * @returns {number}
     */
    size() {
        return this._size;
    }
}

// --- 使用示例 ---
const qLl = new QueueLinkedList();
qLl.enqueue('Job1');
qLl.enqueue('Job2');
qLl.enqueue('Job3');

console.log(`Queue size: ${qLl.size()}`);           // 3
console.log(`Front of queue: ${qLl.front()}`);      // 'Job1'

const dequeuedItem = qLl.dequeue();
console.log(`Dequeued item: ${dequeuedItem}`);      // 'Job1'
console.log(`New front: ${qLl.front()}`);           // 'Job2'

qLl.dequeue();
qLl.dequeue();
console.log(`Is queue empty? ${qLl.isEmpty()}`);   // true
// qLl.dequeue(); // 这会引发 Error
```

---

#### **5.5 循环队列 (Circular Queue)**

循环队列是解决基于数组实现队列时 `dequeue` 效率低下问题的巧妙方案。它避免了 O(n) 的数据迁移。

**核心思想**：将一个固定大小的数组在逻辑上视为一个环。
*   我们维护两个指针：`front` 指向队头元素的索引，`rear` 指向队尾元素**之后一个**可插入位置的索引。
*   **Enqueue**: 在 `rear` 指针的位置放入新元素，然后将 `rear` 指针向后移动一位。`rear = (rear + 1) % capacity`。取模运算 (`%`) 是实现“循环”的关键，它能让指针在到达数组末尾后自动“绕回”到数组开头。
*   **Dequeue**: 从 `front` 指针的位置取出元素，然后将 `front` 指针向后移动一位。`front = (front + 1) % capacity`。

**处理队列满和空的状态**:
*   **空状态**：`front == rear` (并且队列中元素数量为0)。
*   **满状态**：如何区分空状态和满状态？如果 `rear` 绕了一圈追上了 `front`，也会有 `front == rear`。为了解决这个歧义，我们通常采用两种策略之一：
    1.  **牺牲一个存储单元**：规定当 `(rear + 1) % capacity == front` 时，队列就满了。这意味着一个容量为 `k` 的数组最多只能存储 `k-1` 个元素。
    2.  **维护一个 `size` 计数器**：通过 `size` 的值来判断。`size == 0` 表示空，`size == capacity` 表示满。这种方式更直观。

我们将使用第二种方式（维护 `size` 计数器）来实现。

##### **Python 实现**

```python
class CircularQueueArray:
    """
    基于固定大小数组和 size 计数器实现的循环队列。
    所有核心操作都是 O(1)。
    """
    def __init__(self, capacity):
        if capacity <= 0:
            raise ValueError("Capacity must be a positive integer.")
        self._items = [None] * capacity
        self._capacity = capacity
        self._size = 0
        self._front = 0
        self._rear = 0

    def enqueue(self, item):
        """
        向队尾添加元素。
        时间复杂度: O(1)
        """
        if self.is_full():
            raise Exception("Queue is full")
        
        self._items[self._rear] = item
        self._rear = (self._rear + 1) % self._capacity
        self._size += 1

    def dequeue(self):
        """
        从队头移除元素。
        时间复杂度: O(1)
        """
        if self.is_empty():
            raise IndexError("dequeue from an empty queue")
        
        item = self._items[self._front]
        self._items[self._front] = None # 可选：帮助垃圾回收
        self._front = (self._front + 1) % self._capacity
        self._size -= 1
        return item

    def front(self):
        """
        查看队头元素。
        时间复杂度: O(1)
        """
        if self.is_empty():
            raise IndexError("front from an empty queue")
        return self._items[self._front]

    def is_empty(self):
        """
        检查队列是否为空。
        时间复杂度: O(1)
        """
        return self._size == 0
        
    def is_full(self):
        """
        检查队列是否已满。
        时间复杂度: O(1)
        """
        return self._size == self._capacity

    def size(self):
        """
        返回队列的大小。
        时间复杂度: O(1)
        """
        return self._size

# --- 使用示例 ---
cq = CircularQueueArray(3)
cq.enqueue(1)
cq.enqueue(2)
cq.enqueue(3)
# cq.enqueue(4) # 会引发 Exception: Queue is full

print(f"Is full? {cq.is_full()}")      # True
print(f"Front: {cq.front()}")          # 1

print(f"Dequeued: {cq.dequeue()}")    # 1
print(f"Front after dequeue: {cq.front()}") # 2
print(f"Is full? {cq.is_full()}")      # False

cq.enqueue(4) # 现在可以入队了
print(f"Front: {cq.front()}") # 2
# 此时内部数组可能是 [4, 2, 3]，front=1, rear=1, size=3
```
*(注：JS 实现与 Python 逻辑完全相同，此处为简洁省略，核心在于 `front`, `rear` 指针和模运算。)*

---

#### **5.6 双端队列 (Deque)**

**定义**：双端队列 (Deque, pronounced "deck", short for Double-Ended Queue) 是栈和队列的泛化。它是一个允许在**两端**进行元素插入和删除操作的线性集合。

**核心操作**:
*   `add_first(item)` / `add_last(item)`
*   `remove_first()` / `remove_last()`
*   `peek_first()` / `peek_last()`

你可以看到，如果只使用 `add_last` 和 `remove_first`，它就是一个标准队列。如果只使用 `add_last` 和 `remove_last`，它就是一个标准栈。

Python 的 `collections.deque` 是一个高度优化的、基于双向链表实现的双端队列。

---

**应用场景**
队列的 FIFO 特性使其在处理需要按顺序处理的任务时非常有用。

1.  **任务调度**：操作系统中的进程调度、打印机任务队列等。先发出的请求先被服务。
2.  **消息队列 (Message Queue)**：在分布式系统中，用于组件之间的解耦和异步通信。生产者将消息放入队列，消费者从队列中取出并处理。
3.  **广度优先搜索 (Breadth-First Search, BFS)**：在图和树的遍历中，BFS 算法使用队列来存储待访问的节点，确保按层级顺序进行访问。这是队列在算法领域最重要的应用之一。
4.  **缓冲 (Buffering)**：在数据流处理中，如视频播放，数据先被下载到队列缓冲区中，然后播放器按顺序从队列中取出数据进行播放，以平滑网络波动。

**本章小结:**

*   你掌握了队列是一种遵循 **FIFO (先进先出)** 原则的**抽象数据类型 (ADT)**。
*   你理解了队列的核心操作：`enqueue`, `dequeue`, `front`。
*   你分析了直接用数组实现队列的 **O(n) 效率问题**，并学习了两种高效的实现方式：
    *   **基于链表的队列**：通过维护 `head` 和 `tail` 指针，实现所有操作的 **O(1)** 复杂度。
    *   **循环队列**：通过在固定大小的数组上使用模运算，巧妙地避免了数据迁移，同样实现了 **O(1)** 复杂度。
*   你了解了队列在任务调度、异步通信和图遍历 (BFS) 等领域的广泛应用。

我们已经完成了对核心线性数据结构的学习。接下来，我们将进入一个全新的领域：非线性数据结构。我们的第一站将是计算机科学中最高效的数据结构之一。

如果对队列有任何疑问，请提出。否则，我们将进入 **第六章：哈希表 (Hash Tables)**。