当然。我们继续课程，进入第四章。这一章将介绍一个重要的抽象数据类型——栈，它在计算机科学中无处不在。

---

### **第四章：栈 (Stacks)**

在学习了数组和链表这两种基础数据存储结构之后，我们现在开始研究**抽象数据类型 (Abstract Data Type, ADT)**。ADT 定义了数据的逻辑模型和操作，而不关心其具体实现。栈，就是第一个我们将要学习的、非常重要的 ADT。

#### **4.1 栈的定义：后进先出 (LIFO) 的抽象数据类型**

**定义**：栈 (Stack) 是一种遵循**后进先出 (Last-In, First-Out, LIFO)** 原则的线性数据集合。

让我们来精确解析这个定义：
*   **线性数据集合**：栈中的元素具有逻辑上的线性顺序，就像数组和链表一样。
*   **后进先出 (LIFO)**：这是栈最核心、最根本的特性。它规定了数据的存取行为：最后被添加到栈中的元素，必须是第一个被移除的元素。
*   **受限访问**：与数组或链表不同（它们允许在任意位置进行操作），栈是一种**访问受限**的数据结构。所有的数据插入和删除操作都只能在栈的一端进行，这一端被称为**栈顶 (Top)**。另一端则被称为**栈底 (Bottom)**。

因此，栈的操作逻辑可以被严格地限定：新元素被“压入”栈顶，而移除元素时也是从栈顶“弹出”。

#### **4.2 核心操作**

一个标准的栈 ADT 定义了以下几个核心操作：

1.  **`push(element)`**
    *   **功能**：向栈顶添加一个新元素。
    *   **参数**：`element` - 要被添加到栈中的数据。
    *   **返回值**：无。

2.  **`pop()`**
    *   **功能**：移除并返回栈顶的元素。
    *   **参数**：无。
    *   **返回值**：被移除的栈顶元素。
    *   **前置条件**：该操作不能在空栈上执行。在一个空栈上调用 `pop()` 会导致一个称为**“栈下溢 (Stack Underflow)”**的错误。

3.  **`peek()`** (在某些文献中也称为 `top()`)
    *   **功能**：返回栈顶的元素，但**不**移除它。
    *   **参数**：无。
    *   **返回值**：栈顶元素。
    *   **前置条件**：该操作不能在空栈上执行，否则也会导致栈下溢。

4.  **`isEmpty()`**
    *   **功能**：检查栈是否为空。
    *   **参数**：无。
    *   **返回值**：如果栈中没有任何元素，返回 `true`；否则返回 `false`。

5.  **`size()`**
    *   **功能**：返回栈中元素的数量。
    *   **参数**：无。
    *   **返回值**：一个表示栈大小的非负整数。

现在，我们将探讨如何使用第二章和第三章学到的数据结构（数组和链表）来实现这个栈 ADT。

---

#### **4.3 基于数组实现的栈 (Array-based Stack)**

这是实现栈最直观和常见的方式。我们可以使用一个动态数组（Python 的 `list` 或 JavaScript 的 `Array`）作为底层存储。

**实现策略**：我们将数组的**末尾**视为栈的**栈顶**。
*   **为什么是末尾？** 因为动态数组在末尾进行插入（`append`/`push`）和删除（`pop`）操作的摊还时间复杂度是 O(1)。如果我们选择数组的开头作为栈顶，那么每次 `push` 和 `pop` 操作都将导致 O(n) 的时间复杂度（因为需要移动所有其他元素），这完全违背了设计栈的初衷。

##### **Python 实现**

```python
class StackArray:
    """
    基于 Python list (动态数组) 实现的栈。
    """
    def __init__(self):
        """
        初始化一个空栈。
        """
        self._items = []  # 使用一个私有列表来存储栈元素

    def push(self, item):
        """
        将元素压入栈顶。
        时间复杂度: Amortized O(1) - 基于 list.append 的性能。
        """
        self._items.append(item)

    def pop(self):
        """
        从栈顶弹出一个元素。
        时间复杂度: O(1) - 基于 list.pop (无参数) 的性能。
        """
        if self.is_empty():
            raise IndexError("pop from an empty stack") # 抛出异常以处理栈下溢
        return self._items.pop()

    def peek(self):
        """
        查看栈顶元素，不移除。
        时间复杂度: O(1)
        """
        if self.is_empty():
            raise IndexError("peek from an empty stack")
        return self._items[-1]

    def is_empty(self):
        """
        检查栈是否为空。
        时间复杂度: O(1)
        """
        return len(self._items) == 0

    def size(self):
        """
        返回栈的大小。
        时间复杂度: O(1)
        """
        return len(self._items)
        
# --- 使用示例 ---
stack = StackArray()
print(f"Is stack empty? {stack.is_empty()}") # True

stack.push(10)
stack.push(20)
stack.push(30)

print(f"Stack size: {stack.size()}") # 3
print(f"Top element (peek): {stack.peek()}") # 30

popped_item = stack.pop()
print(f"Popped item: {popped_item}") # 30
print(f"New top element: {stack.peek()}") # 20

print(f"Is stack empty? {stack.is_empty()}") # False
```

##### **JavaScript 实现**

```javascript
class StackArray {
    /**
     * 基于 JavaScript Array (动态数组) 实现的栈。
     */
    constructor() {
        /**
         * 使用一个私有数组 (通过命名约定) 来存储栈元素
         * @private
         */
        this._items = [];
    }

    /**
     * 将元素压入栈顶。
     * 时间复杂度: Amortized O(1) - 基于 Array.prototype.push 的性能。
     * @param {*} item
     */
    push(item) {
        this._items.push(item);
    }

    /**
     * 从栈顶弹出一个元素。
     * 时间复杂度: O(1) - 基于 Array.prototype.pop 的性能。
     * @returns {*}
     */
    pop() {
        if (this.isEmpty()) {
            throw new Error("pop from an empty stack"); // 抛出异常以处理栈下溢
        }
        return this._items.pop();
    }

    /**
     * 查看栈顶元素，不移除。
     * 时间复杂度: O(1)
     * @returns {*}
     */
    peek() {
        if (this.isEmpty()) {
            throw new Error("peek from an empty stack");
        }
        return this._items[this._items.length - 1];
    }

    /**
     * 检查栈是否为空。
     * 时间复杂度: O(1)
     * @returns {boolean}
     */
    isEmpty() {
        return this._items.length === 0;
    }

    /**
     * 返回栈的大小。
     * 时间复杂度: O(1)
     * @returns {number}
     */
    size() {
        return this._items.length;
    }
}

// --- 使用示例 ---
const stack = new StackArray();
console.log(`Is stack empty? ${stack.isEmpty()}`); // true

stack.push(10);
stack.push(20);
stack.push(30);

console.log(`Stack size: ${stack.size()}`); // 3
console.log(`Top element (peek): ${stack.peek()}`); // 30

const poppedItem = stack.pop();
console.log(`Popped item: ${poppedItem}`); // 30
console.log(`New top element: ${stack.peek()}`); // 20

console.log(`Is stack empty? ${stack.isEmpty()}`); // false
```

---

#### **4.4 基于链表实现的栈 (Linked List-based Stack)**

我们也可以使用链表来实现栈。这种实现方式能够提供**真正的 O(1)** 复杂度，因为它不涉及动态数组的扩容机制。

**实现策略**：我们将链表的**头部**视为栈的**栈顶**。
*   **为什么是头部？** 因为在单向链表的头部进行插入（`prepend`）和删除（删除 `head`）操作的时间复杂度是 O(1)。如果我们选择链表尾部作为栈顶，`pop` 操作需要遍历整个链表找到倒数第二个节点，时间复杂度为 O(n)。

##### **Python 实现**

```python
# 我们需要一个 Node 类，和上一章一样
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class StackLinkedList:
    """
    基于链表实现的栈。
    """
    def __init__(self):
        self._top = None  # _top 指向链表的头节点，也就是栈顶
        self._size = 0

    def push(self, item):
        """
        将元素压入栈顶。
        时间复杂度: O(1)
        """
        new_node = Node(item)
        new_node.next = self._top
        self._top = new_node
        self._size += 1

    def pop(self):
        """
        从栈顶弹出一个元素。
        时间复杂度: O(1)
        """
        if self.is_empty():
            raise IndexError("pop from an empty stack")
        
        data_to_return = self._top.data
        self._top = self._top.next
        self._size -= 1
        return data_to_return

    def peek(self):
        """
        查看栈顶元素，不移除。
        时间复杂度: O(1)
        """
        if self.is_empty():
            raise IndexError("peek from an empty stack")
        return self._top.data

    def is_empty(self):
        """
        检查栈是否为空。
        时间复杂度: O(1)
        """
        return self._size == 0

    def size(self):
        """
        返回栈的大小。
        时间复杂度: O(1)
        """
        return self._size

# --- 使用示例 ---
stack_ll = StackLinkedList()
stack_ll.push('A')
stack_ll.push('B')
stack_ll.push('C')
print(f"Stack size: {stack_ll.size()}") # 3
print(f"Top element: {stack_ll.peek()}") # 'C'
print(f"Popped: {stack_ll.pop()}") # 'C'
print(f"New top: {stack_ll.peek()}") # 'B'
```

##### **JavaScript 实现**

```javascript
// 需要一个 Node 类
class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

class StackLinkedList {
    /**
     * 基于链表实现的栈。
     */
    constructor() {
        this._top = null; // _top 指向链表的头节点，也就是栈顶
        this._size = 0;
    }

    /**
     * 将元素压入栈顶。
     * 时间复杂度: O(1)
     * @param {*} item
     */
    push(item) {
        const newNode = new Node(item);
        newNode.next = this._top;
        this._top = newNode;
        this._size++;
    }

    /**
     * 从栈顶弹出一个元素。
     * 时间复杂度: O(1)
     * @returns {*}
     */
    pop() {
        if (this.isEmpty()) {
            throw new Error("pop from an empty stack");
        }
        const dataToReturn = this._top.data;
        this._top = this._top.next;
        this._size--;
        return dataToReturn;
    }

    /**
     * 查看栈顶元素，不移除。
     * 时间复杂度: O(1)
     * @returns {*}
     */
    peek() {
        if (this.isEmpty()) {
            throw new Error("peek from an empty stack");
        }
        return this._top.data;
    }

    /**
     * 检查栈是否为空。
     * 时间复杂度: O(1)
     * @returns {boolean}
     */
    isEmpty() {
        return this._size === 0;
    }

    /**
     * 返回栈的大小。
     * 时间复杂度: O(1)
     * @returns {number}
     */
    size() {
        return this._size;
    }
}

// --- 使用示例 ---
const stackLl = new StackLinkedList();
stackLl.push('A');
stackLl.push('B');
stackLl.push('C');
console.log(`Stack size: ${stackLl.size()}`); // 3
console.log(`Top element: ${stackLl.peek()}`); // 'C'
console.log(`Popped: ${stackLl.pop()}`); // 'C'
console.log(`New top: ${stackLl.peek()}`); // 'B'
```

---

#### **4.5 应用场景**

栈的 LIFO 特性使其在计算机科学中有广泛应用。

1.  **函数调用栈 (Function Call Stack)**：这是最核心的应用。当你调用一个函数时，系统会创建一个**栈帧 (Stack Frame)**，包含该函数的局部变量、参数和返回地址，并将其**压入**一个全局的调用栈。如果这个函数又调用了另一个函数，新函数的栈帧会被压入栈顶。当一个函数执行完毕返回时，它的栈帧会从栈顶**弹出**，控制权交还给调用者。递归函数的执行就完美地体现了这一过程。如果递归没有终止条件，会导致栈被无限压入，最终耗尽内存，这就是**“栈溢出 (Stack Overflow)”**错误的由来。

2.  **括号匹配 (Parenthesis Matching)**：判断一个包含多种括号 `()[]{}` 的字符串是否有效。
    *   **算法**：遍历字符串，遇到开括号 `( { [` 就压入栈。遇到闭括号 `) } ]` 就检查栈顶：如果栈为空或栈顶的开括号与当前闭括号不匹配，则字符串无效；如果匹配，则从栈中弹出一个元素。遍历结束后，如果栈为空，则字符串有效。
    *   **原理**：LIFO 原则确保了最后打开的括号必须最先被关闭。

3.  **浏览器的“后退”功能**：你每访问一个新页面，其 URL 就被压入一个栈中。当你点击“后退”按钮时，就从栈顶弹出一个 URL，并跳转到该页面。

4.  **表达式求值与转换**：例如，将中缀表达式 `(3 + 4) * 5` 转换为后缀表达式（逆波兰表达式） `3 4 + 5 *`，这个转换过程需要使用栈。而后缀表达式的求值，同样也依赖于栈。

**本章小结:**

*   你掌握了栈是一种遵循 **LIFO (后进先出)** 原则的**抽象数据类型 (ADT)**。
*   你理解了栈的核心操作：`push`, `pop`, `peek`, `isEmpty`。
*   你学习并亲手实现了两种主要的栈：
    *   **基于数组的栈**：简单直观，利用了动态数组末尾操作的高效性 (摊还 O(1))。
    *   **基于链表的栈**：利用了链表头部操作的高效性，提供了真正的 O(1) 性能。
*   你了解了栈在函数调用、语法解析等计算机科学核心领域的关键作用。

栈的 LIFO 模型与即将学习的队列的 FIFO 模型形成了鲜明对比。这两种结构是许多复杂算法和数据结构的基础。

如果对栈有任何疑问，请提出。否则，我们将进入 **第五章：队列 (Queues)**。