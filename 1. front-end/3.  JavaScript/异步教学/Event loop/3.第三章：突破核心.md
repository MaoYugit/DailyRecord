### ** 第三章：突破核心**

**目标：** “微任务和宏任务，”

**本章学习理念：** 在我们已经建立的模型上，引入一个全新的、更高优先级的队列——微任务队列。我们将通过对比和实例，彻底搞懂两种任务的执行时机和黄金法则，将我们的知识体系提升到“准专家”级别。

---

#### **第一节：一个“插队”的VIP客户 —— 微任务的登场**

在第二章，我们建立了一个清晰的模型：同步代码执行完毕 -> 调用栈清空 -> 事件循环从任务队列取任务执行。

这个模型在处理`setTimeout`等传统异步任务时是完全正确的。但是，随着技术的发展（特别是ES6中Promise的出现），引入了一种新的异步任务类型，它的行为似乎“不守规矩”。

看下面这个例子：

```javascript
console.log('script start');

setTimeout(function() {
    console.log('setTimeout');
}, 0);

Promise.resolve().then(function() {
    console.log('promise1');
}).then(function() {
    console.log('promise2');
});

console.log('script end');
```

如果按照我们第二章的模型，`setTimeout`的回调和`Promise.then`的回调都应该被放入“任务队列”，然后按顺序执行。你可能会猜测输出是：
`script start` -> `script end` -> `setTimeout` -> `promise1` -> `promise2`  (或者promise和setTimeout顺序不确定)

但如果你运行这段代码，你会得到一个非常确定的结果：
`script start` -> `script end` -> **`promise1`** -> **`promise2`** -> `setTimeout`

**为什么Promise的回调插队了？** 而且插得如此霸道，甚至在`setTimeout`（即使是0ms延迟）之前执行？

答案是：**它们排的根本不是同一个队！**

为了解释这个现象，我们必须对第二章的“任务队列”进行升级。实际上，它分为两种完全不同的队列：

1.  **宏任务队列 (Macrotask Queue):**
    *   **就是我们之前所说的“任务队列”。**
    *   **包含的任务类型：**
        *   `script`（整体代码块，这是第一个宏任务）
        *   `setTimeout`, `setInterval`
        *   `requestAnimationFrame` (专门用于渲染，我们第四章再细说)
        *   I/O 操作, UI 渲染等

2.  **微任务队列 (Microtask Queue):**
    *   **这是一个全新的、具有更高优先级的队列。**
    *   **包含的任务类型：**
        *   `Promise.then()`, `Promise.catch()`, `Promise.finally()` 的回调
        *   `async/await` 中的 `await` 后面的代码 (本质是Promise)
        *   `MutationObserver`
        *   `process.nextTick` (Node.js环境，优先级甚至高于其他微任务)

**核心区别：** 事件循环在处理这两个队列时，遵循着一条**铁律**，这是本章最重要的知识点。

#### **第二节：黄金执行法则 —— 事件循环的完整描述**

现在，让我们揭晓事件循环完整、精确的工作流程。请牢牢记住这条法则，它能解释一切！

**事件循环的每一次循环（tick），都遵循以下步骤：**

1.  **执行一个宏任务 (Execute one macrotask):**
    *   从**宏任务队列**中，取出一个最老的任务来执行。
    *   在我们的例子中，第一个要执行的宏任务就是整个`<script>`标签里的所有同步代码。

2.  **执行所有微任务 (Execute all microtasks):**
    *   在刚刚那个宏任务执行完毕后，**立即**检查**微任务队列**。
    *   如果微任务队列不为空，就**循环执行**队列中的所有微任务，直到**微任务队列被清空**为止。
    *   **最关键的一点：** 如果在执行微任务的过程中，又产生了**新的微任务**，那么这些新产生的微任务也会被**追加到当前队列的末尾**，并**在同一个tick内被立即执行**。

3.  **（可选）进行UI渲染 (UI Rendering):**
    *   在所有微任务被清空后，浏览器会评估是否需要进行页面渲染。
    *   **注意：** 渲染不是每次tick都发生，浏览器会根据刷新率、页面性能等因素来决定。

4.  **回到第一步，准备下一个宏任务。**

用一句话总结这条黄金法则就是：**“一次宏任务，清空微任务，可能加一次渲染”。**

#### **第三节：实战演练 —— 用黄金法则破解谜题**

现在，我们用这条黄金法则，来一步步拆解第一节的那个例子，看看为什么会得到那个输出顺序。

**代码：**
```javascript
console.log('script start'); // A

setTimeout(function() { // B
    console.log('setTimeout');
}, 0);

Promise.resolve().then(function() { // C
    console.log('promise1');
}).then(function() { // D
    console.log('promise2');
});

console.log('script end'); // E
```

**分析开始 (第一个tick):**

1.  **执行宏任务 (`<script>`):**
    *   **A:** `console.log('script start')` 执行。
        *   **输出:** `script start`
    *   **B:** 遇到 `setTimeout`。这是一个宏任务。它的回调函数被交给Web API，然后Web API会把它放入**宏任务队列**。
        *   **宏任务队列:** `[setTimeout callback]`
    *   **C:** 遇到 `Promise.resolve().then()`。`.then()`的回调是一个微任务。它被放入**微任务队列**。
        *   **微任务队列:** `[promise1 callback]`
    *   **E:** `console.log('script end')` 执行。
        *   **输出:** `script end`

2.  **第一个宏任务 (`<script>`) 执行完毕！**
    *   **黄金法则第二步：** 立即检查并清空**微任务队列**。
    *   **检查微任务队列:** 发现队列不为空，里面有 `[promise1 callback]`。
    *   **执行微任务:**
        *   取出 `promise1 callback` 并执行。
            *   **输出:** `promise1`
        *   这个`.then()`执行后返回一个新的Promise，并立即注册了下一个`.then()` (也就是 **D**)。这个新的`.then()`回调又是一个**新的微任务**！
        *   **新的微任务被加入队列末尾。**
            *   **微任务队列:** `[promise2 callback]`
    *   **再次检查微任务队列:** 发现队列还不为空！**必须继续执行**。
    *   **执行微任务:**
        *   取出 `promise2 callback` 并执行。
            *   **输出:** `promise2`
    *   **再次检查微任务队列:** 现在队列终于**空了**。

3.  **微任务清空完毕！**
    *   **黄金法则第三步：** 浏览器评估是否需要渲染（此例中无UI变化）。

4.  **第一个tick结束。事件循环准备进入下一个tick。**

**分析开始 (第二个tick):**

1.  **执行宏任务:**
    *   事件循环检查**宏任务队列**，发现里面有 `[setTimeout callback]`。
    *   取出并执行它。
        *   **输出:** `setTimeout`

2.  **第二个宏任务执行完毕。**
    *   **检查微任务队列：** 空的。
    *   **渲染：** 无。

3.  **第二个tick结束。** 两个队列都空了，程序等待新的事件。

**最终输出顺序：** `script start`, `script end`, `promise1`, `promise2`, `setTimeout`。
完全吻合！黄金法则完美地解释了这个现象。

---

**第三章总结与作业**

太棒了！你已经征服了Event Loop中最陡峭的山峰！现在你已经：

*   知道了任务队列分为**宏任务**和**微任务**两种。
*   掌握了它们各自包含的典型任务类型。
*   将**“一次宏任务，清空微任务”** 这条黄金执行法则刻在了心里。
*   能够运用这条法则，准确预测包含Promise和setTimeout的复杂异步代码的输出。

**本章作业 (Action Item):**

1.  **必做！** 将本章开头的代码例子，在纸上或者白板上，画出**宏任务队列**和**微任务队列**两个“盒子”，亲手模拟一遍所有任务的入队和出队过程。这个动手过程至关重要！
2.  **挑战题：** 分析并预测上一章我们最后的“天王级”面试题的输出。现在你有了微任务的知识，特别是 `await` 关键字的行为（`await` 后面的代码会被放入微任务队列），你应该能解开它了！
    ```javascript
    async function async1() {
      console.log('async1 start');
      await async2(); // 关键在这里！
      console.log('async1 end');
    }
    // ... (完整代码见第二章末尾)
    ```
3.  **阅读:** 在MDN上搜索 **"Using microtasks"** 或者 "In-depth: Microtasks and the event loop"，这些文章会用更官方的语言来印证你今天学到的知识。

你已经走过了最艰难的一段路。从下一章开始，我们将把视野放得更宽，看看Event Loop如何与浏览器的渲染协同工作，以及在Node.js这个不同的环境中它又有什么样的变体。

你做得非常出色，为你感到骄傲！我们第四章见！