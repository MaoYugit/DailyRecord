### **第 9 课：过渡与动画（Transitions & Animations）**

过渡和动画是现代 Web 设计中不可或缺的一部分。它们不仅仅是为了“炫酷”，一个好的动态效果可以：

*   **引导用户视线**：平滑地展示或隐藏元素。
*   **提供状态反馈**：按钮按下时的交互效果。
*   **提升愉悦感**：让用户觉得界面是有生命力的，而不是冰冷的。

#### **核心思想：平滑的状态变化**

过渡和动画的本质，都是让一个 CSS 属性值从 **起始状态 A** 平滑地变化到 **结束状态 B**，而不是瞬间完成。

*   **过渡 (Transition)**：更简单，由一个**明确的事件触发**（比如 `:hover`, `:focus` 或通过 JavaScript 添加/移除一个类），用于实现两个状态间的平滑变化。
*   **动画 (Animation)**：更强大，可以**自动播放**，可以**循环**，并且可以定义**多个关键帧（keyframes）**，实现从 A 到 B 到 C 再到 D 的复杂路径。

---

### **深度剖析 1：`transition` —— 简单的状态切换**

`transition` 属性是一个简写属性，通常包含四个子属性：

1.  **`transition-property`**: 你想要为哪个 CSS 属性添加过渡效果。比如 `background-color`, `transform`。
2.  **`transition-duration`**: 过渡效果持续的时间。比如 `0.3s` 或 `300ms`。
3.  **`transition-timing-function`**: 过渡的速度曲线，即“如何”变化。
    *   `ease` (默认): 慢-快-慢
    *   `linear`: 匀速
    *   `ease-in`: 慢-快
    *   `ease-out`: 快-慢
    *   `ease-in-out`: 慢-快-慢 (比 `ease` 更平缓)
    *   `cubic-bezier(...)`: 自定义贝塞尔曲线，可以创造出非常有弹性的效果。
4.  **`transition-delay`**: 延迟多久后才开始过渡。

**简写语法（推荐使用）：**
`transition: property duration timing-function delay;`

**实战例子：一个按钮的悬停效果**
```html
<button class="btn">Hover Me</button>
```
``````css
.btn {
  background-color: #3498db;
  color: white;
  padding: 1rem 2rem;
  border: none;
  cursor: pointer;
  /* 定义过渡效果 */
  /* 当 background-color 和 transform 属性变化时，用 0.3s 的时间，以 ease-out 曲线完成过渡 */
  transition: background-color 0.3s ease-out, transform 0.3s ease-out;
}

.btn:hover {
  background-color: #2980b9;
  /* 在悬停时，让按钮稍微向上移动一点点 */
  transform: translateY(-3px);
}
``````

**关键点**：`transition` 属性必须定义在**元素的默认状态**上，而不是 `:hover` 状态上。这样才能保证鼠标移入和移出时都有平滑的过渡效果。

---

### **深度剖析 2：`animation` & `@keyframes` —— 复杂的动画序列**

当你需要更复杂的、多步骤的动画时，就需要 `animation` 和 `@keyframes` 联手了。

**第一步：用 `@keyframes` 定义动画**
`@keyframes` 就像一个动画的“剧本”，你可以在里面定义动画在不同时间点的状态。

```css
/* 定义一个名为 'fadeInUp' 的动画 */
@keyframes fadeInUp {
  from { /* 相当于 0% */
    opacity: 0;
    transform: translateY(20px);
  }
  to { /* 相当于 100% */
    opacity: 1;
    transform: translateY(0);
  }
}
```
你也可以定义更复杂的中间步骤：
```css
@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
}
```

**第二步：用 `animation` 属性“播放”动画**
`animation` 也是一个简写属性，包含了多个子属性：

*   `animation-name`: 要播放的 `@keyframes` 的名字。
*   `animation-duration`: 动画持续时间。
*   `animation-timing-function`: 速度曲线 (同 `transition`)。
*   `animation-delay`: 延迟播放。
*   `animation-iteration-count`: 播放次数。可以是数字，也可以是 `infinite` (无限循环)。
*   `animation-direction`: 播放方向。`normal` (正向), `reverse` (反向), `alternate` (正反交替)。
*   `animation-fill-mode`: 动画结束后的状态。`forwards` (停在最后一帧), `backwards` (停在第一帧), `both`。

**实战例子：一个加载中的旋转图标**
```html
<div class="spinner"></div>
``````css
@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.spinner {
  width: 50px;
  height: 50px;
  border: 5px solid #eee;
  border-top-color: #3498db;
  border-radius: 50%;
  /* 播放动画 */
  /* 播放名为 'spin' 的动画，持续1秒，匀速，无限循环 */
  animation: spin 1s linear infinite;
}
```

---

### **性能优化：为什么只用 `transform` 和 `opacity`？**

这是一个**非常重要**的面试点和实战技巧。

浏览器渲染页面的过程大致可以分为：`Layout` -> `Paint` -> `Composite`。

*   **Layout (布局/重排)**: 当你改变一个元素的尺寸、位置（比如 `width`, `height`, `left`, `top`, `margin`）时，浏览器需要重新计算所有元素的位置和几何结构。这个过程非常耗费性能。
*   **Paint (绘制/重绘)**: 当你改变元素的背景色、颜色、阴影等外观属性时，浏览器需要重新“绘制”这个元素。
*   **Composite (合成)**: 这是最后一步。浏览器将各个图层（layers）像PS图层一样合并到一起，最终显示在屏幕上。

**关键在于**：
*   改变 `transform` (移动、缩放、旋转) 和 `opacity` (透明度) 这两个属性，浏览器可以**跳过 `Layout` 和 `Paint` 阶段**，直接在 GPU (图形处理器) 中进行 `Composite` (合成)。这个过程非常快，不会阻塞主线程，动画会非常流畅，尤其是在移动设备上。
*   而改变 `left`, `top`, `margin` 等属性会触发**重排 (Layout)**，改变 `background-color` 会触发**重绘 (Paint)**，这些操作都在 CPU 中进行，性能开销大，容易导致动画卡顿。

**结论**：在制作动画时，**优先使用 `transform` 来实现位移、缩放和旋转，用 `opacity` 来实现淡入淡出**。尽量避免对会触发重排和重绘的属性进行动画。

---

### **面试焦点**

**面试官问：“`transition` 和 `animation` 有什么区别？”**

> **你的回答**：“它们都用于创建动态效果，但核心区别在于复杂度和控制性。
>
> *   `transition` 用于实现**两个状态**之间的平滑过渡。它需要一个明确的触发条件（如 `:hover` 或类名变化），更适合简单的交互反馈。
> *   `animation` 则可以定义一个**多步骤的动画序列**，通过 `@keyframes` 可以精确控制动画的每一个阶段。它可以自动播放、无限循环，更适合创建复杂的、自驱动的动画效果。
>
> 简单来说，`transition` 是点对点的简单动画，而 `animation` 是可以设定完整路径的复杂动画。”

**面试官问：“CSS 动画的性能优化有什么技巧？”**

> **你的回答**：“最重要的性能优化技巧是**尽可能地让动画在合成器线程（Compositor Thread）中完成，避免触发重排（Reflow/Layout）和重绘（Repaint）**。
>
- **优先使用 `transform` 和 `opacity`**：对 `transform` (尤其是 `translate`, `scale`, `rotate`) 和 `opacity` 属性进行动画，可以被 GPU 加速，因为它们不会触发重排和重绘，只在合成阶段处理。
> - **避免对几何属性和外观属性做动画**：尽量不要对 `width`, `height`, `margin`, `left`, `top` 或 `background-color` 等属性进行动画，因为它们会分别导致昂贵的重排和重绘操作。
> - **使用 `will-change` 属性**：可以提前告知浏览器某个元素即将发生变化，让浏览器有机会对其进行优化，比如提前为该元素创建一个独立的合成层。但这个属性不应滥用，因为它会消耗额外的内存。”

---

### **实战任务**

我们来创建一个带动画效果的模态框（Modal）弹出效果。

**HTML 结构:**
```html
<button id="open-modal-btn">Open Modal</button>

<div class="modal-overlay">
  <div class="modal-content">
    <h3>Modal Title</h3>
    <p>This is a modal window. You can do anything here.</p>
    <button id="close-modal-btn">Close</button>
  </div>
</div>
```

**你的任务：**
1.  **基础样式**:
    *   `.modal-overlay` 是一个 `position: fixed` 的全屏遮罩层，默认 `display: none`。
    *   `.modal-content` 是在遮罩层中居中的内容框。
2.  **创建打开/关闭的类**:
    *   创建一个 `.is-visible` 类。当 `.modal-overlay` 拥有这个类时，它应该变为 `display: flex` (或其他方式) 显示出来。
    *   (你需要写一点点 JavaScript 来控制这个类的添加和移除，这很简单)。
3.  **使用 `transition` 实现淡入淡出**:
    *   给 `.modal-overlay` 的 `opacity` 属性添加一个 `transition` 效果。
    *   默认状态 `opacity: 0;`，在 `.is-visible` 状态下 `opacity: 1;`。
4.  **使用 `animation` 和 `@keyframes` 实现内容弹出效果**:
    *   定义一个名为 `slideInUp` 的 `@keyframes`，让元素从下方 (`transform: translateY(50px)`) 伴随着透明度从 0 到 1 移动到最终位置 (`transform: translateY(0)`)。
    *   当 `.modal-overlay` 拥有 `.is-visible` 类时，给 `.modal-content` 应用这个 `slideInUp` 动画。

**JavaScript 提示 (可以放在 `<script>` 标签里):**
```javascript
const openBtn = document.getElementById('open-modal-btn');
const closeBtn = document.getElementById('close-modal-btn');
const overlay = document.querySelector('.modal-overlay');

openBtn.addEventListener('click', () => {
  overlay.classList.add('is-visible');
});

closeBtn.addEventListener('click', () => {
  overlay.classList.remove('is-visible');
});
```
这个任务将让你同时实践 `transition` 和 `animation`，并构建出一个非常专业、体验流畅的 UI 组件。
