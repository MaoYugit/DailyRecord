### **核心概念：主轴 (Main Axis) 与交叉轴 (Cross Axis)**

在开始之前，必须理解 Flexbox 的两个基本概念，这是理解所有属性的前提：

1.  **Flex 容器 (Flex Container)**: 设置了 `display: flex` 或 `display: inline-flex` 的元素。
2.  **Flex 项目 (Flex Items)**: Flex 容器的直接子元素。

Flexbox 布局是基于**主轴**和**交叉轴**的。

*   **主轴 (Main Axis)**: Flex 项目沿着其排列的主要方向。**它不一定是水平的**。
*   **交叉轴 (Cross Axis)**: 与主轴垂直的方向。

这两个轴的方向完全由 `flex-direction` 属性决定，这是理解一切的关键。

![Flexbox Axes](https://css-tricks.com/wp-content/uploads/2018/10/flex-axis.svg)

---

### 1. `display: flex`

这是启动 Flexbox 布局的“开关”。

#### 详细介绍

*   **作用**: 将一个元素声明为 Flex 容器，从而为其直接子元素创建一个**弹性格式化上下文 (Flex Formatting Context)**。
*   **效果**:
    *   容器的直接子元素（Flex 项目）会立即表现出 Flex 布局的特性。
    *   Flex 项目默认会**在一行内**水平排列（基于 `flex-direction` 的默认值 `row`）。
    *   Flex 项目会忽略 `float`, `clear`, 和 `vertical-align` 属性。
    *   Flex 项目之间的外边距**不会折叠** (Margin Collapsing)。

#### 代码示例

```html
<div class="container">
  <div>Item 1</div>
  <div>Item 2</div>
  <div>Item 3</div>
</div>``````css
.container {
  display: flex;
  border: 2px solid steelblue;
}

.container div {
  border: 1px solid tomato;
  padding: 10px;
}
```
**结果**: 三个 `<div>` 会并排在一行，即使它们是块级元素。这就是 Flexbox 的魔力。

#### 常见陷阱和面试点

*   **面试题**: “一个容器设置了 `display: flex`，它的子元素上设置 `float: left` 会有什么效果？”
    *   **回答**: **没有效果**。一旦一个元素成为了 Flex 项目，`float`, `clear` 和 `vertical-align` 属性就会失效。这是 Flex 格式化上下文的规则之一。

---

### 2. `flex-direction`

该属性是 Flexbox 的“指南针”，它定义了主轴的方向，从而决定了 Flex 项目的排列方向。

#### 详细介绍与常见值

*   `row` (默认值): 主轴为水平方向，从左到右。交叉轴为垂直方向。
*   `row-reverse`: 主轴为水平方向，从右到左。
*   `column`: 主轴为垂直方向，从上到下。交叉轴为水平方向。
*   `column-reverse`: 主轴为垂直方向，从下到上。

#### 代码示例

```css
.container {
  display: flex;
  height: 200px; /* 给容器一个高度以便观察 */
  border: 2px solid steelblue;
}

/* 将 flex-direction 设置为 column */
.container.column-layout {
  flex-direction: column;
}
```
**结果**: 在 `.column-layout` 容器中，三个项目会从上到下垂直堆叠。

#### 常见陷阱和面试点

*   **面试题**: “当 `flex-direction` 设置为 `column` 时，`justify-content` 和 `align-items` 分别控制哪个方向的对齐？”
    *   **回答**: 这是一个**核心概念**的考察。
        *   `justify-content` **永远**控制**主轴**方向的对齐。当 `flex-direction: column` 时，主轴是**垂直的**，所以 `justify-content` 控制的是**垂直方向**的对齐。
        *   `align-items` **永远**控制**交叉轴**方向的对齐。当 `flex-direction: column` 时，交叉轴是**水平的**，所以 `align-items` 控制的是**水平方向**的对齐。
    *   很多初学者会误以为 `justify-content` 总是水平，`align-items` 总是垂直，这是错误的。它们是相对于**动态的主轴和交叉轴**来工作的。

---

### 3. `justify-content`

定义了 Flex 项目在**主轴**上的对齐方式和空间分配。

#### 详细介绍与常见值

*   `flex-start` (默认值): 项目向主轴的起始位置对齐。
*   `flex-end`: 项目向主轴的结束位置对齐。
*   `center`: 项目在主轴上居中对齐。
*   `space-between`: **两端对齐**。第一个项目在主轴起点，最后一个项目在主轴终点，剩余项目之间的间距相等。
*   `space-around`: **环绕对齐**。每个项目两侧的间距相等。因此，项目之间的间距是两端间距的两倍。
*   `space-evenly`: **均分对齐**。所有项目之间的间距，以及项目与容器边缘的间距，都完全相等。

#### 代码示例与经典面试题

```css
.container { display: flex; }
.container.jc-space-between { justify-content: space-between; }
.container.jc-space-around  { justify-content: space-around; }
.container.jc-space-evenly  { justify-content: space-evenly; }
```

*   **面试题**: “请解释 `space-between`, `space-around`, 和 `space-evenly` 的区别。”
    *   **回答** (结合图示或手绘更佳):
        *   `space-between`: `|Item|--|Item|--|Item|` (边距只在项目之间)
        *   `space-around`: `|-|Item|--|Item|--|Item|-|` (每个项目两侧边距相等，所以中间的间距是两边的两倍)
        *   `space-evenly`: `|--|Item|--|Item|--|Item|--|` (所有间距，包括两端的，都完全相等)

---

### 4. `align-items`

定义了 Flex 项目在**交叉轴**上的对齐方式（当只有一行时）。

#### 详细介绍与常见值

*   `stretch` (默认值): 如果项目未设置高度（或宽度，取决于交叉轴方向），则会拉伸以填满容器的整个交叉轴高度。
*   `flex-start`: 项目向交叉轴的起始位置对齐。
*   `flex-end`: 项目向交叉轴的结束位置对齐。
*   `center`: 项目在交叉轴上居中对齐。
*   `baseline`: 项目根据其内容的第一行文字的**基线**对齐。

#### 代码示例

```css
.container {
  display: flex;
  height: 150px; /* 必须有高度才能看出效果 */
  align-items: center; /* 所有项目在容器中垂直居中 */
  border: 2px solid steelblue;
}

.container div:nth-child(2) {
  font-size: 2em; /* 让一个项目更高，以便观察对齐效果 */
}
```
**结果**: 即使项目内容高度不同，它们也会在容器的垂直中心线上对齐。这就是 **Flexbox 轻松实现垂直居中**的秘密。

---

### 5. `flex-wrap`

定义了当一条主轴线排不下所有 Flex 项目时，项目是否换行以及如何换行。

#### 详细介绍与常见值

*   `nowrap` (默认值): **不换行**。如果项目总宽度超过容器宽度，项目会自动收缩（基于 `flex-shrink` 属性）。
*   `wrap`: **换行**。项目会从上到下，按需换到新的一行。
*   `wrap-reverse`: **反向换行**。项目会从下到上，换到新的一行。

#### 代码示例

```css
.container {
  display: flex;
  flex-wrap: wrap; /* 允许项目换行 */
  width: 350px; /* 限制容器宽度 */
  border: 2px solid steelblue;
}

.container div {
  width: 100px; /* 每个项目固定宽度 */
  height: 50px;
  border: 1px solid tomato;
}
```
**结果**: 因为容器宽度为 350px，而每个项目宽 100px，所以一行只能放下 3 个。第 4 个和第 5 个项目会自动换到下一行。

---

### **终极面试陷阱：`align-items` vs `align-content`**

这是区分 Flexbox 掌握程度的**必考题**。

*   **面试题**: "`align-items` 和 `align-content` 有什么区别？"
*   **回答**:
    *   **作用域不同**:
        *   `align-items` 作用于**单行**。它定义了**一行之内**的项目在交叉轴上如何对齐。即使有多行，它控制的也是每一行内部的项目对齐。
        *   `align-content` 作用于**多行**。它**只有在 `flex-wrap` 为 `wrap` 或 `wrap-reverse` 并且有多行项目时才生效**。它定义了**多行作为一个整体**在交叉轴上如何分布和对齐。
    *   **类比**:
        *   可以把 `align-items` 想象成 `justify-content` 在交叉轴上的“单行版”。
        *   可以把 `align-content` 想象成 `justify-content` 在交叉轴上的“多行版”，它的值（如 `space-between`, `space-around` 等）和 `justify-content` 非常相似，但作用于行与行之间。

#### 示例来解释 `align-items` vs `align-content`

```css
.container {
  display: flex;
  flex-wrap: wrap;
  height: 400px; /* 关键：给容器一个足够的高度来看效果 */
  width: 250px;
  border: 2px solid steelblue;
  
  /* 试试切换下面这两个属性 */
  align-items: center; /* 这会让每一行内部的项目垂直居中 */
  align-content: space-between; /* 这会让第一行贴顶，最后一行贴底，中间的行均分剩余空间 */
}

.container div {
  width: 100px;
  height: 100px; /* 固定高度，避免 stretch 影响 */
}
```
在这个例子中：
*   `align-items: center;` 会使项目在它们各自的 100px 高的行内居中（效果不明显，因为项目和行一样高）。
*   `align-content: space-between;` 会将两行项目作为一个整体，第一行贴着容器顶部，第二行贴着容器底部，中间是巨大的空白。这清晰地展示了 `align-content` 是在控制**行与行**之间的关系。

| 属性            | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| display: flex   | 将元素定义为弹性容器                                         |
| flex-direction  | 设置弹性项目的主轴方向                                       |
| justify-content | 定义了浏览器如何分配顺着弹性容器主轴的弹性元素之间及其周围的空间 |
| align-items     | 定义弹性项目在交叉轴上如何对齐                               |
| flex-wrap       | 指定弹性项目是否换行                                         |

