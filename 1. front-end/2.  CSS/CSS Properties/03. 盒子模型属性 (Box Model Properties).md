### 核心概念：CSS 盒子模型

在讲解具体属性前，必须先理解盒子模型。浏览器渲染的每个元素都可以看作一个矩形的盒子。这个盒子由四个部分组成，从内到外依次是：

1.  **Content (内容)**: 盒子的核心，显示文本、图片等实际内容。`width` 和 `height` 属性设置的就是这个区域的尺寸。
2.  **Padding (内边距)**: 包裹在内容区域外部的透明区域。它位于内容和边框之间。
3.  **Border (边框)**: 包裹在内边距外部的区域。
4.  **Margin (外边距)**: 包裹在边框外部的透明区域，用于控制盒子与其他元素之间的距离。

---

### 超级重点：`box-sizing` 属性 (面试必考)

在深入 width/height 之前，必须先了解 `box-sizing`，因为它彻底改变了 `width` 和 `height` 的计算方式。

*   **`box-sizing: content-box;` (默认值, W3C标准盒模型)**
    *   你设置的 `width` 和 `height` **只应用于内容 (Content) 区域**。
    *   元素的**实际总宽度** = `width` + `padding-left` + `padding-right` + `border-left` + `border-right`。
    *   这会导致一个问题：给一个 `width: 100px;` 的元素增加 `padding: 20px;`，它的视觉宽度会变成 140px，这通常不是我们想要的，布局会因此“撑破”。

*   **`box-sizing: border-box;` (推荐值, IE盒模型/怪异盒模型)**
    *   你设置的 `width` 和 `height` **包含了内容、内边距和边框**。
    *   元素的**实际总宽度** = 你设置的 `width` 值。`padding` 和 `border` 会被“向内”挤压内容空间，而不是“向外”扩张总尺寸。
    *   这是现代 CSS 开发的**最佳实践**。它让布局计算变得极其直观。

#### 最佳实践 & 面试代码

面试官可能会让你写出“重置”CSS，以下代码是现代项目几乎必备的：

```css
html {
  box-sizing: border-box;
}

*, *::before, *::after {
  box-sizing: inherit; /* 让所有元素都继承 html 的 box-sizing 设置 */
}
```

> **接下来的所有例子，我们都默认已经设置了 `box-sizing: border-box;`**

---

### 1. `width` 和 `height`

设置元素内容、内边距和边框所占区域的宽度和高度（在 `border-box` 模型下）。

#### 详细介绍

*   **适用性**：主要对**块级元素 (block)** 和**行内块元素 (inline-block)** 生效。
*   **对行内元素 (inline) 无效**：给一个 `<span>` 或 `<a>` 设置 `width` 和 `height` 是没有效果的。它们的尺寸由其内容决定。
*   **常见值**：
    *   `auto`: 默认值。浏览器会根据元素类型和内容自动计算。对于块级元素，`width: auto;` 通常会使其撑满父容器的宽度。
    *   长度单位: `px`, `em`, `rem`, `vw`, `vh` 等。
    *   百分比 (`%`): 相对于其**包含块 (containing block)** 的**宽度**或**高度**。

#### 代码示例

```css
.container {
  width: 80%; /* 占据父元素宽度的80% */
  max-width: 1200px; /* 但最大不超过1200px，这是响应式设计的常用技巧 */
  height: 400px;
}

/* 行内元素设置宽高无效 */
span.my-span {
  width: 200px; /* 无效 */
  height: 50px; /* 无效 */
  background-color: lightblue;
}

/* 必须改变其 display 属性 */
span.my-span-correct {
  display: inline-block; /* 或 block */
  width: 200px; /* 现在有效了 */
  height: 50px; /* 现在有效了 */
  background-color: lightcoral;
}

/* 使用视口单位创建全屏英雄区域 */
.hero-section {
  width: 100vw; /* 视口宽度的100% */
  height: 100vh; /* 视口高度的100% */
}```

#### 常见陷阱和面试点

*   **面试题**: “为什么我给一个 `<span>` 设置了 `width`，它却不生效？”
    *   **回答**: 因为 `<span>` 默认是 `display: inline` 的行内元素。行内元素的宽高是由其内部内容决定的，`width` 和 `height` 属性对其无效。要使其生效，需要将其 `display` 属性改为 `block` 或 `inline-block`。

*   **面试题**: `width: 100%` 和 `width: auto` 有什么区别？
    *   **回答**: 这是一个微妙但体现深度理解的问题。在大多数情况下，块级元素的 `width: auto` 表现得像 `width: 100%`，因为它会填充父元素的整个可用宽度。但关键区别在于 `box-sizing`。如果一个元素 `box-sizing: content-box`，`width: 100%` 再加上 `padding` 就会溢出父容器。而 `width: auto` 会自动减去 `padding` 和 `border` 的空间来适应父容器，不会溢出。在 `border-box` 模型下，二者行为更接近，但 `auto` 仍然是更“自然”的填充行为。

*   **陷阱**: 百分比高度 (`height: 50%`)。要让一个元素的百分比高度生效，其**父元素必须具有明确的高度定义**（不能是 `auto`）。如果父元素 `height` 是 `auto`，那么子元素的百分比高度将被视为 `auto`。

---

### 2. `padding` (内边距)

设置元素内容与边框之间的空间。

#### 详细介绍

*   **作用**: 在元素内部创建空间，把内容“推”离边框。
*   **简写属性**: `padding` 是一个简写属性，可以接受1到4个值，按**顺时针**方向（上、右、下、左）展开。
    *   `padding: 10px;` (四个方向都是 10px)
    *   `padding: 10px 20px;` (上下 10px, 左右 20px)
    *   `padding: 10px 20px 30px;` (上 10px, 左右 20px, 下 30px)
    *   `padding: 10px 20px 30px 40px;` (上 10px, 右 20px, 下 30px, 左 40px)
*   **独立属性**: `padding-top`, `padding-right`, `padding-bottom`, `padding-left`。
*   **背景**: `padding` 区域会显示元素的背景颜色或背景图片。

#### 代码示例

```css
.button {
  display: inline-block;
  padding: 12px 24px; /* 上下12px，左右24px的内边距，让按钮看起来更饱满 */
  background-color: dodgerblue;
  color: white;
  border: none;
}

.card {
  width: 300px;
  padding: 20px;
  background: #fff;
  border: 1px solid #ccc;
  /* 因为是 border-box, 总宽度依然是 300px */
}
```

#### 常见陷阱和面试点

*   **面试题**: “一个元素的 `padding-top` 和 `padding-bottom` 设置为百分比时，是相对于谁计算的？”
    *   **回答**: 这是一个非常经典的“陷阱”题。**垂直方向（`top`, `bottom`）的 `padding` 或 `margin` 的百分比值，是相对于其包含块的宽度 (width) 来计算的，而不是高度 (height)**。
    *   **应用场景**: 这个特性可以用来创建宽高比固定的响应式容器。例如，创建一个完美的正方形：
        ```css
        .square {
          width: 100%;
          height: 0;
          padding-bottom: 100%; /* padding-bottom 等于 width */
          background-color: orange;
        }
        ```

---

### 3. `margin` (外边距)

设置元素边框之外的空间，用于控制元素与其他元素之间的距离。

#### 详细介绍

*   **作用**: 在元素外部创建“不可见”的空间，将元素“推”离其他元素。
*   **简写与独立属性**: 与 `padding` 类似，有 `margin` 简写和 `margin-top`, `margin-right`, `margin-bottom`, `margin-left`。
*   **背景**: `margin` 区域永远是透明的，会显示父元素的背景。
*   **负值**: `margin` 可以接受负值，这会使元素向指定方向移动，甚至与其他元素重叠，常用于一些特殊的布局技巧。

#### 代码示例

```css
.box1 {
  margin-bottom: 20px; /* 在 .box1 下方创建20px的间距 */
}

.box2 { ... }

/* 水平居中块级元素 */
.center-me {
  width: 80%;
  margin: 0 auto; /* 上下0，左右自动。这是定宽块级元素水平居中的经典方法 */
}

/* 使用负margin创建重叠效果 */
.avatar {
  margin-top: -50px; /* 使头像向上移动50px，覆盖到上方的横幅 */
  border: 4px solid white;
}
```

#### 常见陷阱和面试点

*   **面试题**: “什么是外边距折叠 (Margin Collapsing)？在哪些情况下会发生？”
    *   **回答**: 这是关于 `margin` 的**最核心、最高频**的面试题。外边距折叠指的是在**垂直方向**上，两个或多个相邻的块级元素的 `margin` 会合并成一个 `margin`。合并后的 `margin` 高度是所有 `margin` 中的**最大值**。
    *   **发生的三种情况**:
        1.  **相邻的兄弟元素**: 一个元素的 `margin-bottom` 和它下一个兄弟元素的 `margin-top` 会折叠。
            ```html
            <p style="margin-bottom: 20px;">Paragraph 1</p>
            <p style="margin-top: 30px;">Paragraph 2</p>
            <!-- 它们之间的实际间距是 30px, 而不是 20 + 30 = 50px -->
            ```
        2.  **父元素和第一个/最后一个子元素**: 如果父元素没有 `border`、`padding` 或 `overflow` 等属性来“隔开”，父元素的 `margin-top` 会和第一个子元素的 `margin-top` 折叠。`margin-bottom` 同理。
        3.  **空的块级元素**: 如果一个块级元素是空的（没有内容、内边距、边框），它自己的 `margin-top` 和 `margin-bottom` 会折叠。
    *   **如何防止折叠**:
        *   为父元素创建 BFC (Block Formatting Context)，最简单的方法是设置 `overflow: auto` 或 `overflow: hidden`。
        *   为父元素设置 `padding` 或 `border`。
        *   使用 Flexbox 或 Grid 布局，它们的子项不会发生外边距折叠。

*   **面试题**: "如何水平居中一个 `div`？`margin: auto;` 可以吗？"
    *   **回答**: 使用 `margin: 0 auto;` 是最经典的方法，但它有**两个前提条件**：1) 该元素必须是**块级元素**；2) 该元素必须**有明确的宽度**（不能是 `auto`）。`auto` 关键字会告诉浏览器自动计算左右外边距，使其相等，从而达到居中的效果。

---

### 4. `border` (边框)

在 `padding` 和 `margin` 之间绘制元素的边框。

#### 详细介绍

*   **作用**: 为元素添加可见的轮廓。
*   **简写属性**: `border` 是 `border-width`, `border-style`, `border-color` 的简写。
    *   `border: 1px solid #ccc;`
*   **`border-style` 是必需的**: 如果不设置 `border-style` (其默认值为 `none`)，即使设置了宽度和颜色，边框也**不会显示**。
*   **独立属性**: 也可以单独设置每个方向的边框，如 `border-top`, `border-right` 等，它们本身也是简写属性。
    *   `border-top: 2px dotted blue;`

#### 代码示例

```css
/* 一个标准的卡片边框 */
.card {
  border: 1px solid #e1e1e1;
  border-radius: 8px; /* 配合 border-radius 创建圆角 */
}

/* 只有底部边框，常用作分隔线 */
.nav-item {
  padding-bottom: 5px;
  border-bottom: 2px solid transparent; /* 技巧：先用透明边框占位 */
}
.nav-item.active,
.nav-item:hover {
  border-bottom-color: blue; /* 激活/悬停时只改变颜色，避免布局跳动 */
}

/* 使用边框创建三角形（CSS hack） */
.triangle-down {
  width: 0;
  height: 0;
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
  border-top: 15px solid red;
}
```

#### 常见陷阱和面试点

*   **面试题**: “我写了 `border: 2px red;`，为什么边框没有出现？”
    *   **回答**: 因为 `border` 简写属性需要 `border-style`。`border-style` 的默认值是 `none`。必须显式地提供一个样式，如 `solid`, `dotted`, `dashed` 等，边框才会被渲染。正确的写法是 `border: 2px solid red;`。

*   **面试题**: "当用户 `:hover` 一个链接时，我给它加上了 `border`，但发现页面会“抖动一下”，这是为什么？如何解决？"
    *   **回答**: “抖动”或布局位移 (Layout Shift) 是因为在 `hover` 之前元素没有边框，`hover` 时突然增加的 `border-width` 占据了空间，导致元素总尺寸变大，推开了周围的元素。
    *   **解决方案**: 在正常状态下，就为元素设置一个**相同宽度**的**透明边框** (`border: 1px solid transparent;`)。这样边框的空间已经被预留出来了。在 `hover` 时，只需要改变 `border-color`，元素的总尺寸不会发生变化，也就不会有抖动。

| 属性    | 描述                   |
| ------- | ---------------------- |
| width   | 设置元素的宽度         |
| height  | 设置元素的高度         |
| padding | 设置元素的内边距       |
| margin  | 设置元素的外边距       |
| border  | 一次性设置所有边框属性 |

