### 1. `color`

`color` 属性用于设置元素前景（主要是文本）的颜色。

#### 详细介绍

*   **作用**：定义元素内文本的颜色。它同样会影响一些其他前景内容，比如 `border-color` 的默认值 `currentcolor`。
*   **继承性**：是，子元素会默认继承父元素的 `color` 值。

#### 常见值

*   **关键词**：如 `red`, `blue`, `transparent` 等。
*   **十六进制 (HEX)**：`#RRGGBB` 或 `#RGB`（缩写形式）。例如，`#ff0000` 代表红色。
*   **RGB / RGBA**：`rgb(255, 0, 0)` 或 `rgba(255, 0, 0, 0.5)`（最后一个值是 alpha 透明度，范围从 0 到 1）。
*   **HSL / HSLA**：`hsl(0, 100%, 50%)` 或 `hsla(0, 100%, 50%, 0.5)`（色相、饱和度、亮度、透明度）。
*   **`currentcolor`**：一个特殊的关键词，代表元素当前的 `color` 值。它在设置图标颜色或边框颜色时非常有用，可以使其与文本颜色保持一致。

#### 代码示例

```css
/* 使用关键词 */
p.intro {
  color: steelblue;
}

/* 使用十六进制 */
h1.main-title {
  color: #333; /* 深灰色 */
}

/* 使用RGBA实现半透明效果 */
.subtle-text {
  color: rgba(0, 0, 0, 0.6); /* 60% 透明度的黑色 */
}

/* 使用 currentcolor */
.icon-link {
  color: blue;
  border: 2px solid currentcolor; /* 边框颜色将是蓝色 */
}

.icon-link svg {
  fill: currentcolor; /* SVG图标的填充颜色也将是蓝色 */
}
```

#### 常见陷阱和面试点

*   **面试题**：`color` 属性是否只影响文本？
    *   **回答**：主要影响文本，但它也会影响其他一些默认依赖前景色的属性，比如边框颜色 (`border-color`) 和 SVG 图标的填充色 (`fill`)，它们的默认值都是 `currentcolor`。
*   **陷阱 1：可访问性 (Accessibility)**：确保文本颜色和背景颜色之间有足够的对比度。对比度不足会导致视力障碍用户难以阅读。面试官可能会让你评价一段代码的颜色搭配是否合理。
    *   **最佳实践**：使用在线对比度检查工具（如 WebAIM Contrast Checker）来验证你的颜色选择符合 WCAG (Web Content Accessibility Guidelines) AA 级或 AAA 级标准。
*   **陷阱 2：`opacity` vs `rgba`**：面试官可能会问，`opacity: 0.5;` 和 `color: rgba(0, 0, 0, 0.5);` 有什么区别？
    *   **区别**：`opacity` 会影响整个元素（包括背景、边框和所有子元素）的透明度，而 `rgba` 仅影响 `color` 属性本身，不会影响元素的其他部分。

### 2. `font-family`

`font-family` 用于指定一个或多个字体的名称，浏览器会按照列表顺序依次尝试使用。

#### 详细介绍

*   **作用**：设置元素的字体。可以提供一个字体族列表，浏览器会选择列表中第一个在用户计算机上可用的字体。
*   **继承性**：是。

#### 常见值

*   **特定字体名称**：如 `"Helvetica"`, `"Arial"`, `"Times New Roman"`。如果字体名称包含空格，必须用引号包裹。
*   **通用字体族 (Generic Family)**：这是字体列表的**必备备选项**。包括：
    *   `serif`: 带衬线的字体 (e.g., Times New Roman)
    *   `sans-serif`: 无衬线的字体 (e.g., Arial, Helvetica)
    *   `monospace`: 等宽字体 (e.g., Courier New)
    *   `cursive`: 草书或手写体
    *   `fantasy`: 装饰性字体

#### 代码示例

```css
/* 最佳实践：从最想要的字体到最通用的字体 */
body {
  font-family: "Helvetica Neue", Arial, "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
}

/* 引用代码块使用等宽字体 */
code, pre {
  font-family: "SF Mono", "Consolas", "Liberation Mono", Menlo, Courier, monospace;
}

/* 使用 @font-face 引入自定义字体 */
@font-face {
  font-family: 'MyCustomFont';
  src: url('mycustomfont.woff2') format('woff2');
}

h1 {
  font-family: 'MyCustomFont', fantasy;
}
```

#### 常见陷阱和面试点

*   **面试题**：为什么 `font-family` 列表的最后总要有一个通用字体族？
    *   **回答**：这是一个**防御性编程**的体现。它保证了即使用户的系统中没有任何你指定的特定字体，浏览器也能选择一个同类型的、可用的默认字体来渲染文本，从而避免了浏览器使用完全不符合设计预期的默认字体，保证了内容的可读性和基本样式。
*   **陷阱 1：字体名称中的空格**：忘记给包含空格的字体名称加引号，例如 `font-family: Times New Roman;` 是不规范的，虽然某些浏览器容错性强，但正确写法是 `font-family: "Times New Roman";`。
*   **陷阱 2：中文字体问题**：中文字体文件通常很大。面试时可能会问如何优化网页字体加载。
    *   **最佳实践**：
        1.  **字体栈策略**：优先使用用户系统内置的中文字体，如 `Hiragino Sans GB` (macOS), `Microsoft YaHei` (Windows)。
        2.  **字体裁剪/子集化**：如果必须使用自定义中文字体，可以使用工具（如 `font-spider`）仅打包网页中用到的字符，大大减小字体文件体积。
        3.  **使用 `font-display: swap;`**：在 `@font-face` 中设置，可以让文本先用备用字体渲染，等自定义字体加载完毕后再切换，避免长时间的白屏。

### 3. `font-size`

`font-size` 属性用于设置字体的大小。

#### 详细介绍

*   **作用**：控制文本的尺寸。
*   **继承性**：是，但子元素继承的是**计算后**的值，而不是相对单位本身。

#### 常见值

*   **绝对单位**：`px` (像素), `pt` (点)。`px` 是最常用的，因为它提供了精确的控制。
*   **相对单位**：
    *   `em`: 相对于**父元素**的 `font-size`。
    *   `rem` (root em): 相对于**根元素 (`<html>`)** 的 `font-size`。这是现代响应式设计中的首选。
    *   `%`: 与 `em` 类似，相对于父元素的 `font-size`。
    *   `vw`, `vh`: 相对于视口宽度 (viewport width) 或高度 (viewport height) 的 1%。

#### 代码示例

```css
/* 根元素设置基准字体大小，便于rem单位计算 */
html {
  font-size: 16px;
}

body {
  font-size: 1rem; /* 等于 16px */
}

h1 {
  font-size: 2rem; /* 等于 32px */
}

.parent {
  font-size: 20px;
}

.child {
  font-size: 1.2em; /* 1.2 * 20px = 24px */
}

/* 响应式标题，大小随屏幕宽度变化 */
.responsive-title {
  font-size: 5vw;
}
```

#### 常见陷阱和面试点

*   **面试题**：请解释 `em` 和 `rem` 的区别以及各自的应用场景。
    *   **回答**：
        *   **`em`** 相对于其父元素的字体大小。如果多层嵌套都使用 `em`，可能会导致复杂的计算（`1.2em` 的子元素的 `1.2em` 最终是 `1.44em`），难以维护。它适用于那些希望大小与直接父元素关联的组件，比如一个按钮内的图标大小可以设置为 `0.8em`，这样按钮字体变大时，图标也随之变大。
        *   **`rem`** 相对于根元素 (`<html>`) 的字体大小。这使得所有使用 `rem` 的元素的尺寸都有一个统一的参照基准。它非常适合构建响应式布局，只需在不同的媒体查询断点中修改根元素的 `font-size`，整个页面的元素就能按比例缩放，易于维护。
*   **陷阱 1：`rem` 与无障碍**：为了尊重用户在浏览器中设置的默认字体大小，最佳实践是在 `html` 元素上使用百分比设置 `font-size`。
    *   **最佳实践**：`html { font-size: 62.5%; }` 这样，默认的 `16px` 就变成了 `10px` (`16 * 0.625`)。之后就可以方便地使用 `rem` 了，比如 `1.6rem` 就等于 `16px`，计算非常直观。这种做法既方便了开发者，也尊重了用户的偏好设置。

### 4. `font-weight`

`font-weight` 属性用于设置字体的粗细程度。

#### 详细介绍

*   **作用**：控制文本的“重量”或“加粗”程度。
*   **继承性**：是。

#### 常见值

*   **关键词**：
    *   `normal`: 默认值，等同于 `400`。
    *   `bold`: 加粗，等同于 `700`。
    *   `lighter`: 比父元素更细一级。
    *   `bolder`: 比父元素更粗一级。
*   **数字值**：`100` 到 `900` 之间的整百数。
    *   `100`: Thin
    *   `300`: Light
    *   `400`: Normal / Regular
    *   `500`: Medium
    *   `700`: Bold
    *   `900`: Black / Heavy

#### 代码示例

```css
p {
  font-weight: normal; /* หรือ 400 */
}

strong, b {
  font-weight: bold; /* หรือ 700 */
}

h1 {
  font-weight: 900;
}

.light-text {
  font-weight: 300;
}
```

#### 常见陷阱和面试点

*   **面试题**：我设置了 `font-weight: 100;`，但为什么文本看起来和 `font-weight: 400;` 一样粗？
    *   **回答**：这是因为 `font-weight` 的显示效果**依赖于所使用的字体文件本身是否提供了对应字重的字形**。如果当前字体（比如 Arial）只提供了 "Regular" 和 "Bold" 两种字重，那么无论你设置为 `100`, `200`, `300`, `400` 还是 `500`，浏览器都会渲染成 "Regular" (400) 的样式。同理，`600` 到 `900` 都会被渲染成 "Bold" (700)。要实现多种字重，你需要引入支持可变字重（Variable Fonts）或提供了多个字重文件的字体，如 Google Fonts 上的许多字体。
*   **陷阱 1：`lighter` 和 `bolder` 的相对性**：这两个值是相对于父元素的 `font-weight` 计算的。例如，如果父元素是 `400`，子元素设置 `bolder` 可能会变成 `700`。如果父元素已经是 `700`，子元素再设置 `bolder` 可能会变成 `900`。它的具体表现也取决于字体本身的支持情况。

### 5. `text-align`

`text-align` 属性规定了块级元素或表格单元格内部的**内联内容**（如文本）的水平对齐方式。

#### 详细介绍

*   **作用**：设置文本和其他内联内容的水平对齐。
*   **继承性**：是。

#### 常见值

*   `left`: 左对齐（默认值）。
*   `right`: 右对齐。
*   `center`: 居中对齐。
*   `justify`: 两端对齐。浏览器会调整单词和字符间的间距，使得除最后一行外的每一行都填满整个宽度。
*   `start` / `end`: 根据书写模式（如从左到右或从右到左）决定是左对齐还是右对齐。在多语言网站中是更推荐的选择。

#### 代码示例

```css
p.left {
  text-align: left;
}

p.center {
  text-align: center;
}

blockquote {
  text-align: justify;
}
```

#### 常见陷阱和面试点

*   **面试题**：如何水平居中一个块级元素（比如 `div`）？`text-align: center;` 可以吗？
    *   **回答**：不可以。`text-align` **只作用于元素内部的内联内容**，它不能用来居中块级元素本身。要水平居中一个**定宽**的块级元素，最经典的方法是设置 `margin: 0 auto;`。如果是不定宽的元素，可以使用 Flexbox 布局 (`display: flex; justify-content: center;`)。
*   **陷阱 1：`justify` 的问题**：两端对齐（`justify`）在处理某些文本时，可能会在单词之间产生非常大的、不美观的间隙，特别是在窄列布局中。因此需要谨慎使用。
*   **陷阱 2：对图片等替换元素的作用**：虽然图片是内联元素，但 `text-align: center;` 作用于其父块级容器时，确实可以使图片水平居中。这是因为它影响的是行框（line box）内的内容对齐。

### 6. `text-decoration`

`text-decoration` 是一个简写属性，用于设置文本的装饰线。

#### 详细介绍

*   **作用**：为文本添加或移除下划线、上划线、删除线等。
*   **继承性**：否，但装饰线会“穿过”子元素。

#### 简写属性包括

*   `text-decoration-line`: 线的类型（`underline`, `overline`, `line-through`, `none`）。
*   `text-decoration-color`: 线的颜色。
*   `text-decoration-style`: 线的样式（`solid`, `wavy`, `dotted`, `dashed`, `double`）。
*   `text-decoration-thickness`: 线的粗细。

#### 代码示例

```css
/* 移除链接的默认下划线 */
a {
  text-decoration: none;
}

/* 鼠标悬停时添加下划线 */
a:hover {
  text-decoration: underline;
}

/* 设置删除线 */
.deleted-price {
  text-decoration: line-through;
}

/* 使用详细属性自定义波浪形下划线 */
.special-text {
  text-decoration-line: underline;
  text-decoration-color: red;
  text-decoration-style: wavy;
  text-decoration-thickness: 2px;
}

/* 简写形式 */
.special-text-shorthand {
  text-decoration: underline wavy red 2px;
}
```

#### 常见陷阱和面试点

*   **面试题**：如何只修改下划线的颜色而不影响文本颜色？
    *   **回答**：使用 `text-decoration-color` 属性。在以前，这很难做到，通常需要用 `border-bottom` 来模拟下划线，但现在 CSS 已经原生支持了。
*   **陷阱 1：继承的误解**：`text-decoration` 不被子元素继承。但如果父元素有下划线，这个下划线会延伸到子元素的下方。如果你想让子元素（比如一个行内标签）没有下划线，即使父元素有，你也无法通过 `text-decoration: none;` 来取消父元素的线，因为线是属于父元素的。
    *   **示例**：`p { text-decoration: underline; } span { text-decoration: none; }` -> `<span>` 文本下方的线依然存在。
    *   **解决方案**：如果需要这种效果，可以考虑将父元素的装饰去掉，然后只给需要的子节点单独添加装饰。

### 7. `line-height`

`line-height` 属性用于设置行间的距离（行高）。

#### 详细介绍

*   **作用**：控制文本行在垂直方向上的间距。它定义了行框（line box）的最小高度。
*   **继承性**：是。

#### 常见值

*   `normal`: 默认值，通常是字体大小的 1.2 倍左右，具体由浏览器决定。
*   **无单位的数字**：例如 `line-height: 1.5;`。这是**强烈推荐**的最佳实践。它表示行高是当前元素 `font-size` 的 1.5 倍。
*   **带单位的值**：`px`, `em`, `rem`。例如 `line-height: 24px;` 或 `line-height: 1.5em;`。
*   **百分比**：`line-height: 150%;`，相对于元素自身的 `font-size`。

#### 代码示例

```css
/* 最佳实践：使用无单位的数字 */
p {
  font-size: 16px;
  line-height: 1.6; /* 计算后的行高是 16 * 1.6 = 25.6px */
}

h1 {
  font-size: 32px;
  line-height: 1.2;
}

/* 不推荐的做法 */
.bad-example {
  font-size: 16px;
  line-height: 1.6em; /* 或 160% */
}
```

#### 常见陷阱和面试点

*   **面试题**：`line-height: 1.5;` 和 `line-height: 1.5em;` 有什么本质区别？为什么推荐使用无单位的数值？
    *   **回答**：这是一个非常经典的面试题。
        *   **`line-height: 1.5em;` (或 `150%`)**：子元素继承的是**父元素计算后**的 `line-height` 值。例如，父元素 `font-size: 20px; line-height: 1.5em;`，其计算后的行高是 `30px`。如果一个子元素的 `font-size` 是 `10px`，它会继承 `30px` 这个固定的行高值，这对于小字体来说太大了，会导致行距看起来非常不协调。
        *   **`line-height: 1.5;` (无单位)**：子元素继承的是 `1.5` 这个**比例因子**本身。然后，子元素会用自己的 `font-size` 去乘以这个因子来计算自己的行高。在上面的例子中，子元素的行高会是 `10px * 1.5 = 15px`。这样就保证了无论字体大小如何变化，行高总能保持一个和谐的、成比例的间距。因此，无单位的 `line-height` 提供了更好的可预测性和灵活性，是最佳实践。
*   **面试题**：如何使用 `line-height` 来垂直居中单行文本？
    *   **回答**：将容器的 `height` 和 `line-height` 设置为相同的值。这个技巧的原理是，行高产生的上下“行间距”是均等分布在文本上下的，当行高恰好等于容器高度时，文本在视觉上就垂直居中了。但这**只适用于单行文本**。

### 8. & 9. `letter-spacing` 和 `word-spacing`

这两个属性分别用于调整字符间和单词间的距离。

#### 详细介绍

*   **`letter-spacing`**: 调整**字符**之间的间距（字间距）。
*   **`word-spacing`**: 调整**单词**之间的间距（词间距）。浏览器通过空格来识别单词。
*   **继承性**：都是。

#### 常见值

*   `normal`: 默认间距。
*   长度值：`px`, `em`, `rem` 等。可以是正值（增加间距）或负值（减小间距）。

#### 代码示例

```css
/* 增加大写标题的字间距，提升设计感和可读性 */
h1.main-title {
  text-transform: uppercase;
  letter-spacing: 2px;
}

/* 减小字间距，让文本更紧凑 */
.compact-text {
  letter-spacing: -0.5px;
}

/* 增加单词间的距离 */
.spaced-out-words {
  word-spacing: 0.5em;
}
```

#### 常见陷阱和面试点

*   **面试题**：如何实现文本两端对齐？
    *   **回答**：首先想到的应该是 `text-align: justify;`。但如果面试官追问，除了 `justify` 还有没有其他方式，或者 `justify` 效果不理想怎么办？你可以提到 `letter-spacing` 和 `word-spacing` 可以作为微调手段，但手动调整来实现两端对齐非常繁琐且不实用。`justify` 的原理就是自动调整 `word-spacing`，有时也会调整 `letter-spacing`。
*   **注意事项**：
    *   **可读性**：过度使用负的 `letter-spacing` 会让字符重叠，难以阅读。过大的正值则会使文本显得松散，割裂阅读流。通常只用于标题或特殊设计的短语上。
    *   **`word-spacing` 的基准**：`word-spacing` 是在默认的单词间距之上**额外增加**的间距。例如，`word-spacing: 10px;` 意味着在原有的一个空格宽度基础上再增加 10px。
    *   **中英文差异**：`letter-spacing` 对中英文都有效。而 `word-spacing` 主要影响的是以空格分隔的语言（如英语），对中文这种字符之间没有空格的语言，效果不明显。



---



| 属性            | 描述                               |
| --------------- | ---------------------------------- |
| color           | 设置文本颜色                       |
| font-family     | 设置字体                           |
| font-size       | 设置字体大小                       |
| font-weight     | 设置字体粗细                       |
| text-align      | 设置文本的水平对齐方式             |
| text-decoration | 设置文本的装饰，如下划线、删除线等 |
| line-height     | 设置行高                           |
| letter-spacing  | 设置字符间距                       |
| word-spacing    | 设置单词间距                       |

