### **第 6 课：Positioning（定位）**

Positioning (定位) 就是 CSS 赋予你的“超能力”。它允许你将一个元素从它原本所在的位置“拎起来”，然后精确地放置在你想要的任何地方——无论是相对于它原来的位置进行微调，还是相对于整个浏览器窗口创建一个固定的导航栏。

#### **核心思想：脱离文档流的艺术**

“文档流”就是我们之前学的，元素自上而下、自左而右排列的默认行为。Positioning 的核心就是**让元素脱离（或部分脱离）这个文档流**。

*   **微操**：`position: relative`，不脱离文档流，进行位置微调。
*   **大招**：`position: absolute` / `fixed`，完全脱离文档流，进行大幅度、精确的位置控制。
*   **智能大招**：`position: sticky`，在普通和固定之间智能切换。

一旦一个元素被设置了 `relative`, `absolute`, `fixed`, 或 `sticky`，你就可以使用 `top`, `right`, `bottom`, `left` 这四个属性来控制它的位置。

---

### **深度剖析：五种定位模式**

#### **1. `position: static;` (静态定位)**
*   **含义**：这是每个元素的**默认值**。
*   **行为**：元素老老实实地待在普通文档流里。`top`, `right`, `bottom`, `left` 和 `z-index` 属性对它**完全无效**。
*   **一句话总结**：一个普通的、遵守规则的元素。

#### **2. `position: relative;` (相对定位)**
*   **含义**：相对于**元素自己原来的位置**进行定位。
*   **行为**：
    1.  元素**不脱离文档流**。它在文档流中占据的空间会被**保留**，就像一个“占位符”一样。
    2.  你可以使用 `top`, `left` 等属性，让它在视觉上发生偏移。例如 `top: 20px;` 会让它从原来的位置向下移动 20px。
    3.  **最重要的作用**：它会为其后代中的绝对定位元素（`position: absolute`）创建一个**定位上下文**。
*   **一句话总结**：一个“灵魂出窍”的元素，身体还在原地占着位置，但灵魂（视觉表现）可以四处飘移。

#### **3. `position: absolute;` (绝对定位)**
*   **含义**：相对于其**最近的、已定位的祖先元素**进行定位。
*   **行为**：
    1.  元素**完全脱离文档流**。它在文档流中不再占据任何空间，下面的元素会“顶上来”占据它原来的位置。
    2.  它会向上寻找祖先元素，直到找到第一个设置了 `position` 属性值**不为 `static`** 的祖先（比如 `relative`, `absolute`, `fixed`），然后以这个祖先的内边距（padding）边缘为基准进行定位。
    3.  如果找不到这样的祖先，它最终会相对于初始包含块（通常是 `<html>` 元素）进行定位。
*   **一句话总结**：一个“六亲不认”的元素，它会脱离队伍，去寻找离它最近的那个姓“位”（`position`）的祖先，然后把自己“贴”在那个祖先身上。

#### **4. `position: fixed;` (固定定位)**
*   **含义**：相对于**浏览器视口（Viewport）**进行定位。
*   **行为**：
    1.  元素**完全脱离文档流**。
    2.  无论页面如何滚动，它都会固定在屏幕的同一个位置。
*   **一句话总结**：一个“钉在屏幕上”的元素，常用于创建模态框、固定的顶部导航栏或“回到顶部”按钮。

#### **5. `position: sticky;` (粘性定位)**
*   **含义**：`relative` 和 `fixed` 的混合体。
*   **行为**：
    1.  在默认情况下，它的行为像 `position: relative`。
    2.  当页面滚动，使得该元素即将要移出视口时，它会“粘”在指定的位置（由 `top`, `left` 等定义），行为变得像 `position: fixed`。
*   **一句话总结**：一个“智能膏药”，平时待在原地，滚动到它时就粘在屏幕边缘，常用于实现表格的粘性表头或文章侧边栏。

---

### **关键概念**

#### **定位上下文 (Positioning Context)**
这是 `absolute` 定位的基础。一个元素要想成为其后代的“定位参考物”，它自身的 `position` 属性必须是 `relative`, `absolute`, `fixed` 或 `sticky` 之一。最常用的组合是“父相子绝”：父元素设置 `position: relative;`（不脱离文档流，只为创建上下文），子元素设置 `position: absolute;`。

#### **`z-index` 与 堆叠上下文 (Stacking Context)**
*   `z-index` 决定了已定位元素在 Z 轴（垂直于屏幕）上的堆叠顺序。**数值越大，越靠上**。
*   **注意**：`z-index` **只对 `position` 属性值不为 `static` 的元素生效**。
*   **堆叠上下文**是理解 `z-index` 为何失效的关键。当一个元素满足某些条件时（最常见的是 `position` 不为 `static` 且 `z-index` 不为 `auto`），它会创建一个**新的堆叠上下文**。
*   **核心规则**：在同一个堆叠上下文中，`z-index` 才能互相比较。不同堆叠上下文中的元素，它们的堆叠顺序由**父级的堆叠上下文**来决定。
*   **比喻**：把堆叠上下文想象成一个个独立的“扑克牌堆”。你可以随意调整一个牌堆内部牌的顺序（子元素的 `z-index`），但你无法把 A 牌堆里的一张牌，插到 B 牌堆两张牌的中间。A 牌堆整体，要么在 B 牌堆之上，要么在 B 牌堆之下。

---

### **面试焦点**

**面试官问：“`position: absolute` 是相对于谁定位的？”**

> **你的回答**：“`position: absolute` 的元素会相对于其**最近的、`position` 值不为 `static` 的祖先元素**进行定位。这个祖先元素就是它的‘定位上下文’。如果在它的所有祖先中都找不到这样一个元素，那么它最终会相对于初始包含块，也就是 `<html>` 元素进行定位。”

**面试官问：“`z-index` 为什么有时候会失效？请解释一下堆叠上下文。”**

> **你的回答**：“`z-index` 失效的根本原因通常是**元素处在了不同的堆叠上下文中**。
>
> 堆叠上下文是一个独立的层级空间。当一个元素（比如设置了 `position: relative` 和 `z-index: 1`）创建了一个新的堆叠上下文后，它的所有子元素的 `z-index` 值都只在这个内部上下文中进行比较。
>
> 即使一个子元素的 `z-index` 设置得非常大（比如 `9999`），它在视觉上也永远不可能覆盖到另一个堆叠上下文中的元素之上，如果那个堆叠上下文的层级更高的话。
>
> 所以，解决 `z-index` 问题时，不能只看元素本身的 `z-index`，而是要向上检查它的父级、祖先级元素是否创建了新的堆叠上下文，并调整这些父级上下文的 `z-index`。”

**面试官问：“`fixed` 和 `sticky` 的区别是什么？”**

> **你的回答**：“它们的主要区别在于定位的参考物和行为模式：
>
> *   **参考物不同**：`fixed` 始终相对于**浏览器视口**定位。而 `sticky` 在滚动到阈值前是相对于其在**文档流中的位置**，滚动到阈值后则像 `fixed` 一样相对于视口。
> *   **行为不同**：`fixed` 元素会立即脱离文档流，始终固定在屏幕的某个位置。而 `sticky` 元素在未触发粘性定位时，会**保留其在文档流中的位置和空间**，只有在滚动越过由 `top`, `bottom` 等属性定义的阈值时，才会表现出固定的行为。
>
> 简单来说，`fixed` 是永久固定的，而 `sticky` 是一个在 `static/relative` 和 `fixed` 之间切换的‘智能’定位。”

---

### **实战任务**

我们来做一个非常常见的 UI 组件：一个带**通知角标**的链接。

**HTML 结构:**
```html
<a href="#" class="notification-link">
  Inbox
  <span class="badge">3</span>
</a>
```

**你的任务：**
1.  给 `<a>` 标签一些基本样式（比如 `padding`, `background-color`, `border-radius`）。
2.  **创建定位上下文**: 为了让角标 `<span>` 能相对于 `<a>` 定位，你需要给 `<a>` 标签设置 `position: relative;`。
3.  **定位角标**:
    *   将 `<span>` 标签设置为 `position: absolute;`，让它脱离文档流。
    *   使用 `top` 和 `right` 属性，将它精确地定位到 `<a>` 标签的**右上角**。（提示：你可能需要使用负值来让它稍微向外偏移一点，效果更好）。
4.  给角标 `<span>` 添加样式（比如背景色、文字颜色、圆角等），让它看起来像一个真正的通知角标。

这个小练习将让你完美地掌握“父相子绝”这一最核心、最常用的定位技巧。动手试试吧！
