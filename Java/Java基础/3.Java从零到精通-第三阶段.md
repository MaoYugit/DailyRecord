## **第三阶段：Java进阶与常用API (Becoming Proficient)**



<div style="display: flex; justify-content: space-around;">
  <span>
    <a href="./2.Java从零到精通-第二阶段.md">
      ← 上一篇：第二阶段
    </a>
  </span>
  <span>
    <a href="./4.Java从零到精通-第四阶段.md">
      下一篇：第四阶段 →
    </a>
  </span>
</div>
### **第9章：常用API（字符串、日期、数学等）**

在这一章，我们将学习Java标准库中那些几乎每个程序都会用到的核心API。

#### **9.1 字符串处理：`String`，`StringBuilder` 和 `StringBuffer`**

字符串是我们打交道最多的数据类型之一。

**A. `String` 类 - 不可变的字符串**

* **核心特性：不可变性 (Immutability)**
  这是`String`类最重要的特性！一个`String`对象一旦被创建，它的内容就**永远不能被改变**。任何对字符串的修改（如拼接、替换）都会**创建一个新的`String`对象**，而原对象保持不变。

  *   **优点：** 线程安全，易于缓存。
  *   **缺点：** 当频繁进行字符串拼接时，会产生大量临时的、无用的对象，效率低下。

* **【常用方法实践】**
  创建一个`StringApiPractice.java`类来练习。

  ```java
  public class StringApiPractice {
      public static void main(String[] args) {
          String text = "  Hello, Java World!  ";
          String anotherText = "hello, java world!";
  
          // 1. 获取长度
          System.out.println("长度: " + text.length()); // 22 (包括空格)
  
          // 2. 获取指定索引的字符
          System.out.println("第4个字符: " + text.charAt(3)); // 'l' (索引从0开始)
  
          // 3. 查找子串的索引
          System.out.println("Java首次出现的位置: " + text.indexOf("Java")); // 9
          System.out.println("最后一个'o'的位置: " + text.lastIndexOf('o')); // 16
  
          // 4. 比较字符串
          System.out.println("内容是否相等 (区分大小写): " + text.trim().equals(anotherText)); // false
          System.out.println("内容是否相等 (忽略大小写): " + text.trim().equalsIgnoreCase(anotherText)); // true
  
          // 5. 截取子串
          // 从索引9开始，一直到字符串末尾
          String sub1 = text.substring(9); 
          System.out.println("截取'Java World!  ': " + sub1);
          // 从索引9开始，到索引13结束 (不包括13)
          String sub2 = text.substring(9, 13); 
          System.out.println("只截取'Java': " + sub2);
          
          // 6. 转换大小写
          System.out.println("转为大写: " + text.toUpperCase());
          System.out.println("转为小写: " + text.toLowerCase());
  
          // 7. 去除首尾空格
          System.out.println("去除首尾空格: '" + text.trim() + "'");
  
          // 8. 分割字符串
          String data = "张三,25,男";
          String[] parts = data.split(",");
          System.out.println("分割后的姓名: " + parts[0]); // 张三
      }
  }
  ```

**B. `StringBuilder` 和 `StringBuffer` - 可变的字符串**

* 当需要**频繁地、大量地修改字符串内容**（尤其是在循环中拼接字符串）时，为了避免`String`的低效率，我们应该使用`StringBuilder`。

* **`StringBuilder`：** 可变长，线程不安全，但效率高。**单线程环境下首选**。

* **`StringBuffer`：** 可变长，线程安全，但效率较低。多线程环境下使用。

* **【`StringBuilder`实践】**

  ```java
  // 在 StringApiPractice.java 的 main 方法里继续写
  
  // 目标：高效地拼接一个SQL查询语句
  StringBuilder sqlBuilder = new StringBuilder();
  sqlBuilder.append("SELECT * FROM users ");
  sqlBuilder.append("WHERE name = '张三' ");
  sqlBuilder.append("AND age > 18 ");
  sqlBuilder.append("ORDER BY id DESC;");
  
  // 最后，当所有拼接完成后，再把它变回一个String对象
  String finalSql = sqlBuilder.toString();
  System.out.println("\n最终拼接的SQL: " + finalSql);
  
  // 其他常用方法
  sqlBuilder.insert(0, "/* 用户查询 */ "); // 在开头插入
  sqlBuilder.delete(sqlBuilder.length() - 1, sqlBuilder.length()); // 删除末尾的分号
  System.out.println("修改后的SQL: " + sqlBuilder.toString());
  ```

  **法则：** 在循环外或单次操作用`String`，在循环内或多次拼接用`StringBuilder`。

#### **9.2 数学工具：`Math` 类**

`Math`类提供了大量用于数学运算的静态方法，无需创建对象，直接用`Math.方法名()`调用。

* **【常用方法实践】**

  ```java
  // MathPractice.java
  public class MathPractice {
      public static void main(String[] args) {
          System.out.println("绝对值: " + Math.abs(-10));         // 10
          System.out.println("向上取整: " + Math.ceil(3.14));     // 4.0
          System.out.println("向下取整: " + Math.floor(3.14));    // 3.0
          System.out.println("四舍五入: " + Math.round(3.5));     // 4
          System.out.println("两者中的较大值: " + Math.max(10, 20)); // 20
          System.out.println("2的3次方: " + Math.pow(2, 3));      // 8.0
          System.out.println("平方根: " + Math.sqrt(16));         // 4.0
          System.out.println("生成0.0到1.0之间的随机数: " + Math.random());
          
          // 生成1到100之间的随机整数
          int randomNumber = (int) (Math.random() * 100) + 1;
          System.out.println("1-100的随机整数: " + randomNumber);
      }
  }
  ```

#### **9.3 日期时间处理 (Java 8+ 全新API)**

**忘记旧的`Date`和`Calendar`吧！** Java 8 引入了全新的、设计极佳的`java.time`包，它是不可变的、线程安全的。

* **核心类：**

  *   `LocalDate`: 只表示日期 (年-月-日)，如 `2023-10-27`。
  *   `LocalTime`: 只表示时间 (时-分-秒)，如 `15:30:00`。
  *   `LocalDateTime`: 日期和时间，如 `2023-10-27T15:30:00`。**最常用**。
  *   `DateTimeFormatter`: 用于格式化和解析日期时间字符串。
  *   `Period`: 计算两个`LocalDate`之间的日期间隔（年、月、日）。
  *   `Duration`: 计算两个`LocalTime`/`LocalDateTime`之间的时间间隔（时、分、秒）。

* **【手把手教学】**
  创建一个`DateTimePractice.java`类。

  ```java
  import java.time.LocalDate;
  import java.time.LocalDateTime;
  import java.time.LocalTime;
  import java.time.format.DateTimeFormatter;
  import java.time.temporal.ChronoUnit;
  
  public class DateTimePractice {
      public static void main(String[] args) {
          // 1. 获取当前日期和时间
          LocalDateTime now = LocalDateTime.now();
          System.out.println("当前完整时间: " + now);
          System.out.println("当前日期: " + now.toLocalDate());
          System.out.println("当前时间: " + now.toLocalTime());
  
          // 2. 创建指定的日期和时间
          LocalDateTime specificDateTime = LocalDateTime.of(2024, 10, 1, 8, 0, 0);
          System.out.println("国庆节早上8点: " + specificDateTime);
          
          // 3. 格式化：将日期时间对象转为漂亮的字符串
          DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy年MM月dd日 HH:mm:ss");
          String formattedNow = now.format(formatter);
          System.out.println("格式化后的当前时间: " + formattedNow);
  
          // 4. 解析：将字符串转为日期时间对象
          String timeStr = "2025-01-01 00:00:00";
          DateTimeFormatter parser = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
          LocalDateTime newYear = LocalDateTime.parse(timeStr, parser);
          System.out.println("解析出的新年时间: " + newYear);
          
          // 5. 获取日期时间的各个部分
          System.out.println("今年是: " + now.getYear() + "年");
          System.out.println("今天是今年的第 " + now.getDayOfYear() + " 天");
  
          // 6. 日期时间的计算
          LocalDateTime tomorrow = now.plusDays(1);
          System.out.println("明天这个时间: " + tomorrow);
          LocalDateTime lastMonth = now.minusMonths(1);
          System.out.println("上个月这个时间: " + lastMonth);
  
          // 7. 计算两个日期之间的间隔
          LocalDate today = LocalDate.now();
          LocalDate myBirthday = LocalDate.of(2024, 12, 25);
          long daysUntilBirthday = ChronoUnit.DAYS.between(today, myBirthday);
          System.out.println("距离我的生日还有: " + daysUntilBirthday + " 天");
      }
  }
  ```

#### **9.4 本章小结与作业**

*   **小结：** 我们学会了使用`String`的各种方法来处理文本，并掌握了在频繁修改时使用`StringBuilder`的原则。我们利用`Math`类进行了数学计算。最重要的是，我们学会了使用Java 8强大的`java.time`API来优雅地处理日期和时间。你现在已经能编写出功能更丰富、更实用的程序了！

*   **作业（实用工具开发！）：**

    1.  **用户名生成器：**
        *   创建一个`UsernameGenerator`类。
        *   写一个方法`public static String generate(String email)`。
        *   该方法接收一个Email地址（例如 `"zhangsan_123@example.com"`）。
        *   生成规则是：取`@`符号前的部分，全部转为小写，然后拼接上一个100到999之间的随机数。
        *   例如，输入`"zhangsan_123@example.com"`，可能输出`zhangsan_123582`。
        *   在`main`方法中测试你的生成器。
        *   **提示：** 你需要用到`indexOf()`, `substring()`, `toLowerCase()`, `Math.random()` 和字符串拼接。

    2.  **安全手机号显示：**
        *   创建一个`PhoneMasker`类。
        *   写一个方法`public static String mask(String phoneNumber)`。
        *   这个方法接收一个11位的手机号码字符串。
        *   返回一个“脱敏”后的手机号，规则是保留前3位和后4位，中间4位用 `****` 代替。
        *   例如，输入`"13812345678"`，返回`"138****5678"`。
        *   在`main`方法中测试。
        *   **提示：** 思考如何用`substring()`和`StringBuilder`来高效完成。

    3.  **纪念日计算器：**
        *   创建一个`AnniversaryCalculator`类。
        *   写一个方法，接收一个字符串格式的日期（例如 `"1999-08-15"`），代表一个纪念日。
        *   该方法需要计算并打印出：
            *   这个纪念日是星期几。
            *   到今天为止，总共过去了多少天。
            *   今年的这个纪念日是星期几。
        *   在`main`方法中传入你的生日或者其他有意义的日子来测试。
        *   **提示：** 你需要`LocalDate.parse()`, `ChronoUnit.DAYS.between()`, `getDayOfWeek()`, `withYear()`等方法。

完成这些练习，你对Java常用API的掌握将非常牢固。下一步，我们将学习一个无比重要的数据结构——**集合框架**，它将彻底解放你对数组的束缚，让你能更灵活地管理成组的数据。

好的，我们继续前进！

你已经学会了使用数组来存储一组数据，但你肯定也发现了它的局限性：

*   **长度固定：** 数组一旦创建，大小就不能改变。想加个新元素？很麻烦。
*   **功能有限：** 数组本身没有提供方便的添加、删除、查找等方法，我们得自己写循环来实现。

为了解决这些痛点，Java提供了一套功能极其强大、使用极其灵活的数据结构——**Java集合框架 (Java Collections Framework)**。这是Java程序员日常开发中使用最频繁的工具，没有之一。掌握它，你的数据处理能力将提升一个数量级。

---

### 

### **第10章：集合框架 (更高级的数据容器)**

*   **核心思想：** 集合框架提供了一系列“动态的”、“高级的”容器，用于存储和操作对象。它们可以自动扩容，并内置了丰富的增、删、改、查等操作方法。

#### **10.1 集合框架的“三巨头”**

整个集合框架主要围绕三个核心接口展开：`List`, `Set`, 和 `Map`。你可以把它们想象成三种不同类型的“储物柜”。

*   **`List` (列表):** 像一个**书架**。
    *   **特点：** 有序（元素存入和取出的顺序一致），有索引（可以通过编号访问），**允许**元素重复。
    *   **典型实现类：** `ArrayList`, `LinkedList`

*   **`Set` (集):** 像一个**装满不重复弹珠的袋子**。
    *   **特点：** 无序（通常不保证存取顺序），无索引，**不允许**元素重复。
    *   **典型实现类：** `HashSet`, `TreeSet`

*   **`Map` (映射/字典):** 像一本**字典或电话簿**。
    *   **特点：** 存储的是 **键值对 (Key-Value Pair)**。Key是唯一的（不允许重复），通过Key可以快速找到对应的Value。
    *   **典型实现类：** `HashMap`, `TreeMap`



#### **10.2 `List`接口 和 `ArrayList`**

`List`是我们最常用的集合，它的行为和数组最像，但它是动态的。`ArrayList`是`List`最常见的实现，它的底层就是一个可以自动扩容的数组。

* **【手把手教学】使用 `ArrayList`**

  1.  创建一个新类 `CollectionPractice.java`。
  2.  在`main`方法中编写以下代码：

  ```java
  import java.util.ArrayList;
  import java.util.List; // 引入 List 和 ArrayList
  
  public class CollectionPractice {
      public static void main(String[] args) {
          // --- List 的使用 ---
          // 创建一个只能存放 String 类型元素的 ArrayList
          // List<String> 是父类引用，ArrayList<String> 是子类对象，这是多态的体现
          List<String> fruitList = new ArrayList<>();
  
          // 1. 添加元素 .add()
          fruitList.add("苹果");
          fruitList.add("香蕉");
          fruitList.add("橙子");
          System.out.println("水果列表: " + fruitList);
  
          // 2. 在指定位置添加元素
          fruitList.add(1, "葡萄"); // 在索引1的位置插入
          System.out.println("插入后: " + fruitList);
  
          // 3. 获取元素 .get(index)
          String secondFruit = fruitList.get(1);
          System.out.println("第二个水果是: " + secondFruit);
  
          // 4. 获取列表大小 .size()
          System.out.println("列表里有 " + fruitList.size() + " 种水果。");
  
          // 5. 修改元素 .set(index, newElement)
          fruitList.set(0, "红苹果");
          System.out.println("修改后: " + fruitList);
  
          // 6. 删除元素 .remove()
          fruitList.remove("香蕉"); // 按内容删除
          fruitList.remove(2);     // 按索引删除 (删除的是"橙子")
          System.out.println("删除后: " + fruitList);
          
          // 7. 遍历列表 (for-each 循环是最佳选择)
          System.out.println("--- 遍历水果列表 ---");
          for (String fruit : fruitList) {
              System.out.println(fruit);
          }
      }
  }
  ```

  *   **泛型 (`<String>`)**: 尖括号里的`String`叫做泛型，它像一个“类型标签”，规定了这个`ArrayList`只能存放`String`类型的对象，如果放别的类型（比如数字）编译器会直接报错。这大大增强了代码的安全性。

#### **10.3 `Set`接口 和 `HashSet`**

当你需要存储一组**唯一的**元素，并且不关心它们的顺序时，`Set`是最佳选择。`HashSet`是`Set`最常用的实现，它利用“哈希”算法保证了极高的添加和查找效率。

* **【手把手教学】使用 `HashSet`**

  在`CollectionPractice.java`的`main`方法里继续写：

  ```java
  import java.util.HashSet;
  import java.util.Set;
  
  // ... main 方法内 ...
  System.out.println("\n--- Set 的使用 ---");
  Set<String> uniqueTags = new HashSet<>();
  
  // 1. 添加元素
  uniqueTags.add("Java");
  uniqueTags.add("编程");
  uniqueTags.add("学习");
  System.out.println("标签集合: " + uniqueTags);
  
  // 2. 尝试添加一个重复的元素
  boolean isAdded = uniqueTags.add("Java");
  System.out.println("再次添加'Java'是否成功? " + isAdded); // false
  System.out.println("添加重复元素后: " + uniqueTags); // 内容没有变化
  
  // 3. 检查是否包含某个元素 .contains()
  System.out.println("是否包含'编程'标签? " + uniqueTags.contains("编程")); // true
  
  // 4. 遍历 (只能用 for-each，因为没有索引)
  System.out.println("--- 遍历标签集合 ---");
  for (String tag : uniqueTags) {
      System.out.println(tag);
  }
  ```

  `Set`的**自动去重**特性在很多场景下都非常有用！

#### **10.4 `Map`接口 和 `HashMap`**

当你需要通过一个唯一的“键”来查找对应的“值”时，`Map`是你的不二之选。`HashMap`是`Map`最常用的实现，它也利用哈希算法保证了极快的查找速度。

* **【手把手教学】使用 `HashMap`**

  在`CollectionPractice.java`的`main`方法里继续写：

  ```java
  import java.util.HashMap;
  import java.util.Map;
  
  // ... main 方法内 ...
  System.out.println("\n--- Map 的使用 ---");
  // 创建一个 Map，Key是String类型(学生姓名)，Value是Integer类型(分数)
  Map<String, Integer> studentScores = new HashMap<>();
  
  // 1. 添加键值对 .put(key, value)
  studentScores.put("张三", 95);
  studentScores.put("莉莉", 99);
  studentScores.put("王五", 82);
  System.out.println("学生分数表: " + studentScores);
  
  // 2. 如果 key 已存在，put 会覆盖旧的 value
  studentScores.put("张三", 98); // 张三的分数被更新了
  System.out.println("更新后: " + studentScores);
  
  // 3. 通过 key 获取 value .get(key)
  int liliScore = studentScores.get("莉莉");
  System.out.println("莉莉的分数是: " + liliScore);
  
  // 4. 检查是否包含某个 key .containsKey(key)
  System.out.println("是否包含'赵六'的成绩? " + studentScores.containsKey("赵六")); // false
  
  // 5. 遍历 Map (最常用的方式是遍历 key)
  System.out.println("--- 遍历分数表 ---");
  for (String name : studentScores.keySet()) { // .keySet() 返回所有 key 的集合
      int score = studentScores.get(name);
      System.out.println(name + " 的分数是: " + score);
  }
  
  // 另一种高效的遍历方式 (entrySet)
  System.out.println("--- 使用 entrySet 遍历 ---");
  for (Map.Entry<String, Integer> entry : studentScores.entrySet()) {
      System.out.println(entry.getKey() + " => " + entry.getValue());
  }
  ```

#### **10.5 本章小结与作业**

*   **小结：** 我们学习了Java集合框架的三巨头。**`List`** (有序，可重复)，**`Set`** (无序，唯一)，**`Map`** (键值对，键唯一)。并掌握了它们最常用的实现类 `ArrayList`, `HashSet`, `HashMap` 的基本增删改查和遍历操作。你现在已经拥有了处理动态数据的强大武器！

*   **作业（选择最合适的容器！）：**

    1.  **单词频率统计器：**
        *   给你一段英文文本，例如 `String text = "hello java world hello java programming";`。
        *   编写程序，统计每个单词在这段文本中出现的次数。
        *   打印出类似 `world=1, java=2, hello=2, programming=1` 的结果。
        *   **思考：** 这个问题，用 `List`, `Set`, `Map` 哪个最合适？（提示：你需要一个“键”来代表单词，一个“值”来代表次数）。

    2.  **联系人列表管理：**
        *   创建一个 `Contact` 类，包含 `name` 和 `phoneNumber` 两个属性。
        *   在主程序中，创建一个**列表**来存放多个 `Contact` 对象。
        *   实现一个简单的菜单功能，可以：
            *   1. 添加联系人
            *   2. 按姓名查找并显示电话号码
            *   3. 显示所有联系人
        *   **思考：** 为什么要用`List`而不是`Set`？（提示：可能有同名的人，但电话号码不同）。

    3.  **彩票号码去重：**
        *   假设你机选了一组彩票号码，它们被存放在一个 `ArrayList<Integer>` 中，里面可能有重复的数字，例如 `[10, 23, 5, 10, 8, 23, 9]`。
        *   编写一个方法 `public static List<Integer> removeDuplicates(List<Integer> numbers)`。
        *   这个方法需要返回一个新的`List`，其中包含了所有原始号码，但去除了重复项。例如，返回 `[5, 8, 9, 10, 23]` (顺序可以不同)。
        *   **思考：** `Set` 的什么特性可以帮你轻松解决这个问题？如何巧妙地在`List`和`Set`之间转换？
            *   提示：创建一个`HashSet`，把`List`的所有元素加进去，然后再把`Set`转回`List`。

完成这些作业，你对集合框架的理解和应用将炉火纯青。下一章，我们将学习如何让我们的程序变得更“皮实”，学会优雅地处理可能发生的各种错误——**异常处理**。

好的，没问题！感觉到吃力是非常正常的，因为我们正在从“基础语法”进入“高级应用”的阶段，知识密度和抽象程度都在提高。**集合框架是Java中最重要的部分之一**，我们完全有必要放慢脚步，把每一个细节都弄清楚。

我会用更详细的比喻、更细致的步骤来讲解接下来的内容。请一定记住：**编程学习不是冲刺，而是马拉松。感到困惑时，停下来，多看几遍，多敲几遍代码，理解自然就会水到渠成。**

---

### ****

### **第11章：异常处理 (让你的程序更“耐打”)**

#### **11.1 什么是异常 (Exception)？**

想象一下，你正在开车（运行程序），一切正常。突然，前方修路，一条路被堵死了（程序遇到错误）。这时会发生什么？

*   **没有“异常处理”的程序：** 你的车会直接撞上路障，然后“车毁人亡”（程序**崩溃**，直接终止）。所有后续的任务，比如去超市买菜、回家做饭，都无法完成了。
*   **有“异常处理”的程序：** 你的车载导航（异常处理机制）会提前告诉你：“前方道路不通，已为您规划备用路线！”。你的车会优雅地绕道而行（执行备用方案），虽然可能多花了一点时间，但最终你还是完成了所有任务。

**异常 (Exception)**，就是在程序**运行期间**发生的、打断了正常指令流的非正常事件。比如：

*   你想读取一个根本不存在的文件。
*   你想用一个空的对象去调用它的方法 (`NullPointerException`)。
*   你想访问数组第10个元素，但数组总共只有5个元素 (`ArrayIndexOutOfBoundsException`)。

**异常处理 (Exception Handling)**，就是编写一套“备用方案”，当这些意外发生时，程序不会直接崩溃，而是去执行你预设好的处理逻辑，从而让程序能继续运行或者以一种更优雅的方式结束。

#### **11.2 异常处理的“五大金刚”：`try`, `catch`, `finally`, `throw`, `throws`**

这五个关键字是异常处理的核心，我们一个一个来拆解。

**A. `try...catch` 语句：捕获并处理异常**

这是最核心、最基本的异常处理结构。

*   **`try` 块：** 把**你认为可能会出问题**的代码，像用保护罩一样包裹起来。
*   **`catch` 块：** `try`块的“备用方案”。如果`try`块里的代码真的出了问题（抛出了异常），程序会立刻**跳到**`catch`块里来执行，而不会崩溃。

**【手把手教学】处理一个经典的除零异常**

1. 创建一个新类 `ExceptionPractice.java`。

2. 在`main`方法中，我们先写一段会出错的代码：

   ```java
   public class ExceptionPractice {
       public static void main(String[] args) {
           System.out.println("--- 程序开始 ---");
           
           int a = 10;
           int b = 0;
           int result = a / b; // 这里会发生 ArithmeticException (算术异常)
           
           System.out.println("计算结果是: " + result);
           System.out.println("--- 程序结束 ---");
       }
   }
   ```

   *   **运行它！** 你会看到程序在计算 `a / b` 时直接崩溃，控制台打印出一堆红色的错误信息，最重要的是最后那句 `"--- 程序结束 ---"` **根本没有被执行**！

3. **现在，我们用 `try...catch` 来拯救它！**

   ```java
   public class ExceptionPractice {
       public static void main(String[] args) {
           System.out.println("--- 程序开始 ---");
           
           try {
               // 1. 把可能出错的代码放进 try 块
               System.out.println("正在尝试进行计算...");
               int a = 10;
               int b = 0;
               int result = a / b; // 异常在这里发生
               // 异常发生后，try块中从这一行往下的代码都不会被执行了
               System.out.println("计算结果是: " + result); 
           } catch (ArithmeticException e) {
               // 2. 如果 try 块里发生了 "ArithmeticException" 类型的异常，就捕获它
               //    e 是一个异常对象，包含了错误的详细信息
               System.out.println("糟糕！计算出错了！");
               System.out.println("错误类型是: " + e.getClass().getName());
               System.out.println("错误信息是: " + e.getMessage());
               // 打印完整的错误堆栈信息，方便调试
               // e.printStackTrace(); 
           }
           
           System.out.println("--- 程序优雅地结束了 ---");
       }
   }
   ```

   *   **再次运行它！** 这次程序完全不同了：
       1.  它打印了“程序开始”和“正在尝试进行计算...”。
       2.  当执行 `a / b` 出错时，它没有崩溃，而是立刻跳转到了 `catch` 块。
       3.  它执行了 `catch` 块里的所有打印语句，告诉你发生了什么错误。
       4.  最重要的是，它**跳过了**`try`块里出错代码之后的所有内容，并继续执行`catch`块**之后**的代码，最终打印出了“程序优雅地结束了”。

**B. `finally` 块：无论如何都要执行**

有些代码，我们希望**不管有没有发生异常，都必须被执行**。比如关闭文件、释放网络连接等资源清理工作。这时就需要 `finally`。

*   **`finally` 块：** 紧跟在 `try...catch` 之后，它的代码**总是**会被执行。
    *   情况1：`try` 没出异常 -> `try` 走完 -> `finally` 执行。
    *   情况2：`try` 出了异常，`catch` 捕获了 -> `try` 中断 -> `catch` 走完 -> `finally` 执行。
    *   情况3：`try` 出了异常，但没有匹配的 `catch` 块 -> `try` 中断 -> `finally` 执行 -> 程序崩溃。

**【手把手教学】模拟文件操作**

```java
// 在 ExceptionPractice.java 的 main 方法里继续写
public static void simulateFileOperation() {
    System.out.println("\n--- 模拟文件操作 ---");
    // 假设 file 是一个需要被关闭的资源
    Object file = null; 
    try {
        System.out.println("1. 打开文件资源...");
        file = new Object(); // 模拟文件被成功打开

        // 模拟在读写文件时可能发生错误
        if (true) { // 我们强制让它出错
            throw new RuntimeException("读取文件时磁盘满了！");
        }
        
        System.out.println("2. 文件读写成功..."); // 这句不会被执行
    } catch (Exception e) {
        System.out.println("捕获到异常: " + e.getMessage());
        // 就算这里处理了异常，我们还是需要关闭文件
    } finally {
        // 3. 无论成功还是失败，finally 块总是会被执行
        System.out.println("进入 finally 块...");
        if (file != null) {
            System.out.println("关闭文件资源！");
            file = null;
        }
    }
}
// 在 main 方法里调用它
public static void main(String[] args) {
    // ... 上面的代码 ...
    simulateFileOperation();
}
```

*   运行代码，你会看到，即使`try`块中途因为异常而跳出，`finally`块里的“关闭文件资源！”也一定会被打印。这就是它的价值所在。

**C. `throw` 和 `throws`：抛出异常**

有时候，一个方法自己不知道如何处理一个异常，它希望把这个“烫手山芋”**扔给调用它的人**去处理。

*   **`throw`:** 用在**方法体内部**，表示**主动抛出一个异常**。后面跟一个具体的异常对象 `new Exception(...)`。
*   **`throws`:** 用在**方法签名上**，表示这个方法**可能会抛出**某种类型的异常，它自己不处理，提醒调用者必须处理（用`try-catch`或继续`throws`）。

**【手把手教学】用户注册**

假设我们有一个检查用户名的方法，如果用户名不合法，它应该抛出异常。

1. **先自定义一个异常类（好习惯）**

   ```java
   // 自定义一个“无效用户名异常”
   class InvalidUsernameException extends Exception {
       public InvalidUsernameException(String message) {
           super(message);
       }
   }
   ```

2. **编写一个会“扔”异常的方法**

   ```java
   // 在 ExceptionPractice.java 类里添加一个新方法
   // 使用 throws 关键字声明：我这个方法可能会扔出 InvalidUsernameException
   public static void registerUser(String username) throws InvalidUsernameException {
       System.out.println("正在尝试注册用户: " + username);
       
       if (username == null || username.length() < 6) {
           // 用户名不合法，我不知道怎么办，就创建一个异常对象然后 throw 扔出去！
           throw new InvalidUsernameException("用户名长度不能小于6位！");
       }
       
       System.out.println("用户 " + username + " 注册成功！");
   }
   ```

3. **调用这个方法，并且处理它扔过来的异常**

   ```java
   // 在 main 方法里调用
   public static void main(String[] args) {
       // ...
       
       // --- 处理声明要抛出的异常 ---
       // 因为 registerUser 声明了 throws，所以我们调用它时必须用 try-catch
       try {
           registerUser("zhangsanfeng"); // 合法用户名
           registerUser("lisi");        // 不合法用户名
       } catch (InvalidUsernameException e) {
           System.out.println("注册失败！原因: " + e.getMessage());
       }
   }
   ```

#### **11.3 本章小结与作业**

*   **小结：** 我们深入理解了**异常**是程序运行时的意外。学会了使用 `try` 来包裹危险代码，用 `catch` 来捕获并处理异常，用 `finally` 来确保资源被释放。我们还学会了如何使用 `throw` 主动抛出异常，以及如何用 `throws` 在方法上声明可能发生的异常，将处理责任交给调用者。你现在写的代码，已经从“理想化”变得更加“现实”和“健壮”了。

*   **作业（让你的程序刀枪不入！）：**

    1.  **健壮的除法计算器：**
        *   写一个方法 `public static double divide(double a, double b)`。
        *   在 `main` 方法中，接收用户的两个输入作为除数和被除数。（还记得第3章的 `Scanner` 吗？`scanner.nextDouble()`）。
        *   调用 `divide` 方法并打印结果。
        *   **要求：**
            *   a) 如果用户输入的不是数字（例如输入了"abc"），程序不能崩溃，要提示用户“请输入有效的数字！”。（提示：`scanner.nextDouble()` 在遇到非法输入时会抛出 `InputMismatchException`）。
            *   b) 如果用户输入的第二个数字是0，程序不能崩溃，要提示用户“除数不能为零！”。
            *   c) 无论计算成功还是失败，最后都要打印一句 "感谢使用本计算器！"。
        *   **你需要综合使用 `try-catch-finally` 来完成这个任务。**

    2.  **模拟取款：**
        *   创建一个自定义异常 `InsufficientFundsException` (余额不足异常)。
        *   创建一个 `Account` 类，有 `private double balance` (余额) 属性。
        *   在 `Account` 类中写一个 `public void withdraw(double amount)` (取款) 方法。
        *   **逻辑：**
            *   如果 `amount` (取款金额) 大于 `balance` (余额)，就 `throw new InsufficientFundsException("余额不足！")`。
            *   否则，就用余额减去取款金额，并打印“取款成功，剩余余额...”。
        *   这个 `withdraw` 方法应该在方法签名上用 `throws` 声明它可能抛出 `InsufficientFundsException`。
        *   在 `main` 方法中，创建一个 `Account` 对象（比如有1000元余额），然后尝试取款500元，再尝试取款800元。使用 `try-catch` 来捕获可能发生的“余额不足”异常，并优雅地打印出提示信息。

当你完成这些练习后，你会发现自己看待代码的方式都变了，你会下意识地去思考“这里会不会出错？出错了该怎么办？”。这正是成为一个专业开发者的重要标志。

下一站，我们将学习如何让你的程序**同时做好几件事**——**多线程**！这将是另一个充满挑战又极具威力的领域。

天啊，非常感谢你的指正！你完全正确，我竟然跳过了如此至关重要的一章！你的细心和专注让我印象深刻，这正是一个优秀学习者必备的品质。

I/O流是连接程序与外部世界（如文件、网络）的桥梁，是任何实用程序都离不开的核心功能。我很抱歉在之前的规划中遗漏了它，现在我们立刻补上这关键的一课。让我们把多线程的章节号调整一下，先把I/O流学扎实。

---

### ****

### **第12章：I/O流 (读写文件)**

到目前为止，我们程序中的所有数据都存储在内存里。程序一旦关闭，数据就全部丢失了。为了让数据能够**持久化 (Persistence)**，也就是长久地保存下来，我们需要将它们写入到外部设备中，最常见的就是**硬盘上的文件**。

**I/O** 就是 **Input / Output** 的缩写，即**输入/输出**。

*   **输入 (Input):** 从外部设备（如文件、网络）**读取**数据到程序（内存）中。
*   **输出 (Output):** 将程序（内存）中的数据**写入**到外部设备（如文件、网络）中。

Java的I/O体系非常庞大和灵活，它基于“**流 (Stream)**”这个核心概念。

*   **流 (Stream):** 就像一根**数据管道**，数据会像水流一样在其中单向流动。你只需要关心从管道的哪一端读，往哪一端写，而不用关心数据在管道中具体是怎么传输的。



#### **12.1 I/O流的分类**

Java的I/O流可以从两个维度来分类：

1.  **按流向分：**
    *   **输入流 (InputStream, Reader):** 用来读。
    *   **输出流 (OutputStream, Writer):** 用来写。

2.  **按处理的数据单元分：**
    *   **字节流 (Byte Stream - `InputStream`/`OutputStream`):** 以**字节 (byte)**为单位处理数据。它可以处理**任何类型**的文件（图片、视频、文本等），是I/O的“万金油”。
    *   **字符流 (Character Stream - `Reader`/`Writer`):** 以**字符 (char)**为单位处理数据。它专门用于处理**纯文本文件**，并且能自动处理字符编码（如UTF-8, GBK），避免乱码问题。

**选择原则：**

*   处理**纯文本**文件（.txt, .java, .md等） -> **优先使用字符流**。
*   处理**二进制**文件（.jpg, .mp4, .exe, .zip等）-> **必须使用字节流**。

#### **12.2 文件操作的基石：`File` 类**

在进行文件读写之前，我们首先需要用 `java.io.File` 类来代表一个文件或目录的**路径**。`File`对象本身**不包含文件内容**，它只是文件在硬盘上的一个“地址名片”。

* **【手把手教学】使用 `File` 类**

  ```java
  import java.io.File;
  import java.io.IOException;
  
  public class FilePractice {
      public static void main(String[] args) throws IOException { // 暂时先抛出异常
          // 1. 创建一个 File 对象，代表一个文件路径
          // 路径可以是绝对路径，也可以是相对路径（相对于项目根目录）
          File file = new File("my_first_file.txt");
  
          // 2. 判断文件是否存在
          if (!file.exists()) {
              System.out.println("文件不存在，现在创建它！");
              // 3. 创建文件
              file.createNewFile();
          } else {
              System.out.println("文件已存在。");
          }
  
          // 4. 获取文件信息
          System.out.println("文件名: " + file.getName());
          System.out.println("文件路径: " + file.getPath());
          System.out.println("绝对路径: " + file.getAbsolutePath());
          System.out.println("文件大小 (字节): " + file.length());
  
          // 5. 删除文件
          // System.out.println("删除文件: " + file.delete());
      }
  }
  ```

  *   运行代码，你会在你的项目根目录下看到一个新创建的 `my_first_file.txt` 文件。

#### **12.3 字符流实战：读写文本文件 (`FileReader` / `FileWriter`)**

这是处理纯文本最直接的方式。

* **【手把手教学】写入和读取文本**

  ```java
  import java.io.FileReader;
  import java.io.FileWriter;
  import java.io.IOException;
  
  public class CharacterStreamPractice {
      public static void main(String[] args) {
          File file = new File("poem.txt");
  
          // --- 1. 使用 FileWriter 写入文件 ---
          // 使用 try-with-resources 语法，可以自动关闭流，非常推荐！
          try (FileWriter writer = new FileWriter(file)) {
              writer.write("静夜思\n"); // \n 是换行符
              writer.write("床前明月光，\n");
              writer.write("疑是地上霜。\n");
              writer.write("举头望明月，\n");
              writer.write("低头思故乡。\n");
              System.out.println("诗歌写入成功！");
          } catch (IOException e) {
              System.out.println("写入文件时出错: " + e.getMessage());
          }
  
          System.out.println("\n--- 2. 使用 FileReader 读取文件 ---");
          try (FileReader reader = new FileReader(file)) {
              // 一次读取一个字符
              int charCode;
              System.out.println("开始逐字读取：");
              while ((charCode = reader.read()) != -1) { // read()返回-1表示读到文件末尾
                  // 将整数编码转为字符并打印
                  System.out.print((char) charCode);
              }
          } catch (IOException e) {
              System.out.println("读取文件时出错: " + e.getMessage());
          }
      }
  }
  ```

  *   **`try-with-resources` 语法：**
      *   `try (资源声明) { ... }`
      *   这是Java 7引入的语法糖，凡是写在`try()`括号里的、实现了`AutoCloseable`接口的资源（所有I/O流都实现了），在`try`块执行完毕后，Java会**自动帮你调用`.close()`方法**。
      *   这极大地简化了代码，并避免了忘记关闭流导致的资源泄露。**强烈建议所有I/O操作都使用这种方式！**

#### **12.4 I/O流的“装修升级”：缓冲流**

`FileReader`和`FileWriter`虽然能用，但它们每次读写都是直接操作硬盘，效率较低。就像你每次只从仓库搬一箱货，来回跑很累。

**缓冲流 (Buffered Stream)** 就像是在仓库和你之间加了一个**小推车**。

*   **写操作：** 你先把很多箱货都放到小推车上（写入缓冲区），等车满了，再一趟推到仓库里（一次性写入硬盘）。
*   **读操作：** 你一次性从仓库推一整车货出来（读入缓冲区），然后需要时再从小推车上拿。

这样大大减少了直接与硬盘交互的次数，**性能得到巨大提升**。

*   **`BufferedReader` (配合 `FileReader`)**
*   **`BufferedWriter` (配合 `FileWriter`)**

它们是“处理流”或“包装流”，需要“套”在已有的节点流（如`FileReader`）上使用。

* **【手把手教学】使用缓冲流提升效率**

  ```java
  import java.io.*; // 引入所有io类
  
  public class BufferedStreamPractice {
      public static void main(String[] args) {
          File file = new File("buffered_poem.txt");
  
          // --- 1. 使用缓冲流写入 ---
          try (BufferedWriter writer = new BufferedWriter(new FileWriter(file))) {
              writer.write("春晓");
              writer.newLine(); // BufferedWriter 提供了方便的换行方法
              writer.write("春眠不觉晓，");
              writer.newLine();
              writer.write("处处闻啼鸟。");
              System.out.println("使用缓冲流写入成功！");
          } catch (IOException e) {
              e.printStackTrace();
          }
  
          System.out.println("\n--- 2. 使用缓冲流高效读取 ---");
          // BufferedReader 提供了更方便的按行读取方法 readLine()
          try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
              String line;
              while ((line = reader.readLine()) != null) { // readLine() 读到末尾返回 null
                  System.out.println(line);
              }
          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  }
  ```

  *   **核心模式：** `new 包装流(new 节点流(文件对象))`，像套娃一样，一层一层地增强功能。

#### **12.5 字节流实战：复制图片**

对于非文本文件，我们必须使用字节流。下面我们来演示如何复制一张图片。

1. 先在你的项目根目录下放一张图片，比如 `logo.png`。

2. 编写代码：

   ```java
   import java.io.*;
   
   public class ByteStreamPractice {
       public static void main(String[] args) {
           // 源文件和目标文件
           File sourceFile = new File("logo.png");
           File destFile = new File("logo_copy.png");
   
           // 同样使用带缓冲的字节流，性能更好
           // FileInputStream -> BufferedInputStream
           // FileOutputStream -> BufferedOutputStream
           try (
               BufferedInputStream bis = new BufferedInputStream(new FileInputStream(sourceFile));
               BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFile))
           ) {
               System.out.println("开始复制图片...");
               
               // 创建一个缓冲区（小水桶），大小通常是1024的倍数
               byte[] buffer = new byte[1024]; 
               int bytesRead; // 记录每次实际读到的字节数
   
               // 循环读取和写入
               while ((bytesRead = bis.read(buffer)) != -1) {
                   // 读了多少，就写多少
                   bos.write(buffer, 0, bytesRead);
               }
   
               System.out.println("图片复制成功！");
   
           } catch (IOException e) {
               e.printStackTrace();
           }
       }
   }
   ```

   *   运行代码后，你会看到项目下多了一个 `logo_copy.png` 文件，它和原图一模一样。

#### **12.6 本章小结与作业**

* **小结：** 我们掌握了Java I/O的核心——**流**。理解了**字节流**和**字符流**的区别与适用场景。学会了使用`File`类操作文件路径，并重点实践了使用**字符流**（`FileReader`/`Writer`）和**字节流**（`FileInputStream`/`OutputStream`）进行文件读写。最重要的是，我们学会了使用**缓冲流**（`BufferedReader`/`Writer`, `BufferedInputStream`/`OutputStream`）来极大地提升I/O性能，并掌握了`try-with-resources`这一现代、安全的资源管理方式。

* **作业（打造你的文件工具箱！）：**

  1. **日记本程序：**

     * 创建一个程序，运行时提示用户输入今天的日期（如"2023-10-27"）和日记内容。

     * 程序需要将用户的日记追加（而不是覆盖）到一个名为 `diary.txt` 的文件中。

     * 每一篇日记的格式应该是：

       ```
       ====================
       日期: 2023-10-27
       ====================
       今天天气很好，我学习了Java的I/O流，收获很大。
       ```

     * **提示：** `new FileWriter("diary.txt", true)`，第二个参数 `true` 表示以**追加模式**打开文件。

  2. **简单的文本文件查看器：**

     * 程序启动后，要求用户输入一个文件名。

     * 使用 `BufferedReader` 按行读取该文件的所有内容，并在每一行的前面加上行号后，打印到控制台。

     * 例如：

       ```
       1: public class HelloWorld {
       2:     public static void main(String[] args) {
       3:         // ...
       4:     }
       5: }
       ```

     * **健壮性要求：** 如果用户输入的文件不存在，要使用 `try-catch` 捕获 `FileNotFoundException`，并友好地提示用户“文件未找到！”。

  3. **配置文件解析器（挑战！）：**

     * 创建一个名为 `config.properties` 的文本文件，内容如下（这是一个常见的键值对格式）：

       ```
       username=admin
       password=123456
       server.ip=192.168.1.100
       server.port=8080
       ```

     * 编写一个程序，读取这个文件，并将其内容解析到一个 `Map<String, String>` 中。

     * 最终，程序可以根据`key`（如 "username"）从`Map`中获取对应的`value`（"admin"）并打印出来。

     * **提示：** 按行读取文件，然后对每一行使用 `String` 的 `split("=", 2)` 方法来分割键和值。注意处理空行和以 `#` 开头的注释行（可以跳过它们）。

完成这些练习，你将对文件操作充满信心。现在，我们已经补上了I/O这一课，可以正式将**第13章**的内容定为**多线程**了。你的工具箱正变得越来越丰富！

好的，我们继续！

你已经学会了如何使用Java强大的API库来处理文本、日期、文件等静态数据，并掌握了如何通过异常处理让程序变得健壮。现在，我们将进入一个让程序“活”起来的全新领域——**多线程**。

在学习这一章之前，请做好心理准备，多线程是Java中一个强大但又有些抽象的概念。它能让你的程序“一心多用”，极大地提升效率，但如果理解不当，也很容易出错。请放心，我们会用最通俗易懂的方式来攻克它。

---

### 

### **第13章：多线程 (让程序同时做多件事)**

#### **13.1 为什么需要多线程？(The "Why")**

想象一下，你在使用一个软件下载文件。

*   **单线程模式（一条路走到黑）：** 当你点击“下载”后，整个软件界面就卡住了，动弹不得，你不能点击任何其他按钮，必须等到文件下载完成，软件才能恢复响应。这是因为程序只有**一个执行流**，它正忙于下载，没空搭理你的其他操作。
*   **多线程模式（多车道高速公路）：** 当你点击“下载”后，程序会**开启一个新的、专门负责下载的执行流（线程）**。与此同时，原来的主执行流（主线程）可以继续负责界面的响应。所以，你可以一边看着下载进度条前进，一边还能点击菜单、切换页面，体验非常流畅。

**多线程的核心价值**：提高程序的**响应速度**和**处理效率**，尤其是在需要执行耗时任务（如网络请求、文件读写、复杂计算）的同时，还需要保持用户界面的流畅性。

#### **13.2 核心概念：进程 (Process) 与 线程 (Thread)**

为了更好地理解，我们用一个工厂的比喻：

*   **进程 (Process):**
    *   **比喻：** 一个**完整的工厂**。
    *   **定义：** 操作系统中一个正在运行的应用程序（比如你打开的Word、Chrome浏览器、你的Java程序）。
    *   **特点：** 每个进程都拥有自己**独立**的内存空间、系统资源。工厂与工厂之间是隔离的。

*   **线程 (Thread):**
    *   **比喻：** 工厂里的一条**生产线**或者一个**工人**。
    *   **定义：** 进程中的一个**单一的、顺序的执行流**。一个进程至少有一个线程（主线程），也可以有多个线程。
    *   **特点：** 同一个进程内的所有线程**共享**该进程的内存空间和资源（比如共享原料、共享工具）。这既带来了高效协作的便利，也带来了“资源抢夺”的风险。

**总结：** 进程是资源分配的基本单位，线程是CPU调度的基本单位。我们的目标，就是在我们的Java程序（一个进程）里，创建多个线程（工人），让他们分工协作。

#### **13.3 【手把手教学】创建线程的两种方式**

在Java中，创建并启动一个新线程，主要有两种方法。

**方式一：继承 `Thread` 类 (简单直观，但不推荐)**

1.  **定义一个子类，继承 `java.lang.Thread` 类。**
2.  **重写 (`@Override`) `run()` 方法。** 这个 `run()` 方法就是新的线程需要执行的“任务清单”。
3.  **创建这个子类的对象。**
4.  **调用该对象的 `start()` 方法来启动线程。** **（重要：是调用 `start()`，不是 `run()`!）**

```java
// ThreadCreationPractice.java

// 1. 定义一个继承自 Thread 的类
class DownloaderThread extends Thread {
    private String url;

    public DownloaderThread(String url) {
        this.url = url;
    }

    // 2. 重写 run 方法，定义线程要干的活
    @Override
    public void run() {
        System.out.println("线程 " + Thread.currentThread().getName() + " 开始下载: " + url);
        try {
            // 模拟下载耗时
            Thread.sleep(3000); // 让线程休眠3秒 (3000毫秒)
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("线程 " + Thread.currentThread().getName() + " 下载完成!");
    }
}

public class ThreadCreationPractice {
    public static void main(String[] args) {
        System.out.println("主线程开始...");

        // 3. 创建线程对象
        DownloaderThread downloader1 = new DownloaderThread("http://example.com/movie.mp4");
        DownloaderThread downloader2 = new DownloaderThread("http://example.com/music.mp3");

        // 4. 调用 start() 启动线程，Java虚拟机会在合适的时机调用 run() 方法
        downloader1.start();
        downloader2.start();

        System.out.println("主线程继续做其他事情...");
        // 你会发现，主线程的这句话会立刻被打印出来，而不会等下载完成。
    }
}
```

*   **运行代码**，仔细观察控制台输出的顺序。你会发现“下载开始”和“下载完成”的打印是交错的，并且主线程的任务没有被阻塞。

**方式二：实现 `Runnable` 接口 (推荐！更灵活)**

*   **为什么更推荐？** Java是单继承的。如果你的类已经继承了另一个类，就不能再继承`Thread`了。而实现接口没有这个限制，一个类可以实现多个接口。这使得代码设计更灵活。

1.  **定义一个类，实现 `java.lang.Runnable` 接口。**
2.  **实现接口中的 `run()` 方法。**
3.  **创建这个实现了 `Runnable` 接口的类的对象（这只是一个“任务”）。**
4.  **创建一个 `Thread` 对象，并将上一步的“任务”对象作为参数传给 `Thread` 的构造方法。**
5.  **调用 `Thread` 对象的 `start()` 方法。**

```java
// RunnableCreationPractice.java

// 1. 定义一个实现 Runnable 接口的类
class MusicPlayerTask implements Runnable {
    // 2. 实现 run 方法
    @Override
    public void run() {
        System.out.println("音乐播放线程 " + Thread.currentThread().getName() + " 开始播放音乐...");
        for (int i = 0; i < 5; i++) {
            System.out.println("...正在播放 'My Heart Will Go On'...");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("音乐播放完毕。");
    }
}

public class RunnableCreationPractice {
    public static void main(String[] args) {
        System.out.println("主线程：我正在写作业...");

        // 3. 创建任务对象
        MusicPlayerTask musicTask = new MusicPlayerTask();
        
        // 4. 创建 Thread 对象，并把任务"装"进去
        Thread musicThread = new Thread(musicTask);
        musicThread.setName("音乐播放器"); // 可以给线程起个名字

        // 5. 启动线程
        musicThread.start();
        
        System.out.println("主线程：继续写我的作业，音乐真好听！");
    }
}
```

*   这两种方式达到的效果是一样的，但实现`Runnable`接口的方式将**任务（`Runnable`）**和**执行者（`Thread`）**解耦了，是更优秀的设计。

#### **13.4 线程安全问题 (The BIG Problem)**

这是多线程编程中最核心、最棘手的问题。

* **问题根源：** 多个线程**同时读写同一个共享资源**。

* **比喻：** 银行只有一个账户（共享资源），余额1000元。你和你老婆同时在两台ATM机（两个线程）上取钱。

  1.  你查询余额，是1000。
  2.  几乎同时，你老婆也查询余额，也是1000。
  3.  你取了800，系统计算 `1000 - 800 = 200`，准备把200写回账户。
  4.  在你写回之前，你老婆取了500，系统计算 `1000 - 500 = 500`。
  5.  你老婆的ATM机先把500写回了账户，余额变为500。
  6.  然后你的ATM机才把200写回账户，余额变为200。

  *   **结果：** 你们总共取了1300，但账户最后竟然是200元，银行亏了1100元！这就是**数据错乱**，也叫**线程不安全**。

#### **13.5 解决方案：线程同步 `synchronized`**

为了解决资源抢夺问题，Java提供了“同步”机制，最简单的就是使用 `synchronized` 关键字。

*   **比喻：** 就像给共享资源所在的“房间”（代码块或方法）**加一把锁**。一个线程进去后，会把门锁上。其他线程想进来，必须在门口排队等着，直到里面的线程出来并把锁交出来。

**【手把手教学】模拟不安全的买票，并修复它**

```java
// UnsafeTicketSeller.java

class TicketOffice implements Runnable {
    // 共享资源：总共10张票
    private int ticketCount = 10;
    
    @Override
    public void run() {
        while (ticketCount > 0) {
            // 模拟网络延迟或出票耗时，让问题更容易暴露
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            // 这里就是危险区域！多个线程可能同时读到同一个 ticketCount 值
            System.out.println(Thread.currentThread().getName() + " 卖出了第 " + ticketCount-- + " 张票");
        }
    }
}

public class UnsafeTicketSeller {
    public static void main(String[] args) {
        TicketOffice office = new TicketOffice();

        // 创建3个售票窗口（线程），都卖同一个办公室的票
        new Thread(office, "窗口1").start();
        new Thread(office, "窗口2").start();
        new Thread(office, "窗口3").start();
    }
}
```

*   **运行多次**，你很可能会看到**卖出了重复的票号**，或者最后票数变成了负数。这就是线程不安全。

**【修复版】使用 `synchronized`**

我们只需要给危险的操作（`run`方法）加上`synchronized`即可。

```java
// SafeTicketSeller.java

// 我们把 run 方法变成一个同步方法
class SafeTicketOffice implements Runnable {
    private int ticketCount = 10;
    private boolean flag = true; // 循环控制

    // 加上 synchronized，这个方法就变成了一个"同步方法"
    // 同一时间，只有一个线程能进入这个方法
    public synchronized void sellTicket() {
        if (ticketCount > 0) {
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + " 卖出了第 " + ticketCount-- + " 张票");
        } else {
            flag = false; // 票卖完了
        }
    }

    @Override
    public void run() {
        while (flag) {
            sellTicket();
        }
    }
}

public class SafeTicketSeller {
    public static void main(String[] args) {
        SafeTicketOffice office = new SafeTicketOffice();
        new Thread(office, "窗口1").start();
        new Thread(office, "窗口2").start();
        new Thread(office, "窗口3").start();
    }
}
```

*   **现在再运行**，无论多少次，售票顺序都是正确的，从10到1，绝不会重复。因为`sellTicket`方法被锁住了，每次只有一个线程能进去卖票。

#### **13.6 本章小结与作业**

*   **小结：** 我们理解了多线程是为了提升程序性能和响应能力。掌握了**创建线程的两种方式**（继承`Thread`和实现`Runnable`，后者更优）。最重要的是，我们直面了多线程的**核心难题——线程安全**，并学会了使用`synchronized`关键字来**实现线程同步**，保护共享资源。

*   **作业（直面线程安全！）：**

    1.  **龟兔赛跑模拟：**
        *   创建两个线程，一个代表“乌龟”，一个代表“兔子”。
        *   它们都在`run`方法里循环100次，每次循环代表跑了1米。
        *   乌龟每跑1米，就休息10毫秒 (`Thread.sleep(10)`)。
        *   兔子速度快，每跑1米，只休息1毫秒 (`Thread.sleep(1)`)。但是，兔子有个毛病，每跑10米，就要打个盹，休息100毫秒。
        *   在每次循环中，打印出谁跑了多少米。
        *   在其中一个线程的`run`方法结束时，打印出“XXX到达终点！”。看看谁先到。
        *   这个练习主要为了巩固线程的创建和`sleep`方法的使用。

    2.  **银行账户存取款问题：**
        *   创建一个`Account`类，包含一个`private double balance`属性。
        *   提供两个**同步方法**：`public synchronized void deposit(double amount)` (存款) 和 `public synchronized void withdraw(double amount)` (取款)。
        *   创建一个“储户”线程，循环10次，每次向同一个账户存入100元。
        *   创建一个“取款者”线程，循环10次，每次从同一个账户取出100元。
        *   在`main`方法中，创建一个初始余额为0的`Account`对象。同时启动“储户”和“取款者”两个线程。
        *   在两个线程都执行完毕后（可以用`Thread.sleep()`在主线程里等一会儿），打印账户的最终余额。
        *   **思考：** 如果存款和取款方法**不加`synchronized`**，最终余额会是多少？加上之后，最终余额又应该是多少？（正确答案应该是0）。通过这个对比，深刻理解`synchronized`的作用。

多线程是一个庞大的话题，我们今天接触的是最核心、最基础的部分。当你熟练掌握这些后，未来还可以探索线程池、锁、并发集合等更高级的工具。

你已经完成了Java进阶阶段的学习！你的代码能力和思考深度都已今非昔比。下一站，我们将进入**第四阶段：Java生态与实战**，开始接触真实项目开发中必不可少的工具，让你从一个“会写Java的人”向一个“能做项目的工程师”转变！

太棒了！你的坚持和毅力已经带你走过了Java学习中最陡峭的山路。你现在掌握了Java的核心语法、面向对象的思想以及一系列强大的API。

现在，我们正式开启**第四阶段：Java生态与实战 (The Ecosystem & Real World)**。

从这一刻起，我们的视角要从“学习一门语言”转变为“**使用这门语言来构建一个真正的项目**”。我们将学习工程师们在日常工作中每天都在使用的工具和流程。这会让你离成为一名真正的Java工程师越来越近。

第一站，就是所有现代Java项目的基石——**项目管理工具**。

---

<div style="display: flex; justify-content: space-around;">
  <span>
    <a href="./2.Java从零到精通-第二阶段.md">
      ← 上一篇：二
    </a>
  </span>
  <span>
    <a href="./4.Java从零到精通-第四阶段.md">
      下一篇：第四阶段 →
    </a>
  </span>
</div>
