## **第二阶段：面向对象核心 (The Core of Java)**

<div style="display: flex; justify-content: space-around;">
  <span>
    <a href="./1.Java从零到精通-第一阶段.md">
      ← 上一篇：第一阶段
    </a>
  </span>
  <span>
    <a href="./3.Java从零到精通-第三阶段.md">
      下一篇：第三阶段 →
    </a>
  </span>
</div>

### **第6章：类与对象 (万物皆对象)**

#### **6.1 从“面向过程”到“面向对象”**

到目前为止，我们的编程方式叫做“面向过程”。我们关心的是“第一步做什么，第二步做什么”，代码和数据是分离的。比如在`main`方法里，我们定义一个`int price`，又定义一个`int count`，然后再写一个`for`循环来处理它们。这就像一个厨师，食材（数据）和菜谱（代码）都摊在桌子上，显得有些杂乱。

**面向对象 (OOP)** 换了一种思路。它认为，世界是由一个个“事物”组成的，每个事物都有它自己的**属性**（数据）和**行为**（能做什么）。OOP的目标就是把相关的属性和行为**打包**在一起，形成一个独立的、完整的“对象”。

*   **面向过程：** 思考“怎么做？” —— 关注**步骤**。
*   **面向对象：** 思考“谁来做？” —— 关注**对象**。

**【生活中的例子】**

*   **“汽车”**这个对象：
    *   **属性（它有什么）：** 颜色、品牌、重量、当前速度。
    *   **行为（它能做什么）：** 启动、加速、刹车、鸣笛。

OOP就是让我们在代码中创建出像“汽车”这样具体的“对象”来帮我们做事。

#### **6.2 蓝图：类 (Class)**

如果我们要造一辆车，我们首先需要一张**设计图纸**。这张图纸规定了车应该有哪些属性和行为。

在Java中，这张“图纸”就是**类 (Class)**。

*   **类 (Class):** 是一个模板，一个蓝图。它描述了**某一类事物**应该具有的共同属性和行为。它是一个抽象的概念。
*   **对象 (Object):** 是根据“类”这个蓝图**创造出来**的一个**具体的、真实的个体**。它是实实在在存在的东西，也叫**实例 (Instance)**。

例如：`汽车设计图`是**类**，而`一辆红色的法拉利`、`一辆黑色的特斯拉`就是两个不同的**对象**。

**【手把手教学】设计一个“学生”类**

1.  在你的项目中，在 `src` 文件夹上右键 -> **New** -> **Java Class**。
2.  输入类名 `Student` (类名通常首字母大写)，然后回车。IDEA会为你创建一个新的 `Student.java` 文件。

```java
// Student.java 文件
public class Student {
    // 这个类是空的，现在我们来为它添加属性和行为

    // 1. 属性 (Attributes / Member Variables)
    //    学生有什么？我们把它们定义为类的成员变量。
    String name;  // 姓名
    int age;      // 年龄
    double score; // 分数

    // 2. 行为 (Behaviors / Member Methods)
    //    学生能做什么？我们把它们定义为类的方法。
    //    注意：这里的方法前面不再需要加 static 了！
    public void study() {
        // this 关键字代表“当前这个对象”
        System.out.println(this.name + " 正在努力学习Java！");
    }

    public void sayHello() {
        System.out.println("大家好，我叫 " + name + "，今年 " + age + " 岁了。");
    }
}
```

现在，我们有了一张“学生”的设计图纸 `Student.class`。

#### **6.3 创造与使用：对象 (Object)**

有了图纸，我们就可以开始“造人”了！这个过程叫做**实例化 (Instantiation)**。

*   **语法：** `类名 对象名 = new 类名();`

**【手把手教学】创建和使用学生对象**

1.  我们不能在 `Student.java` 文件里运行，因为它没有 `main` 方法。我们需要一个“主舞台”来使用我们的 `Student` 类。
2.  创建一个新类 `School`，并让IDEA为它生成 `main` 方法。

```java
// School.java 文件
public class School {
    public static void main(String[] args) {
        // --- 创建第一个学生对象 stu1 ---
        // 使用 Student 蓝图，new 一个具体的学生实例
        Student stu1 = new Student();

        // --- 使用 "对象名.属性名" 的方式给对象的属性赋值 ---
        stu1.name = "张三";
        stu1.age = 18;
        stu1.score = 95.5;

        // --- 使用 "对象名.方法名()" 的方式调用对象的行为 ---
        System.out.println("学生1的信息：");
        stu1.sayHello(); // 输出：大家好，我叫 张三，今年 18 岁了。
        stu1.study();    // 输出：张三 正在努力学习Java！

        System.out.println("\n--------------------------\n");

        // --- 创建第二个学生对象 stu2 ---
        Student stu2 = new Student();
        stu2.name = "莉莉";
        stu2.age = 17;
        stu2.score = 99.0;
        
        System.out.println("学生2的信息：");
        stu2.sayHello(); // 输出：大家好，我叫 莉莉，今年 17 岁了。
    }
}
```

*   **运行 `School.java`**。你会看到，我们成功地创建了两个独立的学生对象，每个对象都有自己的一套属性 (`name`, `age`)，并且都能执行 `sayHello()` 这种行为。

#### **6.4 快速初始化：构造方法 (Constructor)**

每次创建完对象，都要挨个 `.` 属性去赋值，有点麻烦。有没有办法在 `new` 的时候，就直接把姓名、年龄这些信息传递进去呢？有！这就是**构造方法**。

*   **构造方法：** 是一个特殊的、与类同名的方法，它没有返回值类型（连`void`都不能写）。它的唯一作用，就是在 `new` 对象的时候被**自动调用**，用来完成对象的初始化。

**【手把手教学】给 `Student` 类添加构造方法**

回到 `Student.java` 文件，在属性和普通方法之间添加构造方法：

```java
// Student.java 文件
public class Student {
    // 属性
    String name;
    int age;
    double score;

    // --- 1. 无参数的构造方法 (No-Arg Constructor) ---
    // 如果你不写任何构造方法，Java会默认送你一个看不见的、空的无参构造方法。
    // 但一旦你写了任何一个构造方法，Java就不再送了。
    public Student() {
        System.out.println("一个无名学生被创建了...(无参构造方法被调用)");
    }

    // --- 2. 带参数的构造方法 (Parameterized Constructor) ---
    // 这是我们最常用的！
    public Student(String name, int age, double score) {
        System.out.println("一个有名有姓的学生被创建了...(带参构造方法被调用)");
        // "this.name" 指的是这个对象自己的 name 属性
        // "=" 右边的 "name" 指的是传递进来的参数 name
        // this 的作用就是区分同名的成员变量和局部变量
        this.name = name;
        this.age = age;
        this.score = score;
    }

    // 行为 (方法)
    public void study() { ... }
    public void sayHello() { ... }
}
```

现在，我们回到 `School.java`，用新的方式创建对象：

```java
// School.java 文件
public class School {
    public static void main(String[] args) {
        // 调用无参构造方法
        Student stu1 = new Student(); 
        stu1.name = "后来者";

        System.out.println("\n--------------------------\n");

        // 直接调用带参构造方法，一步到位完成创建和赋值！
        Student stu2 = new Student("李四", 19, 98.0);
        
        // 不需要再手动赋值了，直接使用
        stu2.sayHello();
    }
}
```

*   运行 `School.java`，观察控制台的输出，你会清楚地看到构造方法是何时被调用的。

#### **6.5 本章小结与作业**

*   **小结：** 这是思维转变的一章！我们理解了**类是蓝图，对象是实例**。学会了如何定义一个**类**（包含**属性**和**方法**），如何通过 `new` **实例化对象**，如何使用 `对象.属性` 和 `对象.方法`。最后，我们掌握了使用**构造方法**在创建对象时快速初始化的强大技巧，并理解了 `this` 关键字的用途。

*   **作业（OOP实战！）：**

    1.  **定义一个 `Dog` 类：**
        *   创建一个 `Dog.java` 文件。
        *   为 `Dog` 类添加属性：`String name` (名字), `String breed` (品种), `int age` (年龄)。
        *   为 `Dog` 类添加行为（方法）：
            *   `public void bark()`: 打印出 "汪汪汪！"。
            *   `public void showInfo()`: 打印出狗的完整信息，例如 "我叫旺财，是一只中华田园犬，今年3岁了。"
        *   为 `Dog` 类提供一个**带所有参数的构造方法**。
        *   创建一个 `PetShop.java` 文件，在它的 `main` 方法中，`new` 出两只不同品种和名字的狗，并分别调用它们的 `showInfo()` 和 `bark()` 方法。

    2.  **定义一个 `Phone` 类：**
        *   创建一个 `Phone.java` 文件。
        *   属性：`String brand` (品牌), `double price` (价格), `int batteryLevel` (电量, 0-100)。
        *   构造方法：提供一个带所有参数的构造方法。
        *   行为（方法）：
            *   `public void call(String personName)`: 模拟打电话。如果电量 `batteryLevel` 大于 10，就打印 "正在给 [personName] 打电话..."，并让电量减 5。如果电量不足10，就打印 "电量不足，无法拨打电话！"。
            *   `public void charge()`: 模拟充电。直接将 `batteryLevel` 设置为 100，并打印 "充电完成，电量已满！"。
            *   `public void showStatus()`: 打印手机当前的状态，包括品牌、价格和剩余电量。
        *   创建一个 `PhoneStore.java`，在 `main` 方法中，创建一个手机对象，多次调用 `call` 方法直到电量不足，然后调用 `charge` 方法，最后再调用 `showStatus` 查看状态。

    3.  **重构你的旧代码（选做，但强烈推荐！）：**
        *   还记得第2章的**超市购物小票**作业吗？现在用面向对象的思想来重构它。
        *   创建一个 `Product.java` 类，它有属性 `String name`, `double price`。
        *   在你的主程序中（比如 `Supermarket.java`），创建多个 `Product` 对象来代表T恤、球鞋等。
        *   把这些对象存入一个 `Product` 类型的**数组**中 `Product[] cart = new Product[3];`。
        *   遍历这个数组，计算总价。这会让你深刻体会到OOP如何让处理复杂数据变得井井有条。



---

### 

### **第7章：面向对象三大支柱 (封装、继承、多态)**

这三大支柱是OOP的灵魂，它们共同协作，使得我们能构建出灵活、可维护、可扩展的复杂软件系统。

### **7.1 支柱一：封装 (Encapsulation) - 保护你的数据**

* **核心思想：** 隐藏对象内部的复杂实现细节，只对外暴露有限的、可控的访问方式。就像一台自动售货机，你不需要知道它内部的制冷、投币、出货的复杂逻辑，你只需要通过投币口（公共接口）和按钮（公共接口）来操作它。

* **为什么要封装？**

  *   **安全性：** 防止外部代码随意修改对象的内部状态，导致数据混乱。
  *   **易用性：** 使用者无需关心内部实现，只需调用提供的公共方法即可。

* **【手把手教学】如何实现封装**

  实现封装只需要两步：

  1.  将类的属性（成员变量）用 `private` 关键字修饰，使其变为私有。
  2.  提供 `public` 的 **Getter** 和 **Setter** 方法作为“公共通道”，来读取和设置这些私有属性。

  **让我们改造上一章的 `Student` 类：**

  1.  打开 `Student.java` 文件。
  2.  将所有属性改为 `private`。

  ```java
  // Student.java
  public class Student {
      private String name;
      private int age;
      private double score;
      
      // ... 构造方法和普通方法 ...
  }
  ```

  3.  现在，回到 `School.java`，你会发现之前的 `stu1.name = "张三";` 这样的代码立刻**报错了**！因为 `name` 是私有的，在 `Student` 类外部无法直接访问。这就是封装的保护作用。

  4.  **解决办法：** 在 `Student.java` 中添加 Getter 和 Setter。

      *   **Getter:** 用于获取属性值，方法名通常是 `get属性名()` (对于boolean类型是`is属性名()`)。
      *   **Setter:** 用于设置属性值，方法名通常是 `set属性名()`。

  ```java
  // Student.java
  public class Student {
      private String name;
      private int age;
      private double score;
  
      // ... 构造方法 ...
  
      // --- 为 name 属性提供 getter 和 setter ---
      public String getName() {
          return this.name;
      }
      public void setName(String name) {
          this.name = name;
      }
  
      // --- 为 age 属性提供 getter 和 setter ---
      public int getAge() {
          return this.age;
      }
      
      // ✨封装的威力✨：我们可以在 setter 中加入逻辑控制！
      public void setAge(int age) {
          if (age > 0 && age < 120) { // 只允许设置合理的年龄
              this.age = age;
          } else {
              System.out.println("错误：年龄值不合法！");
          }
      }
  
      // --- 为 score 属性提供 getter 和 setter ---
      public double getScore() {
          return this.score;
      }
      public void setScore(double score) {
          if (score >= 0 && score <= 100) {
              this.score = score;
          } else {
              System.out.println("错误：分数必须在0-100之间！");
          }
      }
      
      // ... study() 和 sayHello() 方法 ...
      // sayHello() 内部因为还在 Student 类里，所以可以直接用 name, age
  }
  ```

  **💡IDEA快捷键：** 在类中按 `Alt + Insert` (Windows/Linux) 或 `Cmd + N` (Mac)，选择 "Getter and Setter"，可以一键生成所有属性的get/set方法！

  5. **现在，在 `School.java` 中这样使用：**

     ```java
     // School.java
     public static void main(String[] args) {
         Student stu1 = new Student();
         // stu1.name = "张三"; // 错误！不能直接访问
         
         stu1.setName("张三"); // 通过公共的 setter 方法设置值
         stu1.setAge(-30);    // 尝试设置一个非法年龄
         stu1.setScore(95.5);
     
         String name = stu1.getName(); // 通过 getter 方法获取值
         System.out.println("学生的名字是: " + name);
         stu1.sayHello(); // sayHello 内部会拿到正确的 name 和不合法的 age(初始值0)
     }
     ```

     运行 `School.java`，你会看到控制台打印出“年龄值不合法”，而学生对象的年龄不会被改成-30。这就是封装带来的**数据安全性**。

### **7.2 支柱二：继承 (Inheritance) - 传承与扩展**

* **核心思想：** 允许一个类（**子类/派生类**）获取另一个类（**父类/基类/超类**）的属性和方法。这是一种“is-a”（是一个）的关系，极大地促进了**代码复用**。

* **【生活中的例子】**

  *   “学生”**是一个**“人”。
  *   “老师”**是一个**“人”。
  *   “人”是父类，拥有共性：姓名、年龄、吃饭()、睡觉()。
  *   “学生”和“老师”是子类，它们**继承**了“人”的所有共性，并且可以有自己的特性（学生有`学号`，老师有`职工号`）和行为（学生有`学习()`，老师有`教书()`）。

* **【手把手教学】实现继承**

  我们使用 `extends` 关键字来实现继承。

  1. **创建父类 `Person.java`**

     ```java
     // Person.java
     public class Person {
         private String name;
         private int age;
     
         // 父类的构造方法
         public Person(String name, int age) {
             this.name = name;
             this.age = age;
         }
         
         public void eat() {
             System.out.println(this.name + " 正在吃饭。");
         }
     
         // 提供 get/set 方法
         public String getName() { return name; }
         public void setName(String name) { this.name = name; }
         public int getAge() { return age; }
         public void setAge(int age) { this.age = age; }
     }
     ```

  2. **改造 `Student.java`，让它继承 `Person`**

     ```java
     // Student.java
     public class Student extends Person { // 使用 extends 关键字
         // 不再需要定义 name 和 age，因为已经从 Person 继承了！
         private double score;
     
         // 子类的构造方法
         public Student(String name, int age, double score) {
             // 必须在第一行调用父类的构造方法来初始化继承来的属性！
             // super() 就是调用父类构造方法的意思。
             super(name, age); 
             this.score = score;
         }
     
         // 学生特有的行为
         public void study() {
             // 可以通过 getName() 来获取继承来的 name 属性
             System.out.println(getName() + " 正在努力学习Java！");
         }
         
         // ... score 的 get/set 方法 ...
     }
     ```

  3. **创建一个 `Teacher.java` 也继承 `Person`**

     ```java
     // Teacher.java
     public class Teacher extends Person {
         private String subject; // 老师特有的属性：科目
     
         public Teacher(String name, int age, String subject) {
             super(name, age); // 同样调用父类构造
             this.subject = subject;
         }
     
         public void teach() { // 老师特有的行为
             System.out.println(getName() + " 老师正在教 " + this.subject);
         }
         // ... subject 的 get/set 方法 ...
     }
     ```

  4. **在 `School.java` 中使用它们：**

     ```java
     public class School {
         public static void main(String[] args) {
             Student stu = new Student("小明", 15, 99.0);
             Teacher tea = new Teacher("王老师", 35, "数学");
     
             stu.eat();  // 调用从 Person 继承来的 eat() 方法
             stu.study(); // 调用自己特有的 study() 方法
     
             tea.eat();   // 调用从 Person 继承来的 eat() 方法
             tea.teach(); // 调用自己特有的 teach() 方法
         }
     }
     ```

     继承让我们的代码结构更清晰，复用性更高！

### **7.3 支柱三：多态 (Polymorphism) - 同一行为，多种形态**

* **核心思想：** 同一个接口，使用不同的实例而执行不同操作。简单来说，就是**父类的引用可以指向子类的对象**，在调用同一个方法时，会表现出不同子类的行为。

* **实现多态的三个条件：**

  1.  有继承关系。
  2.  子类重写（Override）父类的方法。
  3.  父类引用指向子类对象。

* **【手把手教学】体验多态**

  1. **方法重写 (Method Overriding):**

     *   在子类中，创建一个和父类**一模一样**（方法名、参数列表、返回值类型都相同）的方法，来覆盖掉父类的实现。
     *   我们来重写 `Person` 类中的 `eat` 方法，但是好像每个人吃饭都一样，我们来加一个 `work` 方法。

     在 `Person.java` 添加 `work` 方法:

     ```java
     // Person.java
     public void work() {
         System.out.println("人都要工作...");
     }
     ```

     在 `Student.java` 中**重写** `work` 方法 (使用 `@Override` 注解是一个好习惯，它会帮我们检查是否真的构成了重写):

     ```java
     // Student.java
     @Override
     public void work() {
         System.out.println("学生的工作就是学习！");
     }
     ```

     在 `Teacher.java` 中**重写** `work` 方法:

     ```java
     // Teacher.java
     @Override
     public void work() {
         System.out.println("老师的工作就是教书！");
     }
     ```

  2. **体验多态的魔力！**
     在 `School.java` 的 `main` 方法中：

     ```java
     public static void main(String[] args) {
         // 父类引用 p1 指向 子类 Student 的对象
         Person p1 = new Student("小明", 15, 99.0);
     
         // 父类引用 p2 指向 子类 Teacher 的对象
         Person p2 = new Teacher("王老师", 35, "数学");
     
         // 调用同一个 work() 方法
         p1.work(); // 输出: 学生的工作就是学习！
         p2.work(); // 输出: 老师的工作就是教书！
     
         // 这就是多态：同样是调用 Person 类型的 work() 方法，
         // 因为引用的对象不同（一个是Student，一个是Teacher），
         // 最终执行的行为也不同。
     }
     ```

     **多态最大的好处是**：让程序具有极强的**可扩展性**。如果未来我们新增一个`Worker`类也继承`Person`，我们只需要让它重写`work`方法，而调用方的代码（比如`p.work()`）完全不需要修改！

     

### **7.4 本章小结与作业**

* **小结：** 我们深入学习了OOP的三大支柱。**封装** (`private` + get/set) 保护了数据安全；**继承** (`extends`) 实现了代码复用和“is-a”关系；**多态** (父类引用指向子类对象 + 方法重写) 实现了程序的灵活性和可扩展性。

* **作业（综合大挑战！）：**

  **项目：设计一个简单的“图形”计算器**

  1. **创建父类 `Shape.java` (形状):**

     *   使用**封装**，定义一个 `private String name` 属性（如"圆形", "矩形"）。
     *   提供构造方法和 `getName()` 方法。
     *   定义两个 `public` 方法：
         *   `public double calculateArea()` (计算面积)，方法体里直接 `return 0.0;` 并打印一句 "形状面积无法确定"。
         *   `public double calculatePerimeter()` (计算周长)，方法体里也 `return 0.0;`。

  2. **创建子类 `Circle.java` (圆形):**

     *   **继承** `Shape` 类。
     *   添加私有属性 `private double radius` (半径)。
     *   创建构造方法，记得用 `super()` 调用父类构造方法来设置 `name` 为 "圆形"。
     *   **重写** (`@Override`) 父类的 `calculateArea()` 和 `calculatePerimeter()` 方法，根据圆形的公式（面积：π * r²，周长：2 * π * r）返回正确的结果。 (π 可以用 `Math.PI` 获取)。

  3. **创建子类 `Rectangle.java` (矩形):**

     *   **继承** `Shape` 类。
     *   添加私有属性 `private double width` 和 `private double height`。
     *   创建构造方法，用 `super()` 设置 `name` 为 "矩形"。
     *   **重写** (`@Override`) 父类的 `calculateArea()` 和 `calculatePerimeter()` 方法，根据矩形的公式返回正确结果。

  4. **创建测试类 `ShapeCalculator.java`:**

     * 在 `main` 方法中，利用**多态**，创建一个 `Shape` 类型的数组，里面存放一个 `Circle` 对象和一个 `Rectangle` 对象。

       ```java
       Shape[] shapes = new Shape[2];
       shapes[0] = new Circle(5.0); // 半径为5的圆
       shapes[1] = new Rectangle(4.0, 6.0); // 宽4高6的矩形
       ```

     * 使用 `for` 循环遍历这个 `shapes` 数组。

     * 在循环中，对每一个 `shape` 对象，调用它的 `calculateArea()` 和 `calculatePerimeter()` 方法，并打印出结果。你会看到，同样是 `shape.calculateArea()`，它会对圆形和矩形调用各自正确的计算方法。

这个作业完美地融合了封装、继承和多态。完成它，你对面向对象的理解将达到一个全新的境界！

当你准备好后，我们将进入**第二阶段的最后一章**，学习更多面向对象的深入知识，为你的Java内功再添一甲子！


这一章将为你揭开Java面向对象设计的最后几层面纱。

---


### **第8章：深入面向对象 (抽象类、接口、关键字)**

#### **8.1 抽象类 (Abstract Class) - 不完整的蓝图**

在上一章，我们创建了`Person`类，它是一个可以被实例化的具体类 (`new Person(...)`)。但有时，一个父类本身是如此抽象，以至于**它自己不应该被实例化**。它的存在，就是为了给子类提供一个统一的模板。

* **核心思想：** 抽象类是一个“半成品”蓝图。它规定了子类**必须**拥有某些行为，但它自己不去实现这些行为的具体细节。

* **【生活中的例子】**

  *   `动物 (Animal)` 就是一个抽象的概念。你没法在现实中找到一个叫“动物”的东西，你能找到的是具体的“狗”、“猫”、“鸟”。
  *   `动物` 这个抽象类可以规定：所有动物都必须会 `发出叫声()`，但它不知道具体怎么叫。`狗` 继承后，就必须实现 `发出叫声()` 为 "汪汪"；`猫` 继承后，就实现为 "喵喵"。

* **【手把手教学】使用抽象类**

  1.  **定义抽象类和抽象方法：** 使用 `abstract` 关键字。
      *   **抽象类:** `public abstract class Animal { ... }`
      *   **抽象方法:** 只有方法签名，没有方法体 `{}`。`public abstract void makeSound();`

  ```java
  // Animal.java
  public abstract class Animal {
      private String name;
  
      public Animal(String name) {
          this.name = name;
      }
  
      // 这是一个抽象方法，强制所有子类必须实现（重写）它
      public abstract void makeSound();
  
      // 抽象类也可以有具体的方法
      public void sleep() {
          System.out.println(this.name + " 正在睡觉 Zzz...");
      }
      
      public String getName() { return name; }
  }
  ```

  2.  **子类继承抽象类：**
      *   子类**必须**重写（实现）父类中所有的抽象方法。否则，子类也必须被声明为抽象类。

  ```java
  // Dog.java
  public class Dog extends Animal {
      public Dog(String name) {
          super(name);
      }
  
      // 必须实现父类的 makeSound 抽象方法
      @Override
      public void makeSound() {
          System.out.println(getName() + " 发出声音: 汪汪汪!");
      }
  }
  
  // Cat.java
  public class Cat extends Animal {
      public Cat(String name) {
          super(name);
      }
  
      @Override
      public void makeSound() {
          System.out.println(getName() + " 发出声音: 喵喵喵~");
      }
  }
  ```

  3.  **使用：**
      *   抽象类**不能**被 `new` 实例化！
      *   但它可以作为引用类型，这就是多态的应用场景。

  ```java
  // Zoo.java
  public class Zoo {
      public static void main(String[] args) {
          // Animal animal = new Animal("某种动物"); // 错误！抽象类不能被实例化
  
          Animal myDog = new Dog("旺财");
          Animal myCat = new Cat("咪咪");
  
          myDog.makeSound(); // 调用 Dog 类重写后的方法
          myDog.sleep();     // 调用从 Animal 继承来的具体方法
  
          myCat.makeSound(); // 调用 Cat 类重写后的方法
          myCat.sleep();
      }
  }
  ```

#### **8.2 接口 (Interface) - 行为的“契约”**

如果说抽象类是“不完整的蓝图”，那么接口就是**100%纯粹的“行为规范”**。它只关心一个对象**能做什么** (`can-do`)，不关心它**是什么** (`is-a`)。

* **核心思想：** 接口定义了一组行为（方法）的“契约”。任何类只要愿意遵守这个契约（实现这个接口），就必须完成契约里规定的所有行为。

* **【生活中的例子】**

  *   `USB` 接口是一个标准。它规定了插口的物理形状、数据传输协议。任何设备（U盘、鼠标、键盘）只要实现了这个`USB`接口标准，就能被电脑识别和使用。电脑不关心你插进来的是什么设备，只关心它符不符合USB规范。

* **Java中，一个类只能继承一个父类，但可以实现多个接口！** 这解决了“单继承”的局限性。

* **【手把手教学】使用接口**

  1.  **定义接口：** 使用 `interface` 关键字。
      *   接口中的方法默认都是 `public abstract` 的（所以这两个关键字可以省略）。
      *   接口中的变量默认都是 `public static final` 的（常量）。

  ```java
  // Flyable.java (可飞行的)
  public interface Flyable {
      // public static final 可以省略
      int MAX_FLY_SPEED = 1000; 
  
      // public abstract 可以省略
      void fly();
  }
  ```

  2.  **类实现接口：** 使用 `implements` 关键字。

  ```java
  // Bird.java
  // 鸟既是动物，又能飞行
  public class Bird extends Animal implements Flyable {
      public Bird(String name) {
          super(name);
      }
  
      @Override
      public void makeSound() {
          System.out.println(getName() + " 发出声音: 叽叽喳喳!");
      }
  
      // 必须实现 Flyable 接口中的 fly 方法
      @Override
      public void fly() {
          System.out.println("小鸟 " + getName() + " 正在扇动翅膀飞翔。");
      }
  }
  
  // Plane.java
  // 飞机不是动物，但它也能飞行
  public class Plane implements Flyable {
      @Override
      public void fly() {
          System.out.println("波音747正在高空巡航，速度 " + MAX_FLY_SPEED);
      }
  }
  ```

  3. **使用：**

     ```java
     // TestFlyable.java
     public class TestFlyable {
         public static void main(String[] args) {
             Flyable f1 = new Bird("鹦鹉");
             Flyable f2 = new Plane();
     
             f1.fly();
             f2.fly();
             
             // 让一个能飞的东西飞起来
             takeOff(new Bird("麻雀"));
             takeOff(new Plane());
         }
         
         // 我们可以写一个只接受"能飞的"东西的方法
         public static void takeOff(Flyable f) {
             System.out.println("准备起飞...");
             f.fly();
             System.out.println("起飞成功!");
         }
     }
     ```

#### **8.3 抽象类 vs. 接口 (经典面试题)**

| 特性          | 抽象类 (Abstract Class)                  | 接口 (Interface)                     |
| :------------ | :--------------------------------------- | :----------------------------------- |
| **关系**      | **is-a** (是一个)，强调本质              | **can-do** (能做)，强调能力          |
| **继承/实现** | `extends`，**单继承**                    | `implements`，**可实现多个**         |
| **成员变量**  | 可以有各种类型的成员变量                 | 只能有 `public static final` 常量    |
| **构造方法**  | **有** (用于子类调用`super()`)           | **没有**                             |
| **方法**      | 可包含**抽象方法**和**具体方法**         | (Java 8前)只能有**抽象方法**         |
| **设计目的**  | 在相关类中共享代码，强制子类实现某些方法 | 定义不同类之间可以共同遵循的行为规范 |

**选择原则：** 优先考虑使用接口。如果你想在多个相关的子类中复用代码，或者需要定义非`final`的变量，再考虑使用抽象类。

#### **8.4 两个重要的关键字：`final` 和 `static`**

**`final` (最终的，不可改变的)**

1. **修饰变量：** 变量变成**常量**，只能赋值一次。

   ```java
   final double PI = 3.14159;
   // PI = 3.14; // 错误！常量不能被再次赋值
   ```

2. **修饰方法：** 方法**不能被子类重写**。

   ```java
   public class Parent {
       public final void secretRecipe() { ... }
   }
   public class Child extends Parent {
       // @Override public void secretRecipe() { ... } // 错误！
   }
   ```

3. **修饰类：** 类**不能被继承**。比如Java官方的 `String` 类就是 `final` 的。

   ```java
   public final class MySecureClass { ... }
   // public class HackerClass extends MySecureClass { ... } // 错误！
   ```

**`static` (静态的，属于类的)**

我们一直在用`public static void main`，现在是时候揭开 `static` 的面纱了。

*   **核心思想：** 被`static`修饰的成员（变量或方法）**不属于任何一个对象，而是属于整个类本身**。它在内存中只有一份，被所有该类的对象共享。

1. **`static` 变量 (类变量):**

   *   **例子：** 统计创建了多少个 `Student` 对象。

   ```java
   // Student.java
   public class Student {
       private String name;
       public static int studentCount = 0; // 静态变量，属于Student类
   
       public Student(String name) {
           this.name = name;
           studentCount++; // 每创建一个学生，计数器加1
       }
   }
   // 在其他地方使用
   System.out.println("创建学生前，总数: " + Student.studentCount); // 直接用类名调用
   Student s1 = new Student("A");
   Student s2 = new Student("B");
   System.out.println("创建学生后，总数: " + Student.studentCount); // 输出2
   ```

2. **`static` 方法 (类方法):**

   *   可以直接通过 `类名.方法名()` 调用，无需创建对象。例如 `Math.random()`。
   *   **限制：** 静态方法内部**不能**使用 `this` 关键字，也**不能**直接访问非静态的成员（因为非静态成员属于某个对象，而静态方法不依赖于任何对象）。

   ```java
   // Calculator.java
   public class Calculator {
       // 这是一个工具类，所有方法都是静态的，无需创建对象
       public static int add(int a, int b) {
           return a + b;
       }
   }
   // 使用
   int sum = Calculator.add(5, 3); // 直接调用
   ```

#### **8.5 本章小结与作业**

* **小结：** 我们学习了`abstract`类用于定义模板，`interface`用于定义行为契约，并对比了它们的区别。还深入理解了`final`关键字带来的不可变性，以及`static`关键字定义的属于类本身的成员。至此，Java面向对象的核心内功你已全部掌握！

* **作业（终极OOP设计！）：**

  **项目：设计一个公司员工管理系统**

  1. **创建 `Employee` 抽象类:**

     *   属性: `private String id`, `private String name`。
     *   `static` 属性: `private static int counter = 0;` (用于自动生成ID)。
     *   构造方法: 接收一个 `name`，在构造方法中，根据 `counter` 自动生成ID（如 "EMP-1", "EMP-2"），并让 `counter` 自增。
     *   具体方法: `public void showInfo()`，打印员工ID和姓名。
     *   **抽象方法**: `public abstract void work();`

  2. **创建 `Developer` 类和 `Manager` 类:**

     *   都**继承** `Employee` 类。
     *   `Manager` 类额外有一个属性 `private double bonus` (奖金)。
     *   分别为它们提供构造方法 (记得调用 `super()`)。
     *   **重写** `work()` 方法：`Developer` 打印 "正在写代码，解决BUG"；`Manager` 打印 "正在开会，分配任务"。
     *   **重写** `showInfo()` 方法：`Manager` 在打印基础信息后，还要额外打印奖金信息。

  3. **创建 `Drivable` 接口:**

     *   只包含一个方法 `public void drive();`

  4. **让 `Manager` 类也实现 `Drivable` 接口:**

     *   实现 `drive()` 方法，打印 "[经理姓名] 正在开着车去谈业务"。

  5. **创建 `Company` 测试类:**

     * 在 `main` 方法中，创建一个 `Employee` 类型的数组，里面存放 `new` 出来的 `Developer` 和 `Manager` 对象。

     * 遍历这个数组，对每个员工调用 `showInfo()` 和 `work()` 方法，观察多态的效果。

     * 再次遍历数组，使用 `instanceof` 关键字判断某个员工**是不是**一个 `Drivable` 的实例。如果是，就将它**强制类型转换**为 `Drivable`，然后调用它的 `drive()` 方法。

       ```java
       // 示例
       if (employee instanceof Drivable) {
           Drivable d = (Drivable) employee;
           d.drive();
       }
       ```

这个作业几乎囊括了第二阶段的所有知识点。完成它，意味着你已经具备了良好的面向对象设计能力。

你已经完成了Java学习中最艰难、但也是最重要的一个阶段。从下一章开始，我们将进入**第三阶段：Java进阶与常用API**，学习使用Java为我们提供的强大“工具箱”，让你的程序能处理更真实的业务！



如果说前两个阶段是“练内功”，那么**第三阶段就是学习使用各种“神兵利器”**。Java不仅仅是一门语言，它更是一个拥有海量预置工具的强大生态系统。这些工具就是**API (Application Programming Interface, 应用程序编程接口)**。学会使用它们，你的编程能力将发生质的飞跃，能轻松处理字符串、日期、文件等真实世界的问题。

<div style="display: flex; justify-content: space-around;">
  <span>
    <a href="./1.Java从零到精通-第一阶段.md">
      ← 上一篇：第一阶段
    </a>
  </span>
  <span>
    <a href="./3.Java从零到精通-第三阶段.md">
      下一篇：第三阶段 →
    </a>
  </span>
</div>