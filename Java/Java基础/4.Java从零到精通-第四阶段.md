### **第四阶段：Java生态与实战 (The Ecosystem & Real World)**

<div style="display: flex; justify-content: space-around;">
  <span>
    <a href="./3.Java从零到精通-第三阶段.md">
      ← 上一篇：第三阶段
    </a>
  </span>
 </div>



### **第17章：数据库连接 (JDBC)**

#### **17.1 什么是JDBC？**

想象一下，世界上有各种各样的数据库：MySQL, PostgreSQL, Oracle, SQL Server... 它们的底层实现和通信协议各不相同。如果Java为每一种数据库都提供一套独立的API，那程序员就得为每一种数据库都学习一套全新的代码，这太可怕了。

为了解决这个问题，Sun公司（Java的创造者）定义了一套**标准**，这套标准就是 **JDBC (Java Database Connectivity)**。

*   **JDBC是一套Java API规范**，它定义了Java程序应该如何与**任何**数据库进行交互。它只是一套**接口（规范）**，不包含具体的实现。
*   **数据库驱动 (Driver):** 各个数据库厂商（如MySQL、Oracle）则根据这套JDBC规范，提供了自己数据库的**具体实现**，这个实现就是一个JAR包，我们称之为**数据库驱动**。

**比喻：**

*   **JDBC API:** 就像USB接口标准。它规定了插头的形状、针脚的功能。
*   **数据库驱动:** 就像各个厂商生产的U盘、鼠标。它们都遵循USB标准，所以都能插到你的电脑上使用。
*   **你的Java程序:** 就像你的电脑。你只需要按照USB标准去写代码，就能操作任何符合标准的设备，而不需要关心这个U盘内部的芯片是怎么工作的。

**JDBC工作流程：** 你的Java程序 -> 调用JDBC标准接口 -> JDBC驱动 -> 对应的数据库。

#### **17.2 【手把手教学】前的准备工作**

要进行JDBC编程，你需要：

1.  **一个数据库:** 我们选择最流行、免费开源的 **MySQL**。
2.  **一个数据库管理工具:** 我们选择 **DBeaver** 或 **Navicat**，它们是图形化界面，方便我们查看数据和执行SQL。
3.  **MySQL的JDBC驱动:** 一个JAR包。

**步骤一：安装MySQL**

*   这是一个相对独立的过程，你可以搜索“MySQL 8.0 安装教程”来完成。在安装过程中，请务必**记下你设置的`root`用户密码**。
*   对于初学者，也可以使用**Docker**来快速启动一个MySQL容器，这能避免很多环境配置问题。

**步骤二：安装DBeaver**

*   访问 [DBeaver官网](https://dbeaver.io/download/)，下载并安装社区版（免费）。
*   安装后，新建一个到你本地MySQL的连接，输入用户名`root`和你设置的密码，测试连接成功即可。

**步骤三：在数据库中创建表**

* 在DBeaver中，连接上你的MySQL，执行以下SQL语句来创建一个数据库和一张用户表，并插入几条测试数据。

  ```sql
  -- 创建一个名为 'learning' 的数据库
  CREATE DATABASE IF NOT EXISTS learning;
  
  -- 切换到 'learning' 数据库
  USE learning;
  
  -- 创建一张名为 'users' 的表
  CREATE TABLE users (
      id INT PRIMARY KEY AUTO_INCREMENT,
      username VARCHAR(50) NOT NULL,
      email VARCHAR(100) UNIQUE,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  );
  
  -- 插入一些测试数据
  INSERT INTO users (username, email) VALUES
  ('Alice', 'alice@example.com'),
  ('Bob', 'bob@example.com'),
  ('Charlie', 'charlie@example.com');
  ```

#### **17.3 【手把手教学】JDBC核心编程六步走**

现在，我们回到 `my-maven-app` 项目，用代码来操作刚才创建的`users`表。

**第一步：在`pom.xml`中添加MySQL驱动依赖**

1. 访问 [MVNRepository.com](https://mvnrepository.com/)，搜索 `mysql-connector-java`。

2. 选择一个较新的版本（如`8.0.x`），复制其Maven依赖信息。

3. 将依赖添加到`pom.xml`的`<dependencies>`区域，并加载Maven变更。

   ```xml
   <dependency>
       <groupId>mysql</groupId>
       <artifactId>mysql-connector-java</artifactId>
       <version>8.0.33</version> <!-- 版本可能不同 -->
   </dependency>
   ```

**第二步：编写JDBC代码**

我们将整个流程封装在一个`JdbcPractice.java`类中。JDBC编程有一个非常经典的“六步模板”。

```java
package com.mylearning.app;

import java.sql.*; // 导入所有java.sql包下的类

public class JdbcPractice {

    // --- 数据库连接信息 ---
    // URL格式: jdbc:数据库类型://主机名:端口号/数据库名?参数
    private static final String URL = "jdbc:mysql://localhost:3306/learning?useSSL=false&serverTimezone=UTC";
    private static final String USER = "root";
    private static final String PASSWORD = "你的MySQL密码"; // 替换成你自己的密码

    public static void main(String[] args) {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;

        try {
            // 1. 加载驱动类 (在JDBC 4.0后，这步可以省略，但写上是个好习惯)
            // Class.forName("com.mysql.cj.jdbc.Driver");

            // 2. 获取数据库连接 (Connection)
            System.out.println("正在连接数据库...");
            conn = DriverManager.getConnection(URL, USER, PASSWORD);
            System.out.println("数据库连接成功！");

            // 3. 创建执行SQL语句的对象 (Statement)
            stmt = conn.createStatement();
            String sql = "SELECT id, username, email FROM users";

            // 4. 执行SQL语句，并接收返回的结果集 (ResultSet)
            rs = stmt.executeQuery(sql); // executeQuery用于执行SELECT查询

            // 5. 处理结果集 (ResultSet)
            System.out.println("--- 用户列表 ---");
            while (rs.next()) { // .next() 将光标移动到下一行，如果有数据则返回true
                // 通过列名或列索引(从1开始)获取数据
                int id = rs.getInt("id");
                String username = rs.getString("username");
                String email = rs.getString("email");

                System.out.printf("ID: %d, 用户名: %s, 邮箱: %s\n", id, username, email);
            }

        } catch (SQLException e) {
            System.err.println("数据库操作失败！");
            e.printStackTrace();
        } finally {
            // 6. 释放资源 (非常重要！必须在finally块中进行，且顺序与获取时相反)
            System.out.println("--- 释放资源 ---");
            try {
                if (rs != null) rs.close();
                if (stmt != null) stmt.close();
                if (conn != null) conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}
```

*   **运行代码**，如果一切配置正确，你将在控制台看到从数据库中查询出的三条用户信息。

#### **17.4 防止SQL注入：`PreparedStatement`**

上面使用的`Statement`对象有一个巨大的安全漏洞：**SQL注入**。如果SQL语句是拼接用户输入构成的，恶意用户可能输入SQL片段来破坏你的查询。

**`PreparedStatement`** 是`Statement`的子接口，它通过**预编译**和**参数占位符**的方式，从根本上杜绝了SQL注入。**在实际开发中，必须总是使用`PreparedStatement`！**

**【手把手教学】使用 `PreparedStatement` 进行增、删、改、查**

我们来写一个更完整的 `UserDao` (Data Access Object，数据访问对象) 类，这是企业开发中的常见模式。

```java
// UserDao.java
public class UserDao {
    // ... 连接信息常量 ...

    // --- 查询单个用户 ---
    public void findUserById(int userId) {
        // 使用 try-with-resources 自动关闭资源
        try (Connection conn = DriverManager.getConnection(URL, USER, PASSWORD)) {
            // 使用 ?作为参数占位符
            String sql = "SELECT * FROM users WHERE id = ?";
            
            // 创建 PreparedStatement 对象
            try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
                // 设置参数：第一个问号，值为userId
                pstmt.setInt(1, userId);
                
                // 执行查询
                try (ResultSet rs = pstmt.executeQuery()) {
                    if (rs.next()) {
                        System.out.printf("找到用户: ID: %d, 用户名: %s\n", rs.getInt("id"), rs.getString("username"));
                    } else {
                        System.out.println("未找到ID为 " + userId + " 的用户。");
                    }
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    // --- 插入新用户 ---
    public void addUser(String username, String email) {
        try (Connection conn = DriverManager.getConnection(URL, USER, PASSWORD);
             PreparedStatement pstmt = conn.prepareStatement("INSERT INTO users (username, email) VALUES (?, ?)")) {
            
            pstmt.setString(1, username);
            pstmt.setString(2, email);
            
            // .executeUpdate() 用于执行增、删、改操作，返回受影响的行数
            int rowsAffected = pstmt.executeUpdate();
            
            if (rowsAffected > 0) {
                System.out.println("用户 " + username + " 添加成功！");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    
    // 在 main 方法中测试
    public static void main(String[] args) {
        UserDao dao = new UserDao();
        dao.addUser("David", "david@example.com");
        dao.findUserById(4); // 查找刚刚添加的用户
    }
}
```

*   `PreparedStatement` 不仅更安全，而且由于预编译机制，在多次执行相同结构的SQL时，性能也更好。

#### **17.5 本章小结与作业**

*   **小结：** 我们理解了**JDBC**作为Java数据库连接的**标准规范**，以及**数据库驱动**作为具体实现的作用。我们亲手搭建了MySQL环境，并在Java项目中通过Maven引入了驱动。最重要的是，我们掌握了JDBC编程的**经典六步**，并学会了使用更安全、更高效的 **`PreparedStatement`** 来执行数据库的增删改查操作，并利用`try-with-resources`来优雅地管理资源。

*   **作业（打造你的数据访问层！）：**

    1.  **完善`UserDao`：**
        *   在今天的`UserDao.java`类中，继续添加以下两个方法：
            *   `public void updateUserEmail(int userId, String newEmail)`: 根据用户ID更新其邮箱。
            *   `public void deleteUser(int userId)`: 根据用户ID删除一个用户。
        *   在`main`方法中编写代码来测试你新添加的更新和删除功能。

    2.  **查询所有用户并封装成对象：**
        *   在`com.mylearning.app`包下，创建一个`User.java`实体类，包含`id`, `username`, `email`等属性，并提供`getter/setter`和`toString()`方法。
        *   在`UserDao`中，写一个新方法 `public List<User> findAllUsers()`。
        *   在这个方法里，执行`SELECT * FROM users`查询。
        *   遍历`ResultSet`，在`while`循环中，为每一行数据都创建一个`User`对象，将查询到的`id`, `username`, `email`设置到对象中。
        *   将每个创建好的`User`对象添加到一个`ArrayList<User>`中。
        *   最后，返回这个包含所有用户对象的列表。
        *   在`main`方法中调用此方法，并遍历打印出返回的`List<User>`，验证结果。这个练习是实际项目中最常见的操作模式。

完成这个练习，你就打通了Java程序与后端数据库之间的“任督二脉”。

原生JDBC虽然强大，但也比较繁琐。在下一阶段，我们将学习目前Java世界最流行的框架 **Spring Boot**，它将JDBC等操作简化到了极致，让你能以惊人的速度开发功能完备的Web应用。准备好，迎接真正的企业级开发！

非常好！很高兴我们达成了共识。相信我，学完这一章，你会爱上这种全新的代码风格，并惊叹于Java语言的进化。

准备好，让我们来一次编程思想的“大升级”！

---

### **第四阶段：Java生态与实战 (The Ecosystem & Real World)**

### **第18章：Java 8+ 新特性 (Lambda表达式、Stream API)**

这一章的核心，就是学习如何用一种更简洁、更优雅、更高效的方式来处理数据，特别是集合（List, Set等）中的数据。

#### **18.1 Lambda 表达式 (Lambda Expressions) - 匿名函数的艺术**

**什么是Lambda？**
简单来说，Lambda表达式就是一段可以被传递的、匿名的代码块。它允许你把一个**函数**当作一个**参数**来传递。

**我们为什么需要它？**
看一个例子：假设我们要对一个`List<String>`进行排序。在Java 8之前，我们必须这么写：

```java
List<String> names = Arrays.asList("peter", "anna", "mike");
Collections.sort(names, new Comparator<String>() {
    @Override
    public int compare(String a, String b) {
        return a.compareTo(b);
    }
});
```

看到了吗？为了实现`compare`这一个核心的比较逻辑，我们被迫写了一个完整的、匿名的内部类 (`new Comparator<String>(){...}`)，代码非常臃肿。

**使用Lambda，代码会变成这样：**

```java
List<String> names = Arrays.asList("peter", "anna", "mike");
Collections.sort(names, (String a, String b) -> a.compareTo(b));
```

是不是清爽了无数倍！`->`左边是参数列表，右边是方法体。这就是Lambda的魔力。

**Lambda语法三要素：**

1.  **`(参数列表)`:** `->`左边的部分。
2.  **`->`:** "goes to" 箭头，分隔符。
3.  **`{方法体}`:** `->`右边的部分，是具体的代码实现。

**【手把手教学】Lambda语法的各种“简写”形态**

1.  **标准形式：**
    `(String a, String b) -> { return a.compareTo(b); }`

2.  **类型推断：** 编译器能推断出参数类型，所以可以省略。
    `(a, b) -> { return a.compareTo(b); }`

3.  **方法体只有一行：** 如果方法体只有一行代码，可以省略大括号`{}`和`return`关键字。
    `(a, b) -> a.compareTo(b)`

4.  **参数只有一个：** 如果参数只有一个，可以省略小括号`()`。
    `name -> System.out.println(name)`

**Lambda的前提：函数式接口 (Functional Interface)**
Lambda表达式不是随便什么地方都能用的。它只能用于“**函数式接口**”的场景。

*   **函数式接口：** 就是**有且仅有一个抽象方法**的接口。比如`Runnable`接口（只有一个`run()`方法），`Comparator`接口（只有一个`compare()`方法）。
*   `@FunctionalInterface` 注解：可以加在接口上，如果这个接口不满足函数式接口的定义，编译器会报错。

```java
@FunctionalInterface
interface MyGreeting {
    void sayMessage(String message);
}

// 我们可以用Lambda表达式来创建这个接口的实例
MyGreeting greeting = message -> System.out.println("Hello " + message);
greeting.sayMessage("World"); // 输出 Hello World
```

#### **18.2 Stream API - 流式数据处理的革命**

Stream API是Java 8的另一大“核武器”。它让你能以一种**声明式 (Declarative)**的方式来处理数据集合，就像搭建一条**流水线**。

*   **核心思想：**
    1.  **获取流 (Get a Stream):** 从一个数据源（如List, Set, Array）获取一个Stream。
    2.  **中间操作 (Intermediate Operations):** 对流进行一系列的加工处理（过滤、映射、排序等）。这些操作是**惰性执行**的，它们会返回一个新的Stream，可以形成一个链条。
    3.  **终端操作 (Terminal Operation):** 对流进行最终的计算，得到一个结果（如一个新的List、一个值、或者什么都不返回）。终端操作会触发前面所有中间操作的执行。

**【手把手教学】用Stream API处理一个学生列表**

1. 创建一个`StreamPractice.java`类，并准备一些数据。

   ```java
   // 先定义一个简单的Student类
   class Student {
       private String name;
       private int age;
       private double score;
       // (构造方法, getter, toString... 省略)
   }
   
   public class StreamPractice {
       public static void main(String[] args) {
           List<Student> students = Arrays.asList(
               new Student("Alice", 18, 85.5),
               new Student("Bob", 20, 95.0),
               new Student("Charlie", 18, 70.0),
               new Student("David", 21, 65.5),
               new Student("Eve", 20, 88.0)
           );
           // ...
       }
   }
   ```

2. **实战需求：找出所有年龄大于等于20岁的学生，按分数降序排序，并取出他们的名字，存入一个新的List中。**

* **传统做法 (Java 7):**

  ```java
  List<Student> filteredStudents = new ArrayList<>();
  for (Student s : students) {
      if (s.getAge() >= 20) {
          filteredStudents.add(s);
      }
  }
  Collections.sort(filteredStudents, new Comparator<Student>() {
      @Override
      public int compare(Student o1, Student o2) {
          return Double.compare(o2.getScore(), o1.getScore()); // 降序
      }
  });
  List<String> studentNames = new ArrayList<>();
  for (Student s : filteredStudents) {
      studentNames.add(s.getName());
  }
  System.out.println("传统做法结果: " + studentNames);
  ```

  代码冗长，逻辑分散，还产生了中间集合`filteredStudents`。

* **Stream API做法 (Java 8):**

  ```java
  List<String> studentNames = students.stream() // 1. 获取流
      .filter(s -> s.getAge() >= 20)          // 2. 中间操作：过滤
      .sorted((s1, s2) -> Double.compare(s2.getScore(), s1.getScore())) // 3. 中间操作：排序
      .map(s -> s.getName())                  // 4. 中间操作：映射 (转换)
      .collect(Collectors.toList());          // 5. 终端操作：收集成List
  
  System.out.println("Stream API结果: " + studentNames);
  ```

  是不是像一条清晰的流水线？`[Bob, Eve]`。

**核心Stream操作详解：**

*   `stream()`: 从集合获取流。
*   `filter(Predicate<T> p)`: **过滤**。接收一个返回`boolean`的Lambda，只保留满足条件的元素。
*   `map(Function<T, R> f)`: **映射/转换**。将流中的每个元素T，通过Lambda转换成另一种元素R。比如`Student`对象流 -> `String`名字流。
*   `sorted(Comparator<T> c)`: **排序**。接收一个`Comparator`来定义排序规则。
*   `collect(Collector<T, A, R> c)`: **收集**。最常用的终端操作，将流中的元素收集到集合中，如`Collectors.toList()`, `Collectors.toSet()`。
*   `forEach(Consumer<T> c)`: **遍历**。对流中每个元素执行一个操作，无返回值。
*   `distinct()`: **去重**。
*   `limit(long n)`: **截断**，只取前n个元素。

#### **18.3 方法引用 (Method Reference)**

方法引用是Lambda表达式的一种**终极简写**形式。如果你的Lambda表达式只是在直接调用一个已经存在的方法，那么就可以使用方法引用。

| 类型                        | 示例                  | 等价的Lambda                |
| :-------------------------- | :-------------------- | :-------------------------- |
| **静态方法引用**            | `Math::abs`           | `x -> Math.abs(x)`          |
| **实例方法引用 (特定对象)** | `myPrinter::println`  | `x -> myPrinter.println(x)` |
| **实例方法引用 (任意对象)** | `String::toUpperCase` | `s -> s.toUpperCase()`      |
| **构造方法引用**            | `ArrayList::new`      | `() -> new ArrayList()`     |

**【手把手教学】用方法引用简化Stream代码**
我们之前的排序和映射代码可以进一步简化：

```java
// 使用Comparator.comparing可以更优雅地排序
import static java.util.Comparator.comparingDouble;

List<String> studentNames = students.stream()
    .filter(s -> s.getAge() >= 20)
    // .sorted((s1, s2) -> Double.compare(s2.getScore(), s1.getScore()))
    .sorted(comparingDouble(Student::getScore).reversed()) // 排序简化
    // .map(s -> s.getName())
    .map(Student::getName) // 映射简化: "对于每个Student对象s，调用它的getName方法"
    .collect(Collectors.toList());
```

#### **18.4 本章小结与作业**

*   **小结：** 我们学习了Java 8带来的革命性新特性。**Lambda表达式**让我们能用简洁的语法传递代码块；**Stream API**则提供了一套强大、声明式的“流水线”来处理集合数据，核心操作包括`filter`, `map`, `sorted`, `collect`；**方法引用**作为Lambda的语法糖，让代码更加精炼。掌握这些，你的Java代码将提升到“现代化”的水平。

*   **作业（用现代化的方式解决问题！）：**

    1.  **重构旧作业 - 单词频率统计器：**
        *   回顾第10章的作业“单词频率统计器”。
        *   当时你是用循环和`Map`来解决的。现在，请使用 **Stream API** 来重构它。
        *   **提示：**
            1.  将文本用`split(" ")`分割成一个单词数组。
            2.  使用`Arrays.stream(words)`从数组获取流。
            3.  使用`collect()`终端操作。思考一下，`Collectors`类里有没有一个收集器可以直接帮你分组并计数的？（提示：搜索`Collectors.groupingBy`和`Collectors.counting`）。

    2.  **数据处理流水线：**
        *   给定一个整数列表 `List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 2, 4);`
        *   请使用**一个**Stream流水线操作，完成以下所有要求：
            1.  筛选出所有**偶数**。
            2.  对这些偶数进行**去重**。
            3.  将每个偶数**乘以2**。
            4.  将处理后的结果收集到一个新的`List`中。
        *   最终打印出这个List，结果应该是 `[4, 8, 12, 16, 20]`。

    3.  **方法引用练习：**
        *   创建一个字符串列表 `List<String> words = Arrays.asList("apple", "Banana", "CHERRY");`
        *   使用Stream和**方法引用**，将列表中的所有单词都转换为小写，并打印出来。
        *   **提示：** 使用`forEach`和`String::toLowerCase`。

完成这些练习，你将能熟练地运用Lambda和Stream来编写优雅、高效的数据处理代码。

现在，你已经具备了所有必要的“内功”和“思想”，我们终于可以进入**第五阶段**，学习如何使用业界最顶级的框架**Spring Boot**，将你所有的知识融会贯通，快速构建出一个真正的Web应用！

<div style="display: flex; justify-content: space-around;">
  <span>
    <a href="./3.Java从零到精通-第三阶段.md">
      ← 上一篇：第三阶段
    </a>
  </span>
  <span>
    <a href="./5.Java从零到精通-第五阶段.md">
      下一篇：第五阶段 →
    </a>
  </span>
</div>