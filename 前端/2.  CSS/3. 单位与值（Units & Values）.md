### **第 3 课：单位与值（Units & Values）**

过去，我们用 `px` (像素) 来构建网页，就像用尺子在纸上画画，每一个尺寸都是固定的。这在只有一种屏幕尺寸的时代是可行的。但在今天，你的网页需要在手机、平板、笔记本、大显示器上都能完美展现，**静态的 `px` 思维已经彻底过时了**。

#### **核心思想：拥抱相对单位，构建“会呼吸”的界面**

我们的目标是创建一个**有弹性、可伸缩**的界面。当用户调整浏览器字体大小（为了更好的可访问性）或者在不同设备上查看时，你的整个布局应该能优雅地、成比例地缩放，而不是变得一团糟。

实现这一点的关键，就是从 `px` 驱动的思维，转向由 **`rem`** 驱动的思维。

---

#### **深度剖析 1：绝对单位 (`px`) —— 何时使用？**

`px` (Pixel, 像素) 是一个绝对单位。`1px` 就是屏幕上的一个小点。它的大小是固定的，不会因为任何东西而改变。

虽然我们说要放弃 `px` 驱动的思维，但它并非一无是处。在某些你**明确不希望它缩放**的场景下，`px` 仍然是最佳选择。

**`px` 的最佳适用场景：**

*   **`border` (边框):** `border: 1px solid black;` 一条细线，你通常就希望它永远是 1 像素那么细。
*   **`box-shadow` (阴影):** 阴影的偏移和模糊半径，通常也需要固定的像素值来达到精确的设计效果。

---

#### **深度剖析 2：相对单位 —— 弹性的来源**

##### **a. 百分比 (`%`)**

*   **是什么**：相对于其**父元素**的某个值。
*   **相对于谁？** 这是最关键的问题！
    *   `width`, `height`, `margin`, `padding` (水平方向) -> 相对于**父元素的 `width`**。
    *   **注意一个陷阱**：`padding-top`, `padding-bottom`, `margin-top`, `margin-bottom` 的百分比值，也是相对于**父元素的 `width`** 来计算的，而不是 `height`！这个特性是实现响应式宽高比容器的关键。
    *   `font-size` -> 相对于**父元素的 `font-size`**。
    *   `line-height` -> 相对于**元素自身的 `font-size`**。

##### **b. `em` vs `rem` —— 本课的重中之重**

这两个单位是相对单位中的核心，它们都与 `font-size` 相关。

*   **`em` (em unit)**
    *   **定义**：相对于**当前元素自身**的 `font-size`。如果当前元素没有设置 `font-size`，则会向上继承父元素的 `font-size`。
    *   **最大的问题**：**会产生“复合效应”**。在一个深度嵌套的结构中，如果你给每一层都设置 `font-size: 0.8em;`，字体大小会以 `0.8 * 0.8 * 0.8 ...` 的方式急剧缩小，变得难以预测和管理。

*   **`rem` (Root em unit)**
    *   **定义**：只相对于**根元素 (`<html>`)** 的 `font-size`。
    *   **最大的优点**：**稳定、可预测**。无论一个元素嵌套多深，`1rem` 的值永远是固定的（等于 `<html>` 的 `font-size`）。
    *   **现代 Web 设计的最佳实践**：
        1.  我们不给 `<html>` 设置一个固定的 `px` 值，而是保留浏览器默认的 `font-size: 16px;` (或者设置为 `font-size: 62.5%;` 也就是 `10px`，方便计算)。
        2.  网站所有的尺寸，包括 `width`, `height`, `margin`, `padding`, `font-size` 等，**全部使用 `rem` 作为单位**。
        3.  **结果**：当用户在浏览器设置中调整“字体大小”时，实际上是在改变根元素的 `font-size`。因为我们整个网站的尺寸都与 `rem` 挂钩，所以整个网站的所有元素都会**成比例地、和谐地放大或缩小**，实现完美的响应式和可访问性。

##### **c. `vw` 和 `vh` (Viewport Units)**

*   **是什么**：相对于**视口（Viewport，即浏览器可视窗口）**的尺寸。
    *   `1vw` = 1% 的视口宽度。
    *   `1vh` = 1% 的视口高度。
*   **适用场景**：
    *   **全屏英雄单元**：`height: 100vh;` 可以让一个元素的高度正好撑满整个屏幕。
    *   **响应式字体**：`font-size: 4vw;` 可以让标题文字的大小随着浏览器窗口的拉伸而平滑地变大变小，非常具有视觉冲击力。

---

### **面试焦点**

**面试官问：“请解释 `em` 和 `rem` 的区别，以及你在项目中会如何选择？”**

> **你的回答**：“`em` 和 `rem` 都是相对单位，但它们的参照物不同。
>
> *   `em` 相对于**当前元素自身**的 `font-size`。它的主要问题是在嵌套元素中使用时会产生复合效应，导致尺寸计算变得复杂和不可预测。
> *   `rem` 只相对于**根元素 `<html>`** 的 `font-size`。这使得 `rem` 的值在整个页面中都是稳定和一致的。
>
> **在项目中我的选择策略是**：
>
> 1.  **首选 `rem`**：我会将 `rem` 作为项目的主要单位，用于设置组件的 `width`, `margin`, `padding` 和 `font-size` 等。这能保证整个 UI 布局能够随着根字体大小的改变而等比例缩放，极大地提升了网站的可访问性和响应式能力。
> 2.  **偶尔使用 `em`**：只在一种特定情况下我会考虑使用 `em`——当我想让一个元素的某个属性（比如 `padding`）**只跟它自身的 `font-size` 相关**时。例如，一个按钮的 `padding` 可以用 `em`，这样当这个按钮的 `font-size` 变大时，它的内边距也会自动变大，保持协调，而不会影响到其他组件。”

**面试官问：“如何实现一个宽高比固定的响应式容器？（比如 16:9 的视频容器）”**

> **你的回答**：“这可以利用**百分比 `padding` 是相对于父元素宽度计算**的特性来实现，这被称为‘padding-top hack’。
>
> 步骤如下：
>
> 1.  创建一个外部容器 `div`，并设置 `position: relative;` 和 `width: 100%;`（或者任何你想要的宽度）。
> 2.  将这个外部容器的 `height` 设置为 `0`。
> 3.  计算宽高比对应的百分比。例如，16:9 的比例，就是 `(9 / 16) * 100% = 56.25%`。将这个值设置给外部容器的 `padding-top` 或 `padding-bottom`。
> 4.  创建一个内部容器（比如 `iframe` 或 `img`），设置 `position: absolute;`，`top: 0;`, `left: 0;`，以及 `width: 100%;`, `height: 100%;`。
>
> 这样，无论外部容器的宽度如何变化，它的高度都会通过 `padding-top` 自动保持 16:9 的比例，内部的元素也会被撑满这个空间。
>
> 当然，现在有了更现代的 CSS 属性 `aspect-ratio`，可以直接设置 `aspect-ratio: 16 / 9;` 来实现，代码更简洁。但在不兼容 `aspect-ratio` 的旧浏览器或需要兼容的场景下，‘padding-top hack’ 依然是一个非常稳定可靠的方案。”

---

### **实战任务**

现在，我们来亲手构建一个“会呼吸”的组件。

1.  **建立基础**：
    *   创建一个 HTML 文件，里面有一个 `div`，`class="card"`。
    *   在 CSS 文件中，给 `<html>` 设置 `font-size: 16px;` (模拟浏览器默认值)。
    *   给 `<body>` 设置一个背景色，并使用 Flexbox 让卡片水平垂直居中。

2.  **构建卡片 (全部使用 `rem`)**：
    *   给 `.card` 设置 `width: 20rem;` (20 * 16px = 320px)
    *   设置 `padding: 1.5rem;`
    *   设置 `border-radius: 0.5rem;`
    *   设置 `background-color: white;`
    *   设置 `font-size: 1rem;`
    *   在卡片里加一个 `h2` 标题和一个 `p` 段落。给 `h2` 设置 `font-size: 1.25rem;` 和 `margin-bottom: 1rem;`。

3.  **见证奇迹**：
    *   在浏览器中打开页面。
    *   打开开发者工具，选中 `<html>` 元素，**手动修改它的 `font-size`**，从 `16px` 改为 `20px`，再改为 `10px`。
    *   **请观察**：你的卡片发生了什么变化？它的宽度、内边距、圆角、字体大小是不是都**同时、成比例地**变大了/变小了？

4.  **挑战：响应式图片容器**
    *   在卡片的标题和段落之间，添加一个 `div`，`class="img-container"`。
    *   现在，请你使用我们刚刚学到的“padding-top hack”技术，让这个 `.img-container` 成为一个**永久保持 16:9 宽高比**的响应式容器。
    *   给它一个背景色，以便你能看到它的区域。

