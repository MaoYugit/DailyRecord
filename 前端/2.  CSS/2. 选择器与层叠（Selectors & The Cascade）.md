### **第 2 课：选择器与层叠（Selectors & The Cascade）**

现在，我们要进入 CSS 的灵魂——**“层叠”**。

如果你只记住一件事，请记住：**CSS 的工作就是解决冲突**。当你写了多条规则试图去改变同一个元素的同一个属性时（比如一个`<h1>`，你既想让它是红色，又想让它是蓝色），浏览器究竟听谁的？ 

“层叠”就是浏览器用来解决这些冲突的一套明确、严格的法律体系。掌握了它，你就掌握了 CSS 的核心逻辑。

#### **核心思想：浏览器决定样式时的思维过程**

想象一下，一个 HTML 元素就像一个需要造型的人。现在来了好几个造型师（你的 CSS 规则）都想给他设计发型（`font-family`）、衣服颜色（`color`）等等。浏览器作为最终的决策者，会按照以下三个步骤来决定听谁的：

1.  **第一步：比重要性（Importance）** - 谁带了“尚方宝剑” (`!important`)？
2.  **第二步：比优先级（Specificity）** - 谁的“头衔”更高？（是“皇帝”ID，还是“大臣”Class？）
3.  **第三步：比源顺序（Source Order）** - 如果头衔一样高，谁是“最后”来的？

这就是层叠的全部秘密。我们来逐一拆解。

---

#### **深度剖析 1：优先级（Specificity）—— 精确的计算法则**

这是层叠规则中最核心、最需要精确掌握的部分。我们可以用一个四位数的记分系统来量化任何一条 CSS 规则的优先级。把它想象成 `(I, A, B, C)`：

*   **I (Inline):** 行内样式。写在 HTML 元素的 `style` 属性里的样式。`style="..."` 得 1 分。
*   **A (IDs):** ID 选择器。`#header` 得 1 分。
*   **B (Classes, Attributes, Pseudo-classes):**
    *   类选择器 (`.nav-item`)
    *   属性选择器 (`[type="text"]`)
    *   伪类 (`:hover`)
    *   每匹配一个，就在 B 的位置得 1 分。
*   **C (Types, Pseudo-elements):**
    *   元素/类型选择器 (`div`, `h1`)
    *   伪元素 (`::before`, `::after`)
    *   每匹配一个，就在 C 的位置得 1 分。

**计算规则：**

1.  从 A 开始，**从左到右**比较两个选择器的得分。
2.  **高位的 1 分永远大于低位的所有分数**。也就是说，一个 A (ID) 的优先级，比一百万个 B (Class) 都要高。` (0, 1, 0, 0)` 远大于 `(0, 0, 99, 99)`。
3.  `*` 通配符和 `:where()` 伪类的优先级为 0。`!important` 是个例外，我们最后说。

**实战举例：**

*   `p { color: red; }` -> 优先级: `(0, 0, 0, 1)`
*   `p.description { color: blue; }` -> 优先级: `(0, 0, 1, 1)` (1个Class, 1个Type)
*   `p.description a { color: green; }` -> 优先级: `(0, 0, 1, 2)` (1个Class, 2个Type)
*   `#main .list li:hover { color: purple; }` -> 优先级: `(0, 1, 2, 1)` (1个ID, 2个Class/Pseudo, 1个Type)
*   `<p style="color: orange;">...</p>` -> 优先级: `(1, 0, 0, 0)`

**结论：** 以后遇到样式冲突，不要靠猜，拿出纸笔，按照 `(I, A, B, C)` 法则精确计算，谁的得分高，就听谁的。

---

#### **深度剖析 2：继承（Inheritance）**

*   **是什么？** 某些 CSS 属性（通常是与文本相关的），当父元素设置了，子元素如果没有自己明确的设置，就会自动“继承”父元素的这个属性值。
*   **哪些可以继承？**
    *   **能继承的（很合理）**：`font-family`, `font-size`, `font-weight`, `color`, `line-height`, `text-align`, `list-style`...
    *   **不能继承的（也很合理）**：`width`, `height`, `padding`, `margin`, `border`, `background`... （想象一下，如果父元素的 `border` 也被子元素继承，那页面就全是框了！）
*   **关键字的妙用：**
    *   `inherit`：强制继承。即使某个属性默认不能继承（比如 `border`），你也可以通过 `border: inherit;` 来让它强制继承父元素的值。
    *   `initial`：恢复初始值。将属性恢复到浏览器默认的初始值。比如 `color: initial;` 可能会让文字变回黑色。
    *   `unset`：智能重置。如果该属性默认是可继承的，则行为同 `inherit`；如果默认不可继承，则行为同 `initial`。

---

#### **深度剖析 3：源顺序（Source Order）**

这是最后的决胜局。如果两条规则的**优先级完全相同**，那么浏览器会看它们在你的 CSS 文件中出现的顺序。

**规则：后面出现的，会覆盖前面出现的。**

```css
/* style.css */

p { color: blue; } /* 优先级 (0,0,0,1) */
p { color: red; }  /* 优先级 (0,0,0,1) */

/* 最终 p 的颜色是 red，因为这条规则在后面 */
```

---

### **面试焦点**

**面试官问：“请解释一下 CSS 的优先级规则。”**

> **你的回答**：“CSS 决定最终应用哪个样式的过程遵循一套称为‘层叠’的规则。这个过程主要有三步：
>
> 1.  **重要性**：首先比较规则是否带有 `!important` 标记，带标记的规则胜出。
> 2.  **优先级（Specificity）**：如果不涉及 `!important`，则计算各个选择器的优先级。通常可以用一个四元组 `(行内, ID, Class, Type)` 来量化。ID 选择器的权重远高于 Class，Class 的权重远高于元素选择器。比较时从高位向低位比较，高位胜出则无需再比。
> 3.  **源顺序**：如果上面两步的优先级完全相同，则遵循‘后来者居上’的原则，即在样式表中后定义的规则会覆盖先定义的规则。
>
> 简单总结就是：**!important > 行内样式 > ID > 类/属性/伪类 > 元素/伪元素 > 继承 > 浏览器默认样式**。”

**面试官问：“`#my-id` 和 `[id='my-id']` 的优先级一样吗？为什么？”**

> **你的回答**：“不一样，`#my-id` 的优先级要高得多。因为 `#my-id` 是一个 **ID 选择器**，它的优先级得分是 `(0, 1, 0, 0)`。而 `[id='my-id']` 是一个**属性选择器**，虽然它也选中了同一个元素，但它的优先级得分是 `(0, 0, 1, 0)`。根据优先级计算规则，ID 选择器（A位）的权重远大于属性选择器（B位），所以前者的优先级更高。”

**面试官问：“`!important` 的使用场景和风险是什么？”**

> **你的回答**：“`!important` 是一个‘最终武器’，它会覆盖所有其他声明，包括行内样式。
>
> **风险**：它的最大风险是**破坏了 CSS 的自然层叠规则**，导致样式难以预测和调试。一旦在一个地方使用了 `!important`，后续如果想覆盖这个样式，就可能被迫使用另一个 `!important`，最终导致“`!important` 战争”，代码变得非常混乱和难以维护。
>
> **合理的使用场景**非常有限，通常包括：
>
> 1.  **覆盖第三方库或框架的强样式**：当你需要修改一个外部 UI 库（比如 Bootstrap）中一个具有很高优先级的样式时。
> 2.  **功能性的工具类（Utility Classes）**：比如一个 `.hidden { display: none !important; }` 类，它的作用就是无条件地隐藏元素，需要确保它能覆盖任何其他 `display` 设置。
> 3.  **用户自定义样式表**：用户为了个人访问性需求（如放大字体）而设置的样式。
> 4.  **临时调试**：在开发者工具里快速测试某个样式是否生效。
>
> 总之，在自己的业务代码中应极力避免使用 `!important`，优先考虑通过提高选择器优先级来解决问题。”

---

### **实战任务**

这次的任务需要你动脑预测，而不是动手就写。请看下面的 HTML 和 CSS 代码，然后回答问题。

**HTML:**

```html
<div id="container" class="card">
  <p class="text" style="color: purple;">
    这是一个段落。
  </p>
</div>
```

**CSS:**

```css
/* 规则 1 */
#container .text {
  color: blue;
}

/* 规则 2 */
div.card p {
  color: red;
}

/* 规则 3 */
p {
  color: green !important;
}

/* 规则 4 */
[id="container"] p.text {
  color: orange;
}
```

**请回答：**

1.  **不考虑 `!important` 的情况下**，规则 1、2、4 的优先级分别是多少？（用 `(I,A,B,C)` 的格式写出来）
2.  最终，这个段落的文字会是什么颜色？为什么？请解释你的推理过程，把层叠的三大规则都用上。

行内；id；类伪类和属性元素[]；元素伪元素

规则1：[0, 1, 1, 0]

规则2：[0, 0, 1, 2]

规则4：[0, 0, 2, 1]

不算规则3的话，最终文字颜色是**purple**（紫色），由行内样式决定。

算规则3的话，最终颜色是绿色，因为`!important`优先级最高。
