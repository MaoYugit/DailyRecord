# JS进阶

---

### 1. 作用域 (Scope) 和 作用域链 (Scope Chain)

它们是JS世界里最基本的“规矩”。

#### 核心思想

* **作用域 (Scope)**：就是一个“地盘”。在这个地盘里声明的变量，只有在地盘内部或者更小的子地盘里才能被访问。出了这个地盘，就没人认识你了。这就像你在自己家里（一个地盘），可以随便使用你的牙刷、毛巾。但你跑到邻居家（另一个地盘），就不能用人家的牙刷了。
* **作用域链 (Scope Chain)**：就是一个“寻宝路线图”。当你需要使用一个变量时，JS会先在你的当前地盘（比如一个函数内部）找，如果找不到，它就会去你的上级地盘（比如函数外面）找，再找不到，就再去上级的上级地盘找，一直找到最大的“地球村”（全局作用域）。这条从内到外的寻找路径，就是作用域链。

#### 超详细讲解

我们来看一个故事：

小明住在一个叫`myHouse`的房子里，房子坐落在一个叫`myVillage`的村庄里，村庄外是整个世界。

```javascript
// 全局作用域 (整个世界)
var worldRule = "人人都要讲文明"; 

function myVillage() {
    // 村庄作用域
    var villageRule = "村里不准乱扔垃圾";

    function myHouse() {
        // 房子作用域 (小明的家)
        var houseRule = "进屋要换鞋";

        // 小明现在在自己家里，他想知道有哪些规矩。
        console.log("在家里的规矩:", houseRule);    // 能找到吗？当然，就在家里！
        console.log("村里的规矩:", villageRule);  // 能找到吗？家里找不到，就出门去村里找，找到了！
        console.log("世界的规矩:", worldRule);    // 能找到吗？家里找不到，村里也找不到，就去村外面（世界）找，找到了！
    }

    myHouse(); // 小明在家里思考

    // 现在村长在村委会里，他想知道小明家的规矩
    // console.log("小明家的规矩:", houseRule); // 报错！Uncaught ReferenceError: houseRule is not defined
    // 村长不能直接闯入小明家去看他家的规矩，这是私人的。
}

myVillage(); // 村庄开始运作

// 一个世界公民在任何地方，他想知道村庄和小明家的规矩
// console.log("村里的规矩:", villageRule); // 报错！
// console.log("小明家的规矩:", houseRule); // 报错！
// 他只能知道世界的规矩
console.log("世界的规矩:", worldRule); // 正常输出
```

**一步步分析 "寻宝路线图"（作用域链）:**

1. 当 `myHouse` 函数执行时，它需要打印 `houseRule`。
   * **第一站：** 在 `myHouse` 内部找。嘿！找到了 `var houseRule = "进屋要换鞋";`。任务完成。
2. 当 `myHouse` 函数需要打印 `villageRule`。
   * **第一站：** 在 `myHouse` 内部找。没找到。
   * **第二站：** “出门”去上一层作用域，也就是 `myVillage` 函数内部找。嘿！找到了 `var villageRule = "村里不准乱扔垃圾";`。任务完成。
3. 当 `myHouse` 函数需要打印 `worldRule`。
   * **第一站：** 在 `myHouse` 内部找。没找到。
   * **第二站：** 去 `myVillage` 内部找。还是没找到。
   * **第三站：** “出村”去最外层的全局作用域找。嘿！找到了 `var worldRule = "人人都要讲文明";`。任务完成。

**作用域的类型：**

* **全局作用域 (Global Scope):** 最大的地盘，代码任何地方都能访问。
* **函数作用域 (Function Scope):** 每个函数都会创建一个自己的地盘。
* **块级作用域 (Block Scope):** 在 `let` 和 `const` 出现后，`{}` (比如 `if{}`、`for{}`) 也变成了地盘。这让代码更安全，就像给村里的每条小巷子都装了门禁。

**总结一下：**
作用域就是变量的“有效范围”，作用域链就是当本地盘找不到变量时，向外层地盘逐级寻找的“查找规则”。

---

### 2. JS 垃圾回收机制 (Garbage Collection)

这个概念非常人性化。想象一下你的大脑，你不会永远记住你上周二午饭吃了什么，因为这个信息“没用了”，大脑会自动“清理”它，给新的记忆腾出空间。JS的垃圾回收机制也是干这个活儿的。

#### 核心思想

JavaScript 会自动帮你管理内存。当你创建变量、函数、对象时，JS会分配内存给它们。当这些东西“再也用不到了”的时候，JS的“垃圾回收器”就会像个清洁工一样，把它们占用的内存给收回来，防止内存被耗尽。

#### "再也用不到了" 是如何判断的？

主要有两种算法，但我们只需要重点理解第一种，因为现在浏览器基本都用它。

**1. 标记-清除 (Mark-and-Sweep) 算法（主流）**

这是个非常聪明的算法。

* **工作流程：**
  
  1. **标记阶段 (Mark)：** 垃圾回收器从“根” (Root) 开始，这个“根”你可以理解为全局变量和当前正在被调用的函数等肯定“活着”的东西。它会沿着这些“根”，把所有能访问到的对象都打上一个“存活”的标记。就像从你的心脏开始，把所有连接着的、正在供血的血管都标记为“有用”。
  2. **清除阶段 (Sweep)：** 垃圾回收器会遍历所有的内存，把所有**没有被打上“存活”标记**的对象，当做垃圾，一次性全部清理掉，回收它们的内存。

* **生活化例子：**
  你在办一个派对。
  
  1. **标记：** 你从你自己（根）开始，和你正在聊天的人是“存活”的。然后，你朋友的朋友，只要能通过一条“关系链”找到的，都是“存活”的。你给所有这些人发一个“派对成员”的胸牌。
  2. **清除：** 派对结束时，保安会检查全场，所有**没有胸牌**的人，都会被请出去。

**2. 引用计数 (Reference Counting) 算法（已过时，了解即可）**

* **工作流程：**
  
  * 每个对象都有一个“被引用次数”的计数器。
  * 当有一个变量指向这个对象时，计数器 `+1`。
  * 当这个变量不再指向这个对象时，计数器 `-1`。
  * 当计数器变成 `0` 时，说明没人用它了，它就会被回收。

* **致命缺陷：循环引用**
  想象一下这个场景：
  
  ```javascript
  let objA = {};
  let objB = {};
  
  objA.friend = objB; // objB的引用计数是1
  objB.friend = objA; // objA的引用计数是1
  ```
  
  现在，`objA` 和 `objB` 互相“指着”对方。如果我们不再需要它们了：
  
  ```javascript
  objA = null; // 我们断开了和objA的连接，但objB还指着它，所以objA计数还是1
  objB = null; // 我们断开了和objB的连接，但objA还指着它，所以objB计数还是1
  ```
  
  完蛋了！这两个对象谁也离不开谁，它们的引用计数永远不会是0，内存就泄漏了！它们成了两个谁也不认识的孤魂野鬼，手拉着手，占着内存不肯走。
  而“标记-清除”算法就不会有这个问题，因为从“根”出发，根本找不到 `objA` 和 `objB`，所以它们都不会被标记，最终会被清除。

**总结一下：**
JS有自动的清洁工（垃圾回收器），它会定期（比如当内存不够用时）出来打扫卫生，把那些“失联”的变量（从根部无法访问到的）所占的内存空间给释放出来。你作为开发者，绝大多数时候不用关心这个过程。

---

### 3. JS 闭包 (Closure)

闭包是JS里一个非常强大、但初学者容易懵圈的概念。我们用一个“魔法背包”的比喻来彻底搞懂它。

#### 核心思想

一个函数，如果在它被定义的时候，它的“地盘”（作用域）里有某些变量，那么这个函数就和这些变量被打包在了一起。即使这个函数被带到别的地方去执行，它也**永远记得**它“出生地”的那些变量。这个“函数”和它“出生地的环境变量”组成的包裹，就叫闭包。

#### 超详细讲解

想象一个制造“计数器机器人”的工厂函数 `createCounter`：

```javascript
function createCounter() {
    // 这里是工厂的“内部车间”，外人进不来
    let count = 0; // 这个变量是私有的，只有工厂内部能访问

    // 工厂最后交付给你的，是一个机器人（一个函数）
    const counterRobot = function() {
        count++; // 机器人可以操作自己“出生车间”里的count变量
        console.log("当前计数值:", count);
    };

    return counterRobot; // 把机器人交给你
}

// --- 使用工厂 ---

console.log("召唤第一个机器人...");
const counter1 = createCounter(); // 你从工厂得到了一个机器人，我们叫它 counter1

console.log("召唤第二个机器人...");
const counter2 = createCounter(); // 你又得到了一个全新的机器人，我们叫它 counter2

// --- 操作机器人 ---

counter1(); // 输出: 当前计数值: 1
counter1(); // 输出: 当前计数值: 2
counter1(); // 输出: 当前计数值: 3

counter2(); // 输出: 当前计数值: 1
counter2(); // 输出: 当前计数值: 2

// 你能直接修改count吗？
// console.log(count); // 报错！你根本碰不到工厂车间里的那个count变量
```

**一步步分析 "魔法背包"：**

1. 当你调用 `createCounter()` 时，它创建了一个“车间环境”。
2. 在这个环境中，有一个私有变量 `count`，初始值为 `0`。
3. `createCounter` 函数返回了一个内部函数 `counterRobot`。
4. 当 `createCounter` 执行完毕后，按理说它的“车间环境”应该被销毁，`count` 变量也应该被垃圾回收。
5. **但神奇的事情发生了！** 因为返回的 `counterRobot` 函数内部**还在使用** `count` 变量，JavaScript就认为这个 `count` 变量是“有用的”，不能回收。
6. 所以，JS创建了一个“魔法背包”（闭包），把 `count` 变量装了进去，并把这个背包和 `counterRobot` 函数绑定在了一起。
7. `counter1` 就是一个携带了自己私有 `count` 背包的机器人。`counter2` 是另一个携带了**另一个**私有 `count` 背包的机器人。它们各自的背包是**独立、互不干扰**的。

**闭包的用处：**

1. **数据私有化/封装：** 就像上面的例子，`count` 变量被保护起来了，只能通过我们提供的“机器人接口”去操作它，外部无法随意篡改，非常安全。
2. **创建拥有持久状态的函数：** 每次调用 `counter1`，它都记得上次的值是多少。

**总结一下：**
闭包 = **一个函数** + **该函数创建时所在的作用域环境**。它让一个函数能够“记住”并访问它被创建时的外部变量，即使它在外部作用域执行。

---

### 4. 变量和函数提升 (Hoisting)

这个特性有点像“剧透”。JS引擎在正式一行一行读代码之前，会先快速“扫描”一遍，做一些准备工作。

#### 核心思想

在代码执行前，JavaScript引擎会把所有用 `var` 声明的**变量**和所有**函数声明**，“提升”到它们所在作用域的顶部。

* **对于变量：** 只提升“声明”部分，不提升“赋值”部分。
* **对于函数：** 整个函数体都会被提升。

#### 超详细讲解

**场景一：变量提升 (var)**

想象一下你写了这样的代码：

```javascript
console.log(myName); // 会输出什么？
var myName = "小明";
console.log(myName); // 会输出什么？
```

你可能会想，第一行代码执行时，`myName` 还没定义呢，肯定报错！ **错了！**

JS引擎看到这段代码后，是这么处理的：

1. **准备阶段（提升）：**
   
   * 引擎扫描到 `var myName`，它会说：“哦，有个叫 `myName` 的变量。” 于是它在代码顶部准备好这个变量的位置，但此时还不知道它的值是什么，所以先给它一个默认值 `undefined` (未定义)。
   * 提升后的代码，在JS眼里，实际上是这样的：
   
   ```javascript
   var myName; // 声明被提升到顶部，并赋值为 undefined
   
   console.log(myName); // 执行时，myName是 undefined
   myName = "小明";      // 赋值操作留在原地
   console.log(myName); // 执行时，myName是 "小明"
   ```

2. **执行阶段：**
   
   * 执行第一行 `console.log(myName)`，此时 `myName` 的值是 `undefined`，所以打印出 `undefined`。
   * 执行第二行 `myName = "小明"`，给 `myName` 赋值。
   * 执行第三行 `console.log(myName)`，此时 `myName` 的值是 `"小明"`，所以打印出 `"小明"`。

**场景二：函数提升**

```javascript
sayHello(); // 居然可以正常执行！

function sayHello() {
    console.log("你好呀！");
}
```

这又是为什么？

1. **准备阶段（提升）：**
   
   * 引擎扫描到 `function sayHello() {...}`，它会把**整个函数定义**都“扛”到作用域的最顶上。
   * 提升后的代码，在JS眼里，是这样的：
   
   ```javascript
   function sayHello() { // 整个函数都被提升了
       console.log("你好呀！");
   }
   
   sayHello(); // 然后再执行调用
   ```

2. **执行阶段：**
   
   * 执行 `sayHello()` 时，函数早就准备好了，所以能成功调用。

**现代JS的重要提醒 (`let` 和 `const`)**

为了解决 `var` 提升带来的困惑，ES6引入了 `let` 和 `const`。它们**也会被提升**，但是有一种特殊状态叫 **“暂时性死区” (Temporal Dead Zone, TDZ)**。

```javascript
console.log(myAge); // 致命错误！ReferenceError: Cannot access 'myAge' before initialization

let myAge = 30;
```

`let` 和 `const` 也会被提升到作用域顶部，但它们不允许在“声明”这行代码出现之前被访问。这就好像它们被提升后，被关在一个透明的玻璃盒子里，你能看见它，但你碰不到它。只有当代码执行到声明那一行时，玻璃盒子才会打开。这强制我们养成“先声明，后使用”的好习惯！

**总结一下：**
Hoisting 是 JS 的一种幕后行为。`var` 声明和函数声明会被“提”到最前面。`var` 只提声明，值是 `undefined`；函数声明是整个连身体一起提。`let` 和 `const` 杜绝了这种混乱，让你写出更可靠的代码。**所以，请优先使用 `let` 和 `const`！**

---

### 5. 函数剩余参数 (Rest Parameters) 和 展开运算符 (Spread Operator)

这两个是ES6的超级实用特性，它们都用 `...` 这个符号，但用在不同的地方，意思完全相反。

#### 核心思想

* **剩余参数 (Rest):** 是**聚合**。像一个收纳袋，把一堆零散的东西装进一个数组里。用在**函数定义**的参数部分。
* **展开运算符 (Spread):** 是**打散**。像一袋薯片倒出来，把一个数组里的东西一个个取出来，变成零散的元素。用在**函数调用**或者**数组/对象字面量**中。

#### 超详细讲解

**1. 剩余参数 (Rest Parameters) - 收纳袋 `...`**

假设你要写一个函数，计算所有传入数字的和。但你不知道用户会传几个数字进来。

**以前的丑陋做法：**
要用一个叫 `arguments` 的怪东西，它像数组但又不是真数组，用起来很别扭。

**现在的优雅做法 (用剩余参数)：**

```javascript
// ...args 就是一个收纳袋，它会把所有传入的参数都收集到一个叫 args 的【真数组】里
function sumAll(...args) { 
    console.log(args); // 看看袋子里有什么

    let total = 0;
    for (const num of args) {
        total += num;
    }
    return total;
}

console.log(sumAll(1, 2));             // args 会是 [1, 2]
console.log(sumAll(10, 20, 30, 40));   // args 会是 [10, 20, 30, 40]
console.log(sumAll(5));                // args 会是 [5]
```

你也可以只收集“剩下”的：

```javascript
function introduce(name, age, ...hobbies) {
    console.log("你好，我叫 " + name + "，今年 " + age + "岁。");
    console.log("我的爱好有:", hobbies.join("、")); // hobbies 是个数组，可以直接用数组方法
}

introduce("张三", 25, "打篮球", "编程", "看电影");
// name 会是 "张三"
// age 会是 25
// hobbies 会是 ["打篮球", "编程", "看电影"]
```

**规则：** 剩余参数必须是函数参数列表的**最后一个**。

**2. 展开运算符 (Spread Operator) - 倒薯片 `...`**

**用例一：把数组元素作为函数参数**

```javascript
const numbers = [5, 10, 15];

// 我们想计算 Math.max(5, 10, 15)
// 如果直接传数组，是错的：Math.max(numbers) -> NaN

// 用展开运算符，把数组“打散”成独立的元素
const max = Math.max(...numbers); // 等价于 Math.max(5, 10, 15)
console.log(max); // 15
```

**用例二：合并/克隆数组**

```javascript
const fruits1 = ["苹果", "香蕉"];
const fruits2 = ["橙子", "草莓"];

// 合并数组
const allFruits = [...fruits1, "西瓜", ...fruits2];
// ...fruits1 -> "苹果", "香蕉"
// ...fruits2 -> "橙子", "草莓"
// 结果: ["苹果", "香蕉", "西瓜", "橙子", "草莓"]
console.log(allFruits);

// 克隆数组 (创建一个新的、内容一样的数组)
const fruits1_clone = [...fruits1];
fruits1_clone.push("葡萄");

console.log(fruits1);        // ["苹果", "香蕉"] (原数组不受影响)
console.log(fruits1_clone); // ["苹果", "香蕉", "葡萄"]
```

**用例三：合并/克隆对象（ES2018+）**

```javascript
const userProfile = { name: "李四", age: 30 };
const userAuth = { id: 123, role: "admin" };

// 合并对象
const fullUser = { ...userProfile, ...userAuth, status: "active" };
// 结果: { name: "李四", age: 30, id: 123, role: "admin", status: "active" }
console.log(fullUser);

// 如果有同名属性，后面的会覆盖前面的
const updatedUser = { ...fullUser, age: 31 };
console.log(updatedUser.age); // 31
```

**总结一下：**
看到 `...` 时，问自己一个问题：**它是在收东西，还是在拆东西？**

* 在函数**定义**的参数里 `function(...args)` -> 是**收**，叫**剩余参数**。
* 在函数**调用**或数组/对象里 `myFunc(...arr)` / `[...arr]` -> 是**拆**，叫**展开运算符**。

---


