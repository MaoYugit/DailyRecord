## **DAY 3 - 循环进阶与数组的增删改查**

### **1. `for` 循环及其案例 (复习与深化)**

我们昨天已经学习了 `for` 循环的基本结构：`for (初始化; 条件; 迭代)`。它是我们处理重复性任务最强大的工具。

**核心思想：** 将重复的模式抽象出来，让计算机为我们执行。

**案例：计算 1 到 100 之间所有偶数的和**

```javascript
let sum = 0;

// 初始化 i 为 2，因为 1 不是偶数
// 循环条件是 i <= 100
// 每次循环 i 增加 2，直接跳过所有奇数，效率更高
for (let i = 2; i <= 100; i += 2) {
  sum += i;
}

console.log('1到100之间所有偶数的和是：' + sum); // 输出 2550
```
这个案例展示了 `for` 循环的灵活性，我们可以根据需求调整初始值、条件和迭代方式。

---

### **2. 遍历数组**

这是 `for` 循环最最常见的用途：按顺序访问数组中的每一个元素。

**关键公式：**
*   循环的起始索引是 `0`。
*   循环的结束条件是 `i < 数组.length`。
*   通过 `数组[i]` 来访问当前循环到的元素。

```javascript
const fruits = ['苹果', '香蕉', '橘子', '草莓'];

for (let i = 0; i < fruits.length; i++) {
  // i 的值会依次是 0, 1, 2, 3
  // fruits[i] 会依次是 '苹果', '香蕉', '橘子', '草莓'
  console.log(`我正在吃第 ${i + 1} 个水果：${fruits[i]}`);
}
```
**重点：** `fruits.length` 是数组的长度（4），但最大索引是 `3`。所以循环条件必须是 `i < fruits.length`，如果写成 `i <= fruits.length`，当 `i` 等于 4 时，`fruits[4]` 会是 `undefined`，导致程序出错。

---

### **3. 退出循环 (`break` 与 `continue`)**

有时候我们不需要执行完整个循环，而是想在满足特定条件时提前终止或跳过。

*   `break`: **立即终止**并跳出**整个循环**。就像在比赛中直接退赛。
*   `continue`: **跳过本次循环**的剩余代码，立即进入下一次迭代。就像在比赛中跳过一个障碍，继续跑后面的路。

**案例：在一个数组中寻找第一个大于 80 的数字**

```javascript
const scores = [65, 78, 92, 55, 88];
let foundScore = null;

for (let i = 0; i < scores.length; i++) {
  if (scores[i] > 80) {
    foundScore = scores[i];
    console.log(`找到了！第一个大于80的分数是 ${foundScore}`);
    break; // 已经找到了，没有必要再继续循环，立即退出
  }
}
// 输出：找到了！第一个大于80的分数是 92
```

**案例：计算一个班级的总分，但忽略所有不及格的分数**
```javascript
const scores = [85, 59, 90, 48, 77];
let totalScore = 0;

for (let i = 0; i < scores.length; i++) {
  if (scores[i] < 60) {
    continue; // 如果分数不及格，就跳过本次循环的加法操作
  }
  totalScore += scores[i];
}
console.log('及格分数的总和是：' + totalScore); // 85 + 90 + 77 = 252
```

> #### **面试官提问：** “请说明 `break` 和 `continue` 在循环中的区别和各自的应用场景。”
>
> **回答思路：**
> 1.  **本质区别：**
>     *   `break` 用于完全**终止**离它最近的循环语句，程序将跳转到循环体之外的下一条语句继续执行。
>     *   `continue` 只是用来**结束本次**循环迭代，跳过循环体中尚未执行的语句，然后直接开始下一次循环的迭代。
> 2.  **应用场景：**
>     *   **`break` 的场景**通常是“**查找**”。当你找到了需要的目标，或者某个条件已经达成，后续的循环就失去了意义，使用 `break` 可以提高程序的效率。例如：在一个用户列表中查找特定ID的用户。
>     *   **`continue` 的场景**通常是“**排除**”或“**筛选**”。当循环中的某个元素不符合处理条件时，你想忽略它，继续处理下一个元素。例如：统计数组中所有正数的和，遇到负数时就用 `continue` 跳过。

---

### **4. 循环嵌套**

一个循环体内包含另一个完整的循环结构。这在处理二维数据（如表格、矩阵、棋盘）时非常有用。

**执行规律：** 外层循环执行一次，内层循环会完整地执行一遍。

```javascript
// 外层循环控制行
for (let i = 1; i <= 3; i++) {
  console.log(`这是第 ${i} 行`);
  // 内层循环控制列
  for (let j = 1; j <= 4; j++) {
    console.log(`  - 这是第 ${j} 列`);
  }
}
```
**输出结果：**
```
这是第 1 行
  - 这是第 1 列
  - 这是第 2 列
  - 这是第 3 列
  - 这是第 4 列
这是第 2 行
  - 这是第 1 列
  ... (以此类推)
```

---

### **5. 循环嵌套大练习：打印一个 5x5 的星号矩阵**

**需求：** 在控制台输出一个由 `*` 组成的 5 行 5 列的矩形。

**思路分析：**
1.  我们需要一个外层循环来控制**行数**（总共 5 行）。
2.  在每一行内部，我们需要一个内层循环来控制**列数**（每行打印 5 个 `*`）。
3.  内层循环负责打印 `*`，但不换行。
4.  外层循环每执行完一次（即一行打印完毕），就需要打印一个换行符。

```javascript
let output = ''; // 用一个字符串来拼接结果

for (let i = 1; i <= 5; i++) { // 外层循环控制 5 行
  for (let j = 1; j <= 5; j++) { // 内层循环控制每行打印 5 个星号
    output += '* ';
  }
  output += '\n'; // 每行结束后，拼接一个换行符
}

console.log(output);
```

---

### **6. 九九乘法表案例**

这是循环嵌套最经典的面试题，必须滚瓜烂熟。

**思路分析：**
1.  我们需要两层循环，外层 `i` 和内层 `j` 分别代表两个乘数。
2.  外层循环 `i` 从 1 到 9。
3.  内层循环 `j` 也要从 1 开始，但它的结束条件是 `j <= i`。因为例如 `2*3` 和 `3*2` 是重复的，我们只需要打印一次。同时，每一行打印的个数和行号是相同的（第3行有3个表达式）。
4.  在内层循环中，拼接字符串 `j + 'x' + i + '=' + i * j`，并用制表符 `\t` 分隔，使其对齐。
5.  外层循环结束后，换行。

```javascript
let table = '';
for (let i = 1; i <= 9; i++) { // 外层循环控制行，从1到9
  for (let j = 1; j <= i; j++) { // 内层循环控制列，j 的范围取决于当前的 i
    table += `${j} x ${i} = ${i * j}\t`; // 使用模板字符串和制表符
  }
  table += '\n'; // 一行结束后换行
}
console.log(table);
```

---

### **7. 数组的基本使用以及案例**

复习：数组是值的有序集合，通过索引 `[]` 访问。

**案例：存储一个星期的天气，并输出周三的天气**

```javascript
const weeklyWeather = ['晴', '多云', '晴', '雷阵雨', '阴', '晴', '多云'];
// 索引:             0      1      2       3      4     5     6
console.log('周三的天气是：' + weeklyWeather[2]); // 输出 '晴'
```

---

### **8. 求数组最大/最小值**

这是一个非常基础但重要的算法，考察你的逻辑思维。

**思路：**
1.  声明一个变量 `max` (或 `min`)，并**假设**数组的第一个元素 `arr[0]` 就是最大（或最小）值。
2.  遍历数组，从**第二个**元素开始（因为第一个已经作为初始值了）。
3.  在循环中，将当前元素 `arr[i]` 与 `max` 进行比较。
4.  如果当前元素比 `max` 还大，就更新 `max` 的值为当前元素。
5.  循环结束后，`max` 变量中存储的就是整个数组的最大值。

```javascript
const prices = [102, 99, 150, 88, 188, 120];

// 求最大值
let maxPrice = prices[0]; // 假设第一个就是最大值
for (let i = 1; i < prices.length; i++) {
  if (prices[i] > maxPrice) {
    maxPrice = prices[i]; // 发现一个更大的，更新 maxPrice
  }
}
console.log('最高价格是：' + maxPrice); // 输出 188

// 求最小值 (逻辑完全相反)
let minPrice = prices[0];
for (let i = 1; i < prices.length; i++) {
  if (prices[i] < minPrice) {
    minPrice = prices[i];
  }
}
console.log('最低价格是：' + minPrice); // 输出 88
```

---

### **9. 数组的操作 —— 修改**

通过索引直接赋值即可修改数组中已存在的元素。如果赋值的索引超出了现有范围，JS 会自动扩展数组长度，中间空缺的位置会用 `empty` 或 `undefined` 填充。

```javascript
let colors = ['red', 'green', 'blue'];
colors[1] = 'yellow'; // 修改第二个元素
console.log(colors); // 输出: ['red', 'yellow', 'blue']

colors[3] = 'purple'; // 新增一个元素，因为索引3紧邻末尾
console.log(colors); // 输出: ['red', 'yellow', 'blue', 'purple']

colors[5] = 'black'; // 索引5超出了范围
console.log(colors); // 输出: ['red', 'yellow', 'blue', 'purple', empty, 'black']
console.log(colors.length); // 输出 6
```
**注意：** 直接通过索引跳跃式地增加元素不是一个好习惯，通常我们使用下面介绍的方法。

---

### **10. 数组的操作 —— 增加**

我们使用数组的内置**方法 (Method)** 来更优雅地添加元素。

*   `array.push(元素1, 元素2, ...)`: 在数组的**末尾**添加一个或多个元素。**返回**数组的**新长度**。
*   `array.unshift(元素1, 元素2, ...)`: 在数组的**开头**添加一个或多个元素。**返回**数组的**新长度**。

```javascript
let nums = [10, 20, 30];

// 使用 push
let newLength1 = nums.push(40, 50);
console.log(nums);       // 输出: [10, 20, 30, 40, 50]
console.log(newLength1); // 输出: 5

// 使用 unshift
let newLength2 = nums.unshift(0, 5);
console.log(nums);       // 输出: [0, 5, 10, 20, 30, 40, 50]
console.log(newLength2); // 输出: 7
```
**重点：** `push` 和 `unshift` 都会**修改原始数组**。

---

### **11. 数组筛选案例**

**需求：** 将一个数组中所有大于等于 18 的数字，筛选到一个新的数组中。

> #### **面试官提问：** “给你一个数字数组 `[5, 25, 10, 30, 15]`，请编写代码返回一个只包含其中大于等于 18 的数字的新数组。”
>
> **回答思路：** 这是考察你综合运用循环、条件判断和数组新增操作能力的经典题目。
>
> 1.  **明确目标：** 创建一个**新的、空的数组**，用来存放筛选结果。这一点非常重要，代表你理解了“不可变性”的初步思想，即不修改原始数据。
> 2.  **遍历原始数组：** 使用 `for` 循环遍历给定的数组。
> 3.  **设置筛选条件：** 在循环内部，使用 `if` 语句判断当前元素是否大于等于 18。
> 4.  **添加到新数组：** 如果满足条件，就使用 `push` 方法将这个元素添加到新数组中。
> 5.  **返回新数组：** 循环结束后，返回这个新数组。

**代码实现：**
```javascript
const ages = [15, 22, 18, 12, 30, 17];
const adultAges = []; // 1. 创建一个空数组

for (let i = 0; i < ages.length; i++) { // 2. 遍历原始数组
  if (ages[i] >= 18) { // 3. 设置筛选条件
    adultAges.push(ages[i]); // 4. 添加到新数组
  }
}

console.log('原始年龄数组:', ages);     // [15, 22, 18, 12, 30, 17]
console.log('筛选后的成年人年龄数组:', adultAges); // [22, 18, 30]
```

---

### **12. 数组的操作 —— 删除**

*   `array.pop()`: 删除数组的**最后一个**元素。**返回**被删除的那个**元素**。
*   `array.shift()`: 删除数组的**第一个**元素。**返回**被删除的那个**元素**。
*   `array.splice(开始索引, 删除个数, [新增元素1, ...])`: 这是最强大的数组修改方法，可以实现删除、插入和替换。
    *   **只删除：** `arr.splice(1, 2)` - 从索引1开始，删除2个元素。
    *   **返回**一个包含被删除元素的**数组**。

```javascript
let letters = ['a', 'b', 'c', 'd', 'e'];

// 使用 pop
let lastElement = letters.pop();
console.log(letters);       // 输出: ['a', 'b', 'c', 'd']
console.log(lastElement);   // 输出: 'e'

// 使用 shift
let firstElement = letters.shift();
console.log(letters);       // 输出: ['b', 'c', 'd']
console.log(firstElement);  // 输出: 'a'

// 使用 splice
let deletedItems = letters.splice(0, 2); // 从索引0开始，删除2个元素
console.log(letters);       // 输出: ['d']
console.log(deletedItems);  // 输出: ['b', 'c']
```
**重点：** `pop`, `shift`, `splice` 都会**修改原始数组**。
