### Event Loop 精通学习路线图

我们将分六个阶段完成这个旅程，每个阶段都有明确的目标和行动指南。

| 阶段                 | 核心目标                                                     | 关键行动                                        | 主要资源                                                  |
| :------------------- | :----------------------------------------------------------- | :---------------------------------------------- | :-------------------------------------------------------- |
| **阶段一：建立直觉** | **“啊哈！原来是这样！”** <br> 建立对Event Loop工作模式的宏观、可视化认知。 | 反复观看Philip Roberts的演讲，建立心智模型。    | 📺 Philip Roberts: What the heck is the event loop anyway? |
| **阶段二：夯实地基** | **“原来这些词是这个意思！”** <br> 学习核心概念和术语，将直觉转化为知识。 | 阅读MDN和《忍者秘籍》的基础章节，理解基本组件。 | 📚 MDN, 《JavaScript忍者秘籍》                             |
| **阶段三：突破核心** | **“微任务和宏任务，我懂了！”** <br> 掌握Event Loop中最关键、最易混淆的知识点。 | 专项学习Microtask与Macrotask的区别和执行顺序。  | 📚 MDN, 高质量博客                                         |
| **阶段四：融会贯通** | **“原来和页面渲染是这么回事！”** <br> 将Event Loop与浏览器渲染、性能优化联系起来。 | 学习渲染时机、`requestAnimationFrame`等。       | 📚 MDN, 开发者工具                                         |
| **阶段五：高手进阶** | **“我还能讲清楚Node.js的区别！”** <br> 探索浏览器与Node.js环境下Event Loop的异同。 | 专项学习Node.js的事件循环模型。                 | 📚 《深入浅出Node.js》, Node.js官方文档                    |
| **阶段六：实战为王** | **“放马过来，这题我会！”** <br> 通过实战题目，检验并巩固所有知识。 | 分析复杂的异步代码，预测输出结果。              | 💻 经典面试题                                              |

---

### 详细行动指南

#### **阶段一：建立直觉 —— “啊哈！原来是这样！”**

**你的状态：** 一张白纸，对Event Loop一无所知。
**目标：** 不求甚解，只求在脑中画出一幅动态的流程图。

1.  **核心行动：观看Philip Roberts的演讲视频。**
    *   **第一遍：** 不按暂停，完整看完。感受一下整个流程：代码如何进入**调用栈（Call Stack）**，`setTimeout`如何被扔给**Web APIs**，回调函数如何进入**回调队列（Callback Queue）**，Event Loop如何不断地把队列里的东西搬回调用栈。
    *   **第二遍：** 边看边暂停，在纸上画出他演示的四个区域：Call Stack, Web APIs, Callback Queue, Event Loop（那个圈圈）。跟着他的例子，手动模拟一遍 `console.log`、`setTimeout` 的流转过程。
    *   **关键理解：** 记住这张图，并理解一个核心思想：**JavaScript本身是单线程的，但它运行的环境（浏览器/Node.js）是多线程的，Event Loop就是连接这两者的桥梁。**

#### **阶段二：夯实地基 —— “原来这些词是这个意思！”**

**你的状态：** 脑子里有幅图，但说不清楚每个部分叫什么，干什么。
**目标：** 用专业的术语精确描述你在第一阶段看到的流程。

1.  **阅读MDN官方文档：**
    *   搜索并精读 **“并发模型与事件循环”** 页面。这是MDN对Event Loop最权威、最核心的解释。
    *   你需要在这里搞懂以下几个名词的精确定义：
        *   **调用栈 (Call Stack):** 函数调用的地方，后进先出。
        *   **堆 (Heap):** 对象等引用类型数据存储的地方。
        *   **队列 (Queue):** 准备执行的回调函数排队的地方（这里先理解为宏任务队列）。
        *   **事件循环 (Event Loop):** 它的唯一工作就是“当调用栈为空时，从队列中取出一个任务并放入调用栈”。

2.  **阅读《JavaScript忍者秘籍》（第2版）：**
    *   **精读第13章 “让代码活起来的定时器”**：这一章会用非常精准的语言解释定时器（如`setTimeout(fn, 0)`）的原理，它会告诉你，定时器不是“到时间就执行”，而是“到时间后，把回调函数**放入队列**”。这会完美印证和深化你在视频里学到的知识。

#### **阶段-三：突破核心 —— “微任务和宏任务，我懂了！”**

**这是从“知道”到“精通”最关键的一步！** 那个10000块的课程，80%的“干货”都在这里。

1.  **重新定义“队列”：**
    *   现在你要知道，第二阶段的“队列”其实不够精确。它实际上分为两种：
        *   **宏任务队列 (Macrotask Queue):** `setTimeout`, `setInterval`, `I/O`, UI渲染, `requestAnimationFrame` 等。
        *   **微任务队列 (Microtask Queue):** `Promise.then/catch/finally`, `process.nextTick` (Node.js), `MutationObserver` 等。

2.  **学习黄金执行法则：**
    *   Event Loop的每一次循环（称为一个tick）的执行顺序是固定的：
        1.  从**宏任务队列**中取出一个宏任务来执行。
        2.  执行完毕后，检查**微任务队列**，并**执行完所有的微任务**。如果在执行微任务的过程中，又产生了新的微任务，那么这些新的微任务也会在同一个tick内被执行。
        3.  （可选）执行UI渲染操作。
        4.  回到第1步，开始下一次循环。

3.  **资源强化：**
    *   **MDN:** 搜索并阅读 **“In depth: Microtasks and the event loop”**。
    *   在网上搜索文章：“深入理解JS事件循环：微任务和宏任务”，看别人画的图和举的例子。

#### **阶段四：融会贯通 —— “原来和页面渲染是这么回事！”**

**目标：** 把抽象的知识和用户能看到的东西联系起来，理解性能问题。

1.  **渲染时机：** 理解UI渲染本身也是一个宏任务。它会在处理完所有微任务后，由浏览器决定是否执行。如果你的微任务队列执行时间过长，就会阻塞渲染，导致页面卡顿。
2.  **`requestAnimationFrame` (rAF):** 阅读MDN关于rAF的文档。理解它为什么是实现流畅动画的最佳选择——因为它是一个**由浏览器保证在下一次重绘（repaint）前执行**的特殊宏任务。

#### **阶段五：高手进阶 —— “我还能讲清楚Node.js的区别！”**

**目标：** 扩展你的知识边界，展现你的知识深度。

1.  **浏览器 vs. Node.js：** 简单来说：
    *   **浏览器Event Loop** 的实现是统一的（遵循HTML5标准），模型相对简单（宏任务队列 -> 所有微任务 -> 渲染）。
    *   **Node.js Event Loop** 的实现基于`libuv`，它的循环分为好几个阶段（timers, I/O callbacks, poll, check等）。
2.  **关键区别 `process.nextTick`：** 在Node.js中，`process.nextTick` 有一个独立的队列，它的优先级甚至高于微任务队列。即：**在一个阶段结束后，会先清空`nextTick`队列，再清空微任务队列。**

#### **阶段六：实战为王 —— “放马过来，这题我会！”**

**目标：** 用最经典的面试题来检验你的学习成果，达到能给别人讲明白的程度。

1.  **拿起纸笔，分析下面的“天王级”面试题：**

    ```javascript
    async function async1() {
      console.log('async1 start');
      await async2();
      console.log('async1 end');
    }

    async function async2() {
      console.log('async2');
    }

    console.log('script start');

    setTimeout(function() {
      console.log('setTimeout');
    }, 0);

    async1();

    new Promise(function(resolve) {
      console.log('promise1');
      resolve();
    }).then(function() {
      console.log('promise2');
    });

    console.log('script end');
    ```

2.  **你的任务：**
    *   **不要运行代码！**
    *   按照你在第三阶段学到的“黄金执行法则”，一步步推导出`console.log`的输出顺序。
    *   **提示：** `await` 右边的代码是立即执行的，而 `await` 下方的代码，会被包装成一个微任务，放入微任务队列。
    *   **写下你的分析过程：**
        1.  同步代码执行...
        2.  遇到`setTimeout`，将其回调放入宏任务队列。
        3.  执行`async1`...
        4.  遇到`Promise`...
        5.  同步代码执行完毕，当前微任务队列里有什么？宏任务队列里有什么？
        6.  开始执行微任务...
        7.  微任务执行完毕，执行下一个宏任务...

3.  **核对答案和解析：**
    *   正确答案是：`script start`, `async1 start`, `async2`, `promise1`, `script end`, `async1 end`, `promise2`, `setTimeout`。
    *   去网上搜索这道题的解析，对比你的分析过程，看看错在哪里，或者哪里理解得还不够透彻。

