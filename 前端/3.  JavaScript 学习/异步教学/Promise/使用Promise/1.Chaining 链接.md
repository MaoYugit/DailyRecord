# 使用Promise 

## 1. 基础概念 (从回调到 .then)

[`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) 是一个表示异步操作最终完成或失败的对象。由于大多数人都是使用已创建的 Promise，因此本指南将先解释如何使用已返回的 Promise，然后再解释如何创建它们。

本质上，Promise 是一个返回的对象，你可以将回调附加到该对象上，而不是将回调传递给函数。想象一下 `createAudioFileAsync()` 函数，它根据一个配置记录和两个回调函数异步生成一个声音文件：一个回调函数在音频文件创建成功时调用，另一个回调函数在发生错误时调用。

以下是一些使用 `createAudioFileAsync()` 代码：

```js
function successCallback(result) {
  console.log(`Audio file ready at URL: ${result}`);
}

function failureCallback(error) {
  console.error(`Error generating audio file: ${error}`);
}

createAudioFileAsync(audioSettings, successCallback, failureCallback);

```

如果 `createAudioFileAsync()` 被重写为返回一个 Promise，那么应该将回调附加到它上面：

```js
createAudioFileAsync(audioSettings).then(successCallback, failureCallback);

```

- 在旧的回调模式中，你必须**在发起异步操作时**就想好成功和失败后要干什么，并把这两个“后续处理”作为参数传进去。
- 在 Promise 模式中，你只需要发起异步操作，它会**立即返回一个“凭证”（Promise 对象）**。你可以在任何需要的时候，拿着这个凭证去注册“后续处理”（通过 .then()）。



这种惯例有几个优点。我们将逐一探讨。

## 2. 链式调用 Chaining 

一种常见的需求是连续执行两个或多个异步操作，其中每个后续操作都在前一个操作成功时启动，并使用前一步的结果。在过去，连续执行多个异步操作会导致经典的[回调地狱 ](https://medium.com/@raihan_tazdid/callback-hell-in-javascript-all-you-need-to-know-296f7f5d3c1)：

假设点外卖有三个异步步骤（每一步都需要花时间等待结果）：

1. `doSomething`: 选择一家餐厅。（这需要时间，可能餐厅没开门）
2. `doSomethingElse`: 从选好的餐厅里，挑选一道菜。（这也需要时间，可能菜卖完了）
3. `doThirdThing`: 选好菜后，下单支付。（这也需要时间，可能支付失败）

```js
function failureCallback(error) {
  console.error("出错了:", error);
}

doSomething(function (result) {
  doSomethingElse(result, function (newResult) {     
    doThirdThing(newResult, function (finalResult) {       
      console.log(`Got the final result: ${finalResult}`);       
    }, failureCallback);    
  }, failureCallback);   
}, failureCallback);

```

```js
// 这是一个统一的失败处理函数，比如弹出一个“操作失败”的提示框。
function failureCallback(error) {
  console.error("出错了:", error);
}

// 开始执行任务
doSomething(
    // 这是 doSomething 的 “成功回调函数”
    // 只有在【第一步：选择餐厅】成功后，这个函数才会被调用
    function (result) {
        // result 是第一步成功的结果，也就是【选好的餐厅】

        console.log("第一步完成：选好了餐厅", result);

        // 现在，用第一步的结果去执行第二步
        doSomethingElse(
            result, // 把【选好的餐厅】传进去

            // 这是 doSomethingElse 的 “成功回调函数”
            // 只有在【第二步：挑选菜品】成功后，这个函数才会被调用
            function (newResult) {
                // newResult 是第二步成功的结果，也就是【选好的菜品】

                console.log("第二步完成：选好了菜品", newResult);

                // 现在，用第二步的结果去执行第三步
                doThirdThing(
                    newResult, // 把【选好的菜品】传进去

                    // 这是 doThirdThing 的 “成功回调函数”
                    // 只有在【第三步：下单支付】成功后，这个函数才会被调用
                    function (finalResult) {
                        // finalResult 是第三步成功的结果，比如【订单号】
                        console.log(`Got the final result: ${finalResult}`);
                        console.log("任务全部完成！外卖在路上了！");
                    },
                    
                    // 如果【第三步：下单支付】失败，调用这个失败处理函数
                    failureCallback
                );
            },
            
            // 如果【第二步：挑选菜品】失败，调用这个失败处理函数
            failureCallback
        );
    },
    
    // 如果【第一步：选择餐厅】失败，调用这个失败处理函数
    failureCallback
);
```

**总结一下它的执行逻辑：**

1. **启动**：程序调用 doSomething 函数，并给了它两个“指令”：
   - 一个函数告诉它**成功后该做什么**。
   - 另一个函数 (failureCallback) 告诉它**失败后该做什么**。
2. **第一步**：doSomething 开始执行（比如去网络上查找餐厅）。
   - **如果成功**：它会调用我们给的第一个函数（成功回调），并把结果（比如餐厅的名字 result）传进去。**然后，代码进入了下一层嵌套**。
   - **如果失败**：它会调用 failureCallback，整个流程就此中断。
3. **第二步**：在第一步的成功回调里面，程序调用了 doSomethingElse，并把上一步的结果 result 传了进去。同样，也给了它成功和失败的指令。
   - **如果成功**：它调用成功回调，把结果 newResult（选好的菜）传进去。**代码再次进入更深一层嵌套**。
   - **如果失败**：它调用 failureCallback，流程中断。
4. **第三步及最终结果**：在第二步的成功回调里，程序调用 doThirdThing，逻辑和前面一样。
   - **如果成功**：它调用自己的成功回调，打印出最终结果 finalResult。至此，所有任务圆满完成。
   - **如果失败**：调用 failureCallback，流程中断。

### 为什么这种写法被称为“回调地狱”？

看完上面的分析，你应该能感觉到问题所在了：

1. **可读性极差**：代码不断向右缩进，形成一个“金字塔”形状（Pyramid of Doom）。当步骤增多时，你很难一眼看清整个流程的顺序和逻辑。
2. **难以维护**：
   - 如果想在第二步和第三步之间**增加一个新步骤**，你需要在嵌套的中间层插入一大块代码，非常容易出错。
   - 如果想**调整步骤的顺序**，几乎等于重写。
3. **错误处理混乱**：虽然这个例子里共用了一个 failureCallback，但在实际项目中，不同步骤可能需要不同的错误处理逻辑，这会让代码变得更加复杂和难以管理。

**这正是 Promise 要解决的核心问题**。Promise 通过链式调用 (.then())，将这个“金字塔”结构拉平成了一条直线，让代码像同步代码一样从上到下执行，大大提升了可读性和可维护性。

使用 Promise，我们通过创建 Promise 链式调用来实现这一点。Promise 的 API 设计使其更加出色，因为回调会附加到返回的 Promise 对象上，而不是传递给函数。

```js
// 使用 Promise 的版本 (是不是清爽多了？)
doSomething()
  .then(result => doSomethingElse(result))
  .then(newResult => doThirdThing(newResult))
  .then(finalResult => console.log(`Got the final result: ${finalResult}`))
  .catch(error => failureCallback(error));

```

这就是魔法： `then()` 函数返回一个**新的 promise** ，与原来的不同：

```js
const promise = doSomething();
const promise2 = promise.then(successCallback, failureCallback);

```

第二个 Promise ( `promise2` ) 不仅代表 `doSomething()` 的完成，还代表你传入的 `successCallback` 或 `failureCallback` 的完成——后者可以是其他返回 Promise 的异步函数。在这种情况下，任何添加到 `promise2` 的回调都会排在 `successCallback` 或 `failureCallback` 返回的 Promise 之后。

**笔记：** 如果您想要一个可以运行的示例，您可以使用以下模板来创建任何返回Promise的函数：

```js
function doSomething() {
  return new Promise((resolve) => {
    setTimeout(() => {
      // Other things to do before completion of the promise
      console.log("Did something");
      // The fulfillment value of the promise
      resolve("https://example.com/");
    }, 200);
  });
}

```

下面的围绕旧回调 API 创建 Promise部分讨论了该实现。

使用此模式，您可以创建更长的处理链，其中每个 Promise 代表链中一个异步步骤的完成。此外， `then` 的参数是可选的， `catch(failureCallback)` 是 `then(null, failureCallback)` 的缩写——因此，如果您的错误处理代码在所有步骤中都相同，则可以将其附加到链的末尾：

```js
doSomething()
  .then(function (result) {
    return doSomethingElse(result);
  })
  .then(function (newResult) {
    return doThirdThing(newResult);
  })
  .then(function (finalResult) {
    console.log(`Got the final result: ${finalResult}`);
  })
  .catch(failureCallback);

```

您可能会看到用[箭头函数](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)来表达这一点：

```js
doSomething()
  .then((result) => doSomethingElse(result))
  .then((newResult) => doThirdThing(newResult))
  .then((finalResult) => {
    console.log(`Got the final result: ${finalResult}`);
  })
  .catch(failureCallback);

```

**注意：** 箭头函数表达式可以有[隐式返回 ](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#function_body)；因此， `() => x` 是 `() => { return x; }` 缩写。

`doSomethingElse` 和 `doThirdThing` 可以返回任何值——如果它们返回 Promise，则首先等待该 Promise 完成，然后下一个回调接收完成值，而不是 Promise 本身。务必始终从 `then` 回调返回 Promise，即使该 Promise 最终解析为 `undefined` 。如果前一个处理程序启动了一个 Promise 但未返回，则无法再跟踪其完成情况，此时该 Promise 被称为“浮动”。

```js
doSomething()
  .then((url) => {
    // Missing `return` keyword in front of fetch(url).
    fetch(url);
  })
  .then((result) => {
    // result is undefined, because nothing is returned from the previous
    // handler. There's no way to know the return value of the fetch()
    // call anymore, or whether it succeeded at all.
  });

```

通过返回 `fetch` 调用的结果（这是一个承诺），我们既可以跟踪它的完成情况，也可以在完成时接收它的值。

```js
doSomething()
  .then((url) => {
    // `return` keyword added
    return fetch(url);
  })
  .then((result) => {
    // result is a Response object
  });

```

如果存在竞争条件，浮动承诺可能会更糟 - 如果未返回最后一个处理程序的承诺，则 `then` 处理程序将被提前调用，并且它读取的任何值都可能是不完整的。

```js
const listOfIngredients = [];

doSomething()
  .then((url) => {
    // Missing `return` keyword in front of fetch(url).
    fetch(url)
      .then((res) => res.json())
      .then((data) => {
        listOfIngredients.push(data);
      });
  })
  .then(() => {
    console.log(listOfIngredients);
    // listOfIngredients will always be [], because the fetch request hasn't completed yet.
  });

```

因此，根据经验法则，每当您的操作遇到承诺时，就返回它并将其处理推迟到下 `then` 处理程序。

```js
const listOfIngredients = [];

doSomething()
  .then((url) => {
    // `return` keyword now included in front of fetch call.
    return fetch(url)
      .then((res) => res.json())
      .then((data) => {
        listOfIngredients.push(data);
      });
  })
  .then(() => {
    console.log(listOfIngredients);
    // listOfIngredients will now contain data from fetch call.
  });

```

更好的是，你可以将嵌套链展平为单个链，这样更简洁，也更容易处理错误。详细信息将在下面的 [“嵌套”](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises#nesting) 部分讨论

```js
doSomething()
  .then((url) => fetch(url))
  .then((res) => res.json())
  .then((data) => {
    listOfIngredients.push(data);
  })
  .then(() => {
    console.log(listOfIngredients);
  });

```

使用 [`async` / `await`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) 可以帮助你编写更直观、更类似于同步代码的代码。下面是使用 `async` / `await` 相同示例：

```js
async function logIngredients() {
  const url = await doSomething();
  const res = await fetch(url);
  const data = await res.json();
  listOfIngredients.push(data);
  console.log(listOfIngredients);
}

```

请注意，除了 Promise 前面的 `await` 关键字外，这段代码看起来与同步代码完全相同。唯一的缺点之一是容易忘记 [`await`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) 关键字，只有在类型不匹配时（例如，尝试将 Promise 用作值）才能修复这个问题。

`async` / `await` 建立在 Promise 之上——例如， `doSomething()` 与之前的函数相同，因此只需进行少量重构即可从 Promise 转换为 `async` / `await` 。您可以在 [async 函数](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)和 [`await`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await) 参考中了解有关 `async` / `await` 语法的更多信息。

**注意：** `async` / `await` 具有与普通承诺链相同的并发语义。一个异步函数内的 `await` 不会停止整个程序，只会停止依赖于其值的部分，因此其他异步作业在 `await` 待处理时仍可以运行。