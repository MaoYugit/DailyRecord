在 JS 中，很多操作（比如网络请求、文件读写、定时器）都不会立即返回结果，它们需要时间。如果代码一直“傻等”着这些操作完成，整个程序就会被阻塞，用户界面会卡死。为了解决这个问题，JS 提供了异步编程的能力。

现在我们来梳理一下 JS 异步解决方案的演进之路，从“回调地狱”到 `Promise`，再到现代的 `Async/Await`。

---

### **1. 回调函数 (Callbacks)**

回调函数是 JS 最早的异步解决方案。它的思想很简单：**“你先忙，忙完了调用我给你提供的这个函数”**。

这个被“提供”的函数，就叫回调函数 (Callback Function)。

#### **基本概念**

我们先用一个常见的 `setTimeout` 来模拟一个异步操作（比如请求数据）。

```javascript
// 定义一个模拟获取用户数据的函数
// 它接受一个用户 ID 和一个回调函数作为参数
function getUserData(userId, callback) {
  console.log(`开始获取 ID 为 ${userId} 的用户数据...`);
  
  // 模拟网络延迟，2秒后执行
  setTimeout(() => {
    // 假设这是从服务器获取到的数据
    const userData = { id: userId, name: 'Alice', age: 25 };
    
    // 数据获取成功后，调用传入的回调函数，并将数据作为参数传回去
    callback(userData); 
  }, 2000);
}

// 定义一个回调函数，用于处理获取到的数据
function handleUserData(data) {
  console.log('数据获取成功!');
  console.log(`用户姓名: ${data.name}, 年龄: ${data.age}`);
}

// 调用函数，传入 ID 和回调函数
getUserData(101, handleUserData);

console.log('主线程代码继续执行，不会被阻塞...');
```

**代码细节拿捏：**

1.  `getUserData` 函数发起了异步操作 (`setTimeout`)。
2.  它没有 `return`任何数据，因为数据要 2 秒后才可用。
3.  `handleUserData` 就是回调函数，它定义了**数据回来后该做什么**。
4.  `getUserData(101, handleUserData)` 这行代码执行后，`console.log('主线程代码...')` 会立刻被打印，证明了代码没有被阻塞。2 秒后，`setTimeout` 里的匿名函数执行，调用 `callback(userData)`，此时 `handleUserData` 才被执行。

#### **“回调地狱” (Callback Hell)**

当多个异步操作之间存在依赖关系时，事情就变得复杂了。比如：你需要先获取用户信息，然后根据用户信息去获取他的订单，再根据订单信息去获取商品详情。

这会导致回调函数层层嵌套，形成所谓的 **“回调地狱” (Callback Hell)** 或 **“毁灭金字塔” (Pyramid of Doom)**。

```javascript
// 模拟三个相互依赖的异步操作
function getUser(userId, callback) {
  setTimeout(() => {
    console.log(`(1) 获取用户 ${userId} 的信息...`);
    const user = { id: userId, name: 'Bob' };
    callback(user);
  }, 1000);
}

function getOrders(user, callback) {
  setTimeout(() => {
    console.log(`(2) 获取用户 ${user.name} 的订单列表...`);
    const orders = [{ id: 1, amount: 100 }, { id: 2, amount: 200 }];
    callback(orders);
  }, 1000);
}

function getOrderDetails(order, callback) {
  setTimeout(() => {
    console.log(`(3) 获取订单 ${order.id} 的商品详情...`);
    const details = { orderId: order.id, items: ['商品A', '商品B'] };
    callback(details);
  }, 1000);
}

// 回调地狱出现！
getUser(102, function(user) {
  getOrders(user, function(orders) {
    getOrderDetails(orders[0], function(details) {
      console.log('最终获取到的商品详情:', details.items);
      // 如果还有第四步、第五步...代码会继续向右缩进
    });
  });
});
```

**问题所在：**

*   **可读性极差**：代码横向发展，逻辑混乱。
*   **难以维护**：增加或修改其中一步都非常困难。
*   **错误处理复杂**：每一层都需要单独处理错误，很容易遗漏。

---

### **2. Promise (ES6)**

为了解决回调地狱的问题，ES6 标准化了 `Promise` 对象。`Promise` 的意思是“承诺”，它承诺一个异步操作最终会有一个结果。

`Promise` 就像一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。

#### **三种状态**

一个 `Promise` 对象必然处于以下三种状态之一：

1.  **Pending (进行中)**：初始状态，既不是成功，也不是失败。
2.  **Fulfilled (已成功)**：意味着操作成功完成。
3.  **Rejected (已失败)**：意味着操作失败。

**状态转换细节：**

*   状态只能从 `Pending` 变为 `Fulfilled` 或 `Pending` 变为 `Rejected`。
*   这个状态变化是**一次性**的，一旦改变，就再也不会变了。

#### **核心 API: `.then()`, `.catch()`, `.finally()`**

我们用 `Promise` 来重写上面的“回调地狱”代码。

```javascript
// 1. 将异步操作封装成返回 Promise 的函数
function getUserPromise(userId) {
  // Promise 构造函数接受一个函数作为参数
  // 这个函数有两个参数：resolve 和 reject
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log(`(1) 获取用户 ${userId} 的信息...`);
      if (userId > 100) {
        const user = { id: userId, name: 'Charlie' };
        // 成功时调用 resolve，将 Promise 状态从 Pending 变为 Fulfilled
        resolve(user); 
      } else {
        // 失败时调用 reject，将 Promise 状态从 Pending 变为 Rejected
        reject(new Error('无效的用户ID'));
      }
    }, 1000);
  });
}

function getOrdersPromise(user) {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log(`(2) 获取用户 ${user.name} 的订单列表...`);
      const orders = [{ id: 1, amount: 100 }, { id: 2, amount: 200 }];
      resolve(orders);
    }, 1000);
  });
}

function getOrderDetailsPromise(order) {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log(`(3) 获取订单 ${order.id} 的商品详情...`);
      const details = { orderId: order.id, items: ['商品C', '商品D'] };
      resolve(details);
    }, 1000);
  });
}

// 2. 使用 .then() 链式调用，告别回调地狱
getUserPromise(103)
  .then(user => {
    // .then 的第一个回调函数处理 Fulfilled 状态
    // 它的返回值会作为一个新的 Promise 的结果
    return getOrdersPromise(user); 
  })
  .then(orders => {
    return getOrderDetailsPromise(orders[0]);
  })
  .then(details => {
    console.log('最终获取到的商品详情:', details.items);
  })
  .catch(error => {
    // .catch 用于捕获链条中任何一个环节的 Rejected 状态
    console.error('出错了:', error.message);
  })
  .finally(() => {
    // .finally 无论成功 (Fulfilled) 还是失败 (Rejected) 都会执行
    console.log('整个流程执行完毕。');
  });
```

**代码细节拿捏：**

1.  **Promise 封装**：每个异步函数不再接受回调，而是返回一个 `new Promise()`。
2.  **`resolve` 和 `reject`**：它们是函数，调用 `resolve(value)` 将状态变为 `Fulfilled` 并传递结果 `value`；调用 `reject(error)` 将状态变为 `Rejected` 并传递错误 `error`。
3.  **链式调用**：`.then()` 方法返回的是一个新的 `Promise`，这使得我们可以像链条一样把多个异步操作串联起来，代码从横向的金字塔变成了纵向的线性结构，可读性大大增强。
4.  **统一错误处理**：`.catch()` 可以捕获它前面链条上任何一个 `Promise` 的 `reject` 状态，实现了统一的、清晰的错误处理。
5.  **`.finally()`**：非常适合做一些无论成功失败都需要执行的清理工作，比如关闭加载动画。

#### **静态方法**

`Promise` 对象本身也提供了一些好用的静态方法。

* **`Promise.resolve(value)`**: 创建一个立即进入 `Fulfilled` 状态的 Promise。

  ```js
  Promise.resolve('成功').then(res => console.log(res)); // "成功"
  
  ```

* **`Promise.reject(error)`**: 创建一个立即进入 `Rejected` 状态的 Promise。

  ```javascript
  Promise.reject(new Error('失败')).catch(err => console.error(err.message)); // "失败"
  ```
* **`Promise.all(iterable)`**: 接收一个 Promise 数组，**全部**成功才算成功，返回所有结果的数组。只要有一个失败，整个就失败，并返回第一个失败的原因。

  ```javascript
  const p1 = Promise.resolve('p1 OK');
  const p2 = new Promise(resolve => setTimeout(() => resolve('p2 OK'), 1000));
  const p3 = Promise.resolve('p3 OK');
  
  Promise.all([p1, p2, p3])
    .then(results => console.log(results)) // 约1秒后打印: ['p1 OK', 'p2 OK', 'p3 OK']
    .catch(err => console.error(err));
  ```
* **`Promise.race(iterable)`**: 接收一个 Promise 数组，“赛跑”，**任何一个** Promise 完成（无论成功或失败），整个就完成，并返回那一个 Promise 的结果/原因。

  ```javascript
  const pFast = new Promise(resolve => setTimeout(() => resolve('快的赢了'), 500));
  const pSlow = new Promise(resolve => setTimeout(() => resolve('慢的输了'), 1000));
  
  Promise.race([pFast, pSlow])
    .then(result => console.log(result)) // 500ms后打印: "快的赢了"
    .catch(err => console.error(err));
  ```
* **`Promise.allSettled(iterable)` (ES2020)**: 接收一个 Promise 数组，等待**所有** Promise 都完成（不管是 `fulfilled` 还是 `rejected`）。它总会进入 `fulfilled` 状态，并返回一个包含每个 Promise 结果对象（包含状态和值/原因）的数组。非常适合不关心某个异步操作是否失败，只关心所有操作都已结束的场景。

  ```javascript
  const pSuccess = Promise.resolve('成功了');
  const pFail = Promise.reject('失败了');
  
  Promise.allSettled([pSuccess, pFail])
    .then(results => console.log(results));
  /*
  打印:
  [
    { status: 'fulfilled', value: '成功了' },
    { status: 'rejected', reason: '失败了' }
  ]
  */
  ```
* **`Promise.any(iterable)` (ES2021)**: 接收一个 Promise 数组，只要**任何一个** Promise 成功 (`fulfilled`)，整个就成功，并返回第一个成功的结果。如果所有都失败了，则抛出一个 `AggregateError` 错误。

  ```javascript
  const pFail1 = Promise.reject('第一个失败');
  const pSuccess1 = new Promise(resolve => setTimeout(() => resolve('第一个成功'), 500));
  const pSuccess2 = new Promise(resolve => setTimeout(() => resolve('第二个成功'), 1000));
  
  Promise.any([pFail1, pSuccess1, pSuccess2])
    .then(result => console.log(result)); // 500ms后打印: "第一个成功"
  ```

---

### **3. Async/Await (ES2017)**

`Async/Await` 是异步编程的终极解决方案（目前来看）。它被称为“异步的同步写法”，让你可以像写同步代码一样去写异步代码，大大提升了代码的可读性。

`Async/Await` 本质上是 `Promise` 的**语法糖 (Syntactic Sugar)**，它并没有创造新的东西，底层仍然是 `Promise`。

#### **`async` 和 `await` 的作用**

*   **`async`**：用于声明一个函数是异步函数。
    *   **本质**：`async` 函数的返回值会自动被包装成一个 `Promise` 对象。如果函数内部 `return` 一个非 `Promise` 值，它会被 `Promise.resolve()` 包装。
*   **`await`**：字面意思是“等待”。
    *   **作用**：它只能用在 `async` 函数内部。`await` 后面通常跟着一个 `Promise` 对象。它会暂停 `async` 函数的执行，直到后面的 `Promise` 状态变为 `Fulfilled`，然后将 `Promise` 的结果返回。如果 `Promise` 状态变为 `Rejected`，它会抛出错误。

#### **使用 `try...catch` 进行错误处理**

我们用 `async/await` 来重构之前的 `Promise` 链式调用代码。

```javascript
// 函数声明前加上 async 关键字
async function fetchOrderDetails() {
  // 使用 try...catch 来捕获 await 过程中可能出现的错误
  try {
    // await 会“暂停”执行，直到 Promise 完成，并返回其结果
    const user = await getUserPromise(103); 
    const orders = await getOrdersPromise(user);
    const details = await getOrderDetailsPromise(orders[0]);
    
    console.log('最终获取到的商品详情:', details.items);
    return details; // async 函数的返回值
  } catch (error) {
    console.error('出错了:', error.message);
  } finally {
    console.log('整个流程执行完毕。');
  }
}

// 调用 async 函数
fetchOrderDetails().then(details => {
  if (details) {
    console.log('Async 函数返回的 Promise 成功了，结果是:', details);
  }
});
```

**代码细节拿捏：**

1.  **代码结构**：代码从 `.then()` 的链式结构，变成了从上到下的同步代码结构，逻辑一目了然。
2.  **`await` 的魔力**：`const user = await getUserPromise(103);` 这行代码看起来就像一个普通的赋值语句，但 `await` 确保了 `getUserPromise` 的 `Promise` 完成后，才会把结果赋值给 `user`，并继续执行下一行。
3.  **错误处理**：`Promise` 链的 `.catch()` 被 `try...catch` 语句替代，这是同步代码中标准的错误处理方式，非常直观。
4.  **`async` 函数的返回值**：调用 `fetchOrderDetails()` 会立即返回一个 `Promise`。当函数内部所有 `await` 都执行完毕（或遇到 `return` 或 `throw`），这个 `Promise` 的状态才会确定。你可以像普通 `Promise` 一样，在后面链式调用 `.then()`。

---

### **最终案例练习**

现在，请你运用今天学到的知识，完成下面的练习。

**需求：**

创建一个函数 `fetchUserAndFirstPost(userId)`，它需要完成以下几件事：

1.  根据 `userId` 从 `https://jsonplaceholder.typicode.com/users/{userId}` 获取用户信息。
2.  获取成功后，根据用户信息中的 `id`，从 `https://jsonplaceholder.typicode.com/posts?userId={userId}` 获取该用户的**所有帖子**。
3.  获取成功后，找到帖子列表中的**第一篇帖子**。
4.  最后，将用户信息和第一篇帖子的信息组合成一个对象并返回，格式如下：
    ```json
    {
      "user": { "id": 1, "name": "Leanne Graham", ... },
      "firstPost": { "userId": 1, "id": 1, "title": "...", "body": "..." }
    }
    ```
5.  在任何一步网络请求失败时，都需要能捕获到错误并打印 "获取数据失败: [错误信息]"。

**提示:**

*   你需要使用 `fetch()` API 来发送网络请求。`fetch()` 本身返回的就是一个 `Promise`。
*   `fetch(url).then(response => response.json())` 可以将返回的响应体解析为 JSON 对象，`response.json()` 也返回一个 `Promise`。

请你分别用 **Promise 的 `.then()` 链** 和 **`async/await`** 两种方式来实现这个函数。

<details>
<summary>点击查看 Promise 方案参考答案</summary>

```javascript
function fetchUserAndFirstPostWithPromise(userId) {
  let fetchedUser; // 在链的外部定义一个变量来存储用户信息

  fetch(`https://jsonplaceholder.typicode.com/users/${userId}`)
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return response.json();
    })
    .then(user => {
      fetchedUser = user; // 保存用户信息
      console.log('成功获取用户:', user.name);
      return fetch(`https://jsonplaceholder.typicode.com/posts?userId=${user.id}`);
    })
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return response.json();
    })
    .then(posts => {
      if (posts.length === 0) {
        throw new Error('该用户没有发表任何帖子');
      }
      const firstPost = posts[0];
      console.log('成功获取第一篇帖子:', firstPost.title);
      
      const result = {
        user: fetchedUser,
        firstPost: firstPost
      };
      
      console.log('最终组合结果:', result);
      return result;
    })
    .catch(error => {
      console.error('获取数据失败:', error.message);
    });
}

// 调用函数
fetchUserAndFirstPostWithPromise(1);
```
</details>

<details>
<summary>点击查看 Async/Await 方案参考答案</summary>

```javascript
async function fetchUserAndFirstPostWithAsync(userId) {
  try {
    // 获取用户
    const userResponse = await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`);
    if (!userResponse.ok) {
      throw new Error(`HTTP error! status: ${userResponse.status}`);
    }
    const user = await userResponse.json();
    console.log('成功获取用户:', user.name);
    
    // 获取帖子
    const postsResponse = await fetch(`https://jsonplaceholder.typicode.com/posts?userId=${user.id}`);
    if (!postsResponse.ok) {
      throw new Error(`HTTP error! status: ${postsResponse.status}`);
    }
    const posts = await postsResponse.json();
    if (posts.length === 0) {
      throw new Error('该用户没有发表任何帖子');
    }
    const firstPost = posts[0];
    console.log('成功获取第一篇帖子:', firstPost.title);

    // 组合并返回结果
    const result = {
      user: user,
      firstPost: firstPost
    };
    
    console.log('最终组合结果:', result);
    return result;

  } catch (error) {
    console.error('获取数据失败:', error.message);
  }
}

// 调用函数
fetchUserAndFirstPostWithAsync(2);
```
</details>

尝试自己动手实现这个练习，并对比两种写法的差异，你会对 JS 异步编程有更深刻的理解。如果还有其他问题，随时可以提出来！