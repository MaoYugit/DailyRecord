### **第 5 课：Grid（网格布局）**

如果说 Flexbox 是一条生产流水线，擅长将物品（items）沿着一条线高效地排列和对齐，那么 **Grid 就是一个仓库的货架系统**。它同时关心水平（行）和垂直（列）的位置，让你能够精确地将页面的各个宏观部分（如页眉、侧边栏、主内容区、页脚）放置在它们应该在的位置。

欢迎来到二维布局的终极形态。

#### **核心思想：二维布局，布局优先**

Grid 的核心思想与 Flexbox 完全不同。Flexbox 是“内容优先”（content-out），你把一堆内容扔进去，然后告诉它们如何流动和对齐。

而 Grid 是“布局优先”（layout-in）。你**首先用 CSS 在页面上画出一个看不见的网格框架**，就像一个棋盘，然后把你页面的各个部分（items）像棋子一样，**精确地放置**到你预先定义好的单元格中。你拥有对行和列的同时控制权。

---

### **深度剖析 1：定义网格 (The Container's Rules)**

一切始于一个容器，通过 `display: grid;` 将其激活。

#### **`grid-template-columns` 和 `grid-template-rows`：定义网格轨道**
这两个属性是 Grid 布局的基石。它们用来定义网格有多少列、多少行，以及每一列/行的尺寸。

```css
.container {
  display: grid;
  grid-template-columns: 200px 1fr 1fr; /* 3列：第一列200px，后两列平分剩余空间 */
  grid-template-rows: 100px auto 50px; /* 3行：第一行100px高，第二行自适应内容，第三行50px高 */
}
```

#### **`fr` 单位：网格的灵魂**

`fr` (Fractional Unit, 碎片单位) 是 Grid 布局的专属单位。它代表了网格容器中**可用空间**的一份。这使得创建弹性布局变得异常简单。

*   `1fr 1fr 1fr`：将可用空间平均分成 3 份。
*   `2fr 1fr`：将可用空间分成 3 份，第一列占 2 份，第二列占 1 份。

#### **`repeat()` 函数：更高效的写法**
当你有很多重复的轨道时，`repeat()` 函数可以简化你的代码。

```css
/* 写法一：啰嗦 */
grid-template-columns: 1fr 1fr 1fr 1fr 1fr;

/* 写法二：优雅 */
grid-template-columns: repeat(5, 1fr);
```

#### **`minmax()` 函数：弹性的边界**

这个函数允许你为一个轨道定义一个最小和最大尺寸，是实现响应式设计的利器。

```css
/* 这一列的宽度最小是200px，最大会自由伸展占据1份空间 */
grid-template-columns: minmax(200px, 1fr);
```

#### **`gap`：网格间距**
与 Flexbox 中的 `gap` 完全一样，用来定义行与行、列与列之间的间距。

```css
.container {
  gap: 20px; /* 行和列的间距都是 20px */
  row-gap: 10px; /* 只设置行间距 */
  column-gap: 30px; /* 只设置列间距 */
}
```

---

### **深度剖析 2：项目放置 (The Items' Rules)**

定义好网格之后，我们就需要把项目（子元素）放进去。

#### **基于网格线 (Grid Lines)**
一个 `n` 列的网格有 `n+1` 条垂直的网格线。行也同理。

*   `grid-column-start` / `grid-column-end`：定义项目从哪条列网格线开始，到哪条结束。
*   `grid-row-start` / `grid-row-end`：定义项目从哪条行网格线开始，到哪条结束。
*   **简写**：`grid-column: 1 / 3;` (从第1条线开始，到第3条线结束，占据第1、2列)
*   **简写**：`grid-row: 2 / 4;`
*   **超级简写**：`grid-area: row-start / column-start / row-end / column-end;`

#### **基于网格区域命名 (`grid-area`)**
这是 Grid 布局最强大、最语义化的部分。你可以给网格的每个区域命名，然后直接把项目放进这个命名的区域。

**第一步：在容器上用 `grid-template-areas` 定义布局**
```css
.container {
  display: grid;
  grid-template-columns: 1fr 3fr;
  grid-template-rows: auto 1fr auto;
  grid-template-areas:
    "header header"
    "sidebar main"
    "footer footer";
}
```
*   上面的代码定义了一个 2x3 的网格。
*   `header` 区域横跨了两列。
*   `sidebar` 和 `main` 在第二行并列。
*   `footer` 横跨了两列。
*   用 `.` 代表一个空的单元格。

**第二步：在项目上用 `grid-area` “对号入座”**
```css
.header-item { grid-area: header; }
.sidebar-item { grid-area: sidebar; }
.main-item { grid-area: main; }
.footer-item { grid-area: footer; }
```
仅仅通过这几行代码，一个完整的、清晰的页面布局就完成了。而且在媒体查询中，你只需要重新定义 `grid-template-areas` 就可以轻松改变整个页面的布局结构！

---

### **深度剖析 3：无需媒体查询的响应式网格**

结合 `repeat()` 和 `minmax()`，我们可以创造出一种“魔法”般的响应式列表，它会自动根据容器宽度调整列的数量。

```css
.card-list {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 1rem;
}
```
**代码解读：**
*   `repeat(auto-fit, ...)`: 浏览器会自动计算，在当前容器宽度下，能放下多少列。`auto-fit` 会将空轨道折叠起来，让现有项目去占据空间，通常是你想要的效果。（`auto-fill` 则会保留空轨道）。
*   `minmax(250px, 1fr)`: 每个列的宽度最小是 `250px`。如果还有剩余空间，它们会像 `1fr` 一样去平分这些空间。
*   **效果**：当容器足够宽时，它可能是 3 列或 4 列。当你缩小浏览器窗口，它会自动变成 2 列，再缩小，就变成 1 列，全程无需写一条媒体查询！

---

### **实战与面试**

**面试官问：“请解释 Grid 和 Flexbox 的区别及适用场景。”**

> **你的回答**：“最核心的区别在于维度：**Flexbox 是一维布局，Grid 是二维布局**。
>
> *   **Flexbox** 擅长沿着单根轴线（行或列）对齐一系列内容。它非常适合**组件内部**的布局，比如导航栏里的菜单项、卡片里的按钮对齐等，我们称之为“内容优先”的布局。
> *   **Grid** 擅长同时在行和列两个维度上进行布局，可以轻松地创建复杂的宏观页面结构。它非常适合**页面级别**的整体布局，比如页眉、侧边栏、主内容和页脚的排布，我们称之为“布局优先”的布局。
>
> 在实际项目中，它们通常是**协同工作**的：用 Grid 搭建页面的整体骨架，然后用 Flexbox 来处理骨架内部各个组件的细节布局。”

**面试官问：“如何实现一个圣杯布局的现代版本？”**

> **你的回答**：“圣杯布局（三栏布局，中间自适应，两边固定）在过去需要复杂的 hack，但用 Grid 布局只需要几行代码，并且非常健壮。我们可以使用 `grid-template-areas` 来实现。
> ```css
> .container {
> display: grid;
> grid-template-columns: 200px 1fr 200px; /* 左中右三列 */
> grid-template-areas: "header header header"
>                     "nav main aside"
>                     "footer footer footer";
> }
> .header { grid-area: header; }
> .nav { grid-area: nav; }
> .main { grid-area: main; }
> .aside { grid-area: aside; }
> .footer { grid-area: footer; }
> ```
> 这样就创建了一个完美的圣杯布局，中间的 `main` 区域（`1fr`）会自动伸缩。”

**面试官问：“`fr` 单位和百分比有什么不同？”**

> **你的回答**：“它们都用于创建弹性布局，但计算基准不同。
>
> *   **百分比 (`%`)** 是相对于**容器的总宽度或总高度**来计算的。它不考虑 `gap`。如果你设置 `grid-template-columns: 50% 50%;` 并加上 `column-gap`，总宽度会超出 100%，导致溢出。
> *   **`fr` 单位**是相对于**容器的可用空间**来计算的。可用空间是容器总尺寸减去所有非 `fr` 单位的轨道和所有 `gap` 之后剩下的空间。`fr` 是“gap 感知”的，它会自动处理间距，永远不会导致溢出。
>
> 因此，在 Grid 布局中，`fr` 是创建弹性轨道的首选单位，它比百分比更强大、更可靠。”

---

### **实战任务**

现在，我们来用 Grid 搭建一个经典的博客页面布局。

**HTML 结构:**
```html
<div class="blog-layout">
  <header class="blog-header">Header</header>
  <nav class="blog-nav">Navigation</nav>
  <main class="blog-main">Main Content</main>
  <aside class="blog-sidebar">Sidebar</aside>
  <footer class="blog-footer">Footer</footer>
</div>
```

**你的任务：**
1.  将 `.blog-layout` 变成一个 Grid 容器。
2.  **定义网格结构**: 创建一个三列、三行的网格。
    *   **列**: 左侧导航栏 `200px`，中间内容区**自适应**，右侧侧边栏 `250px`。
    *   **行**: 头部 `100px`，中间内容区**自适应**，底部 `80px`。
3.  **命名网格区域**: 使用 `grid-template-areas` 创建一个与经典博客布局匹配的视觉结构。
4.  **放置项目**: 将 HTML 中的五个元素，通过 `grid-area` 属性，准确地放置到你命名的区域中。
5.  **(挑战)** 添加一个媒体查询，当屏幕宽度小于 `768px` 时，让侧边栏 (`.blog-sidebar`) 移动到主内容区 (`.blog-main`) 的下方，导航栏移动到页眉下方，形成单列布局。

这个任务将让你完整地体验一次从设计网格到放置内容，再到响应式调整的全过程。祝你玩得愉快！
