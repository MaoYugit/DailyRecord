# [274. H 指数](https://leetcode.cn/problems/h-index/)

给你一个整数数组 `citations` ，其中 `citations[i]` 表示研究者的第 `i` 篇论文被引用的次数。计算并返回该研究者的 **`h` 指数**。

根据维基百科上 [h 指数的定义](https://baike.baidu.com/item/h-index/3991452?fr=aladdin)：`h` 代表“高引用次数” ，一名科研人员的 `h` **指数** 是指他（她）至少发表了 `h` 篇论文，并且 **至少** 有 `h` 篇论文被引用次数大于等于 `h` 。如果 `h` 有多种可能的值，**`h` 指数** 是其中最大的那个。

 

**示例 1：**

```
输入：citations = [3,0,6,1,5]
输出：3 
解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。
     由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。
```

**示例 2：**

```
输入：citations = [1,3,1]
输出：1
```

 

**提示：**

- `n == citations.length`
- `1 <= n <= 5000`
- `0 <= citations[i] <= 1000`





### 题解：

看起来不容易，毕竟是道中等题。仔细分析一下，`h`肯定大于等于0。我们可以先把`h`设置为0，然后遍历整个数组，逐渐更新`h`的值。但是更新的条件应该是什么呢？

灵光一闪！我们可以先给整个数组从小到大排序，中间向下取整那个值便是所求。这也太简单了吧。还中等题呢，啧啧啧。不对，好像有问题，我们仔细分析一下什么是`h`指数：至少发表了 `h` 篇论文，并且 **至少** 有 `h` 篇论文被引用次数大于等于 `h` 。如果 `h` 有多种可能的值，**`h` 指数** 是其中最大的那个。

如果我们中间这个数字是100，但是我们根本没有100篇论文，那不完犊子了。乱七八糟的，好像有很多错误。

所以说我们重新搞一个如何得到`h`的方法，是不是可以重后往前遍历，后面的数字一定是大于等于我们最终求得的`h`的，我们先让`h=0`，如果最后那个数字大于h，那么`h+1`，然后逐个往回走，知道遇见一个没有`h`大的那我们就终止，这个`h`一定就是我们所求：因为它满足至少发表了h篇论文（h就是我们通过遍历论文得到的，所以一定满足这个条件）；也满足h篇论文引用次数大于等于h，因为后面h篇论文都是会大于这个h的，h也是最大的那个，再继续增大就不满足前面的条件了。但是用的冒泡排序，击败的人数比较少。

```python
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        def bubble_sort(nums):
            n = len(nums)
            for i in range(0, n):
                for j in range(0, n - i - 1):
                    if nums[j] > nums[j + 1]:
                        nums[j], nums[j + 1] = nums[j + 1], nums[j]
            return nums
        n = len(citations)
        bubble_sort(citations)
        h = 0
        for i in range(n-1, -1, -1):
            if citations[i] > h:
                h += 1
        return h
```

看一下官方解答，哦！原来python有排序函数可以直接调用。那直接这样就可以了。用时击败100% 内存击败85.34%。牛逼。看来得补习一下排序相关知识了。

```python
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        sorted_citations = sorted(citations)
        h = 0
        n = len(citations)
        for i in range(n-1, -1, -1):
            if sorted_citations[i] > h:
                h += 1
        return h

```

给Gemini看了一下，他给了我们一种全新的思路，看起来更棒！

### 提供一个进阶思路（非排序解法）

既然你已经掌握了排序解法，这里再给你介绍一种不需要排序、时间复杂度为 **O(n)** 的方法，叫**计数排序**或**桶排序**的思想。

1. H 指数 h 不可能超过论文总数 n。
2. 我们可以创建一个长度为 n+1 的计数数组 counter。counter[i] 用来记录引用次数**恰好**为 i 的论文有多少篇。（对于引用次数 > n 的论文，我们都可以当作 n 来处理，因为 h 不会超过 n）。
3. 遍历一遍 citations 数组，填充这个 counter 数组。
4. **从后往前**遍历 counter 数组 (从 n 到 0)。维护一个变量 total 记录论文总数。total += counter[i]。
5. 当 total >= i 时，说明我们已经找到了 total 篇论文，它们的引用次数都大于等于 i。因为我们是从大到小遍历 i 的，所以第一个满足这个条件的 i 就是最大的 h 指数。

这个方法只需要两次 O(n) 的遍历和 O(n) 的额外空间，所以整体是 O(n) 的，比排序更快。
