# [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置在下标 0。

每个元素 `nums[i]` 表示从索引 `i` 向后跳转的最大长度。换句话说，如果你在索引 `i` 处，你可以跳转到任意 `(i + j)` 处：

- `0 <= j <= nums[i]` 且
- `i + j < n`

返回到达 `n - 1` 的最小跳跃次数。测试用例保证可以到达 `n - 1`。

 

**示例 1:**

```bash
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

**示例 2:**

```bash
输入: nums = [2,3,0,1,4]
输出: 2
```





### 题解：

这题一看就知道蛮简单！因为我刚刚做完跳跃游戏第一题。但是好像有点不对劲！

我目前的思路是：记录下每个能到达的点，然后进行处理。我们先从前往后推理：如果我们每一次都跳到离当前位置最远的可达点，是不是就是最优解？好像不是：假设当前可以跳到倒数第五个，但是倒数第五个需要一步一步跳到最后一个，这样总共就需要五步到达终点，如果我们最开始只跳到第一个，而第一个刚好可以一步跳到重点，那我们只需要两步就行了。从后往前推，如果是按照相同的思路的话，结果是一样的，因为本质上我们到达最后一个点，把那一边看作最后一个点都是一样的。

那到底该怎么办？

潜意识里还是觉得应该从后往前来推导。我们慢慢来：

**倒数第一个**：已经到终点了，所以需要的步数为0

**倒数第二个**：如果可以到达终点的话，所需要的步数为1

倒数第三个：如果可以到达终点的话，分为几种情况：如果自己本身可以到达终点，那么需要的步数是1，如果本身不可以到达的话，那需要借助倒数第二个，如果倒数第二个可以到达的话，那就是2步；

**总结一下**：如果可以直接到达，那就是一步；如果不可以直接到达，那就筛选出前面可以到达的点中可以用最短步数到达的点，加上1就是最终需要花费的步数。

看起来这个思路是可以的，只需要记录每个点到达需要的最短步数就好了。但是该怎么用代码实现呢？感觉用字典存储相关信息会比较便捷，但是我不太会，不过熟能生巧，这一个代码就用字典存储吧。

好吧，还是不会，好烦。

**Gemini 启动！**

好的，让我们来启动 Gemini，为你剖析这道经典的算法题！

你对这道题的思考过程非常棒，特别是你意识到了“每次都跳到最远的点不一定是最优解”这一点，这说明你已经深入思考了问题的复杂性。你总结的思路“如果可以直接到达，那就是一步；如果不可以直接到达，那就筛选出前面可以到达的点中可以用最短步数到达的点，加上1就是最终需要花费的步数”其实已经非常接近动态规划的思想了。

不过，这道题有一个更高效、更巧妙的解法，那就是**贪心算法**。

### 贪心算法思路解析

你的直觉“从前往后推理”是正确的方向。贪心算法的核心思想是：**在每一步都做出当前看起来最优的选择，从而期望最终得到全局最优解**。

对于这个问题，我们的“贪心”策略不是关注下一步跳到哪个具体的点，而是**在当前这一跳的覆盖范围内，找到下一跳能跳到的最远距离**。这有点像广度优先搜索（BFS）的思路，我们一层一层地扩展可以到达的范围。

让我们用几个变量来辅助理解这个过程：

1.  `jumps`: 记录总的跳跃次数。
2.  `current_jump_end`: 记录当前这一跳所能到达的最远边界。当我们遍历到这个边界时，就意味着必须进行下一次跳跃了。
3.  `farthest`: 记录在当前位置 `i`，通过 `nums[i]` 的跳跃，我们能到达的最远位置。

**算法步骤:**

1.  初始化 `jumps = 0`, `current_jump_end = 0`, `farthest = 0`。
2.  从左到右遍历数组 `nums`（注意：只需要遍历到倒数第二个元素，因为我们的目标是“到达”最后一个元素，一旦我们的 `farthest` 能够覆盖到最后一个元素，就可以确定结果了）。
3.  在遍历到位置 `i` 时，我们计算从这个位置出发能到达的最远距离 `i + nums[i]`，然后更新 `farthest = max(farthest, i + nums[i])`。这个 `farthest` 变量会不断记录我们从【第一跳能覆盖的所有位置】中出发，【第二跳】能到达的最远距离。
4.  判断当前位置 `i` 是否到达了 `current_jump_end`。
    *   如果 `i == current_jump_end`，说明我们已经走完了当前这一跳可以覆盖的所有范围。
    *   此时，我们必须进行下一跳。于是，我们将 `jumps` 加 1。
    *   同时，我们将下一跳的边界更新为我们之前计算好的 `farthest`，即 `current_jump_end = farthest`。

通过这种方式，我们确保了每一步跳跃都是为了达到尽可能远的目标，从而最小化了总的跳跃次数。

### 示例 1 演练: `nums = [2,3,1,1,4]`

让我们来一步步分解这个过程：

*   **初始状态**: `jumps = 0`, `current_jump_end = 0`, `farthest = 0`, `n = 5`

*   **i = 0**:
    *   `nums[0] = 2`。从位置0最远可以跳到 `0 + 2 = 2`。
    *   更新 `farthest = max(0, 2) = 2`。
    *   此时 `i == current_jump_end` (都是0)。这意味着第一跳的范围已经考察完毕，必须进行跳跃了。
    *   `jumps` 增加 1，变为 `1`。
    *   更新下一跳的边界 `current_jump_end = farthest = 2`。
    *   *状态*: 我们用了 **1** 跳，现在最远可以到达下标 **2**。

*   **i = 1**:
    *   `nums[1] = 3`。从位置1最远可以跳到 `1 + 3 = 4`。
    *   更新 `farthest = max(2, 4) = 4`。
    *   此时 `i != current_jump_end` (1 != 2)，所以还不需要进行下一次跳跃的决策。

*   **i = 2**:
    *   `nums[2] = 1`。从位置2最远可以跳到 `2 + 1 = 3`。
    *   更新 `farthest = max(4, 3) = 4`。
    *   此时 `i == current_jump_end` (都是2)。这意味着第二跳的范围已经考察完毕。
    *   `jumps` 增加 1，变为 `2`。
    *   更新下一跳的边界 `current_jump_end = farthest = 4`。
    *   *状态*: 我们用了 **2** 跳，现在最远可以到达下标 **4**。

*   **i = 3**:
    *   `nums[3] = 1`。从位置3最远可以跳到 `3 + 1 = 4`。
    *   更新 `farthest = max(4, 4) = 4`。
    *   此时 `i != current_jump_end` (3 != 4)。

循环在 `i = len(nums) - 2 = 3` 结束后停止。最终返回 `jumps` 的值，即 **2**。

### Python 代码实现

下面是基于贪心算法的 Python 代码实现。

```python
from typing import List

class Solution:
    def jump(self, nums: List[int]) -> int:
        n = len(nums)
        if n <= 1:
            return 0
        
        # jumps 记录跳跃次数
        jumps = 0
        # current_jump_end 记录当前这一跳能到达的最远边界
        current_jump_end = 0
        # farthest 记录在遍历过程中，能到达的最远位置
        farthest = 0
        
        # 我们只需要遍历到倒数第二个元素
        # 因为当 i 到达倒数第二个元素时，farthest 必然已经覆盖了最后一个元素
        for i in range(n - 1):
            # 更新从当前位置能跳到的最远距离
            farthest = max(farthest, i + nums[i])
            
            # 如果到达了当前跳跃的边界
            if i == current_jump_end:
                # 进行下一次跳跃
                jumps += 1
                # 更新下一次跳跃的边界
                current_jump_end = farthest
                
                # 一个小优化：如果下一跳的边界已经可以覆盖或超过终点，
                # 就可以提前结束循环了
                if current_jump_end >= n - 1:
                    break
                    
        return jumps

```





