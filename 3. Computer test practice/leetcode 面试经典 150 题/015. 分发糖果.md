# [135. 分发糖果](https://leetcode.cn/problems/candy/)

`n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到 `1` 个糖果。
- 相邻两个孩子中，评分更高的那个会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。

 

**示例 1：**

```
输入：ratings = [1,0,2]
输出：5
解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
```

**示例 2：**

```
输入：ratings = [1,2,2]
输出：4
解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。
```

 

**提示：**

- `n == ratings.length`
- `1 <= n <= 2 * 104`
- `0 <= ratings[i] <= 2 * 104`



### 题解：

终于要来了吗？我的第一个困难题！字越少题越难是吧。一看不会。总感觉要用到贪心、动态规划什么的。但是我不熟。让我来仔细思考一下吧。

**1小朋友**：1颗糖

**2个小朋友**：2颗糖

**3个小朋友**：

​	评分相同：3颗糖

​	评分不同：		

|   评分    |    糖     | 总数 |
| :-------: | :-------: | :--: |
| [1, 2, 1] | [1, 2, 1] |  4   |
| [2, 2, 1] | [1, 2, 1] |  4   |
| [1, 1, 2] | [1, 1, 2] |  4   |
| [1, 2, 3] | [1, 2, 3] |  6   |
|  [2,1,2]  |  [2,1,2]  |  5   |

看不出来什么规律啊。再来一组

**4个小朋友：**

​	评分相同：4颗糖

​	评分不同：		

|      评分       |       糖        | 总数 |
| :-------------: | :-------------: | :--: |
|  [1, 1, 1, 2,]  |  [1, 1, 1, 2,]  |  5   |
|  [1, 1,  2, 1]  |  [1, 1,  2, 1]  |  5   |
| [1, 1, 2, 3, 1] | [1, 1, 2, 3, 1] |  8   |
| [1, 2, 1, 3, 1] | [1, 2, 1, 2, 1] |  7   |

初现端倪，但是好难总结。

妈的！给小孩发糖还这么扣扣嗖嗖的！

**Gemini！启动！**

哈哈哈，你这个吐槽太到位了：“给小孩发糖还这么扣扣嗖嗖的！”

这道题确实是困难题里的经典，你的直觉非常准，它就是一道典型的贪心算法题。你自己动手推演小规模的例子，这是解决所有算法题最正确的第一步！看不出规律是完全正常的，因为这个规律隐藏得比较深。

问题的核心难点在于，**每个孩子的糖果数量，同时受到左边和右边两个孩子的影响**。只看一边是不够的。

比如 `ratings = [1, 5, 3]`：
*   看孩子2（评分5），他比左边的孩子1（评分1）高，所以糖果要比孩子1多。
*   同时，他又比右边的孩子3（评分3）高，所以糖果也要比孩子3多。

如果我们试图一次遍历就确定所有糖果，会陷入“瞻前顾后”的困境。那怎么办呢？

### 核心思想：规则拆解，两次搞定！

既然同时考虑左右两边很复杂，我们就把它拆开，一次只考虑一边！

1.  **第一次遍历（从左到右）**：先满足一个规则 —— **“如果一个孩子比他左边的孩子评分高，那他的糖果就要比左边孩子的多。”**
2.  **第二次遍历（从右到左）**：再满足另一个规则 —— **“如果一个孩子比他右边的孩子评分高，那他的糖果就要比右边孩子的多。”**

这两次遍历结合起来，就能得到那个“扣扣嗖嗖”的最小糖果数。

---

### 详细步骤 (贪心算法)

让我们用 `ratings = [1, 0, 2]` 这个例子来走一遍流程。

#### 步骤一：初始化

首先，根据规则“每个孩子至少分配到1个糖果”，我们给每个孩子都先发1颗糖。
创建一个 `candies` 数组，长度和 `ratings` 一样，所有元素都初始化为 1。

`ratings = [1, 0, 2]`
`candies = [1, 1, 1]`

#### 步骤二：第一次遍历 (从左到右)

我们从第二个孩子开始，只和他**左边**的邻居比较。

*   **`i = 1`** (第二个孩子): `ratings[1] (0)` 不大于 `ratings[0] (1)`。不满足“评分更高”的条件，啥也不用做。
    `candies` 仍然是 `[1, 1, 1]`

*   **`i = 2`** (第三个孩子): `ratings[2] (2)` 大于 `ratings[1] (0)`。他需要比第二个孩子糖果多。
    `candies[2] = candies[1] + 1 = 1 + 1 = 2`。
    `candies` 变为 `[1, 1, 2]`

第一次遍历结束。现在 `candies` 数组 `[1, 1, 2]` 已经满足了所有“比左边邻居评分高”的情况。但是，它可能不满足“比右边邻居评分高”的规则（比如第一个孩子评分1 > 第二个孩子评分0，但糖果数却是1=1）。

#### 步骤三：第二次遍历 (从右到左)

现在，我们从倒数第二个孩子开始，只和他**右边**的邻居比较，来“查漏补缺”。

*   **`i = 1`** (第二个孩子): `ratings[1] (0)` 不大于 `ratings[2] (2)`。不满足“评分更高”的条件，啥也不用做。
    `candies` 仍然是 `[1, 1, 2]`

*   **`i = 0`** (第一个孩子): `ratings[0] (1)` 大于 `ratings[1] (0)`。他需要比第二个孩子糖果多。
    他需要的糖果数**至少**是 `candies[1] + 1 = 1 + 1 = 2`。
    我们现在的 `candies[0]` 是 1，比 2 小，所以需要更新。
    `candies[0]` 更新为 `2`。
    `candies` 变为 `[2, 1, 2]`

    **关键点**：如果第二次遍历时，发现某个孩子 `i` 需要更新糖果数，我们不能简单地 `candies[i] = candies[i+1] + 1`。因为第一次遍历的结果也要被尊重。所以应该是 `candies[i] = max(candies[i], candies[i+1] + 1)`。这样可以保证两个规则同时满足。

第二次遍历结束。我们得到了最终的糖果分配方案 `[2, 1, 2]`。

#### 步骤四：计算总和

`sum([2, 1, 2]) = 5`。这就是最少需要的糖果数。

---

### Python 代码实现

```python
from typing import List

class Solution:
    def candy(self, ratings: List[int]) -> int:
        n = len(ratings)
        # 1. 初始化，每个孩子至少一个糖果
        candies = [1] * n
        
        # 2. 第一次遍历：从左到右
        # 满足“比左边邻居评分高，糖果更多”的规则
        for i in range(1, n):
            if ratings[i] > ratings[i-1]:
                candies[i] = candies[i-1] + 1
                
        # 3. 第二次遍历：从右到左
        # 满足“比右边邻居评分高，糖果更多”的规则
        # 从倒数第二个孩子开始
        for i in range(n - 2, -1, -1):
            if ratings[i] > ratings[i+1]:
                # 如果右遍历需要的糖果数比左遍历分配的还多，就更新
                # 这样可以同时满足两个规则
                candies[i] = max(candies[i], candies[i+1] + 1)
                
        # 4. 计算总和
        return sum(candies)

```

这个“两次遍历”的贪心思路非常巧妙，它把一个复杂的问题分解成了两个简单的子问题，分别解决后再合并，最终得到全局最优解。现在再看这道题，是不是感觉清晰多了？



好一个Gemini，一看就很清晰了。

但是又有一个疑惑：删删减减最终汇成一句话，我是傻逼，脑子到不到那个点，或许多练练最终就不会有这样乱七八糟自己也说不清楚的疑惑和问题。
