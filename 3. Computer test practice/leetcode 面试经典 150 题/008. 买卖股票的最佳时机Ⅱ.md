# [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。然而，你可以在 **同一天** 多次买卖该股票，但要确保你持有的股票不超过一股。

返回 *你能获得的 **最大** 利润* 。

 

**示例 1：**

```
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。
最大总利润为 4 + 3 = 7 。
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
最大总利润为 4 。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0。
```

 

**提示：**

- `1 <= prices.length <= 3 * 104`
- `0 <= prices[i] <= 104`





### 题解：

我一看我就知道，这题----我不会。那就先想想吧。先去晾一个衣服。

啥也不管，Gemini 启动！

**Gemini：**当然可以！这道题有一个非常巧妙且简洁的解法。为了引导你找到它，这里有几个不同角度的提示，你可以按顺序看，直到找到思路为止。

---

### **提示 1：关注基本操作**

不要去想复杂的“买入”和“卖出”状态。把问题简化到最核心的部分：**利润是如何产生的？** 利润只在价格上涨时产生。我们能从每一次价格上涨中获利吗？

---

### **提示 2：贪心思维 (Greedy Approach)**

这道题是贪心算法的一个经典应用。贪心算法的核心是在每一步都做出当前看起来最好的选择。

想一想，对于股票交易，**“当前最好的选择”** 是什么？是不是只要明天的价格比今天高，我就应该抓住这个利润？如果我今天买入，明天卖出，我就赚了 `prices[i+1] - prices[i]`。我需要担心这个决定会影响未来的收益吗？

---

### **提示 3：分解利润**

看一个上涨区间的例子：`[1, 2, 5]`。

*   如果在第1天买入（价格1），第3天卖出（价格5），利润是 `5 - 1 = 4`。

*   现在换个思路：
    *   如果在第1天买入（1），第2天卖出（2），利润是 `2 - 1 = 1`。
    *   然后，**立刻**在第2天再次买入（2），第3天卖出（5），利润是 `5 - 2 = 3`。
    *   总利润是 `1 + 3 = 4`。

你发现了吗？**一个连续上涨区间的总利润，等于该区间内每一天上涨利润的总和。** 这个发现能把一个复杂的问题变得非常简单。

---

### **提示 4：一个更简单的视角（最关键的提示）**

你完全不需要去记录“买入”价格。

从第二天开始遍历数组，你只需要问一个问题：**今天的价格比昨天高吗？**

*   如果**是**，那就意味着存在一个利润机会 `prices[i] - prices[i-1]`。把这个正的差值累加到你的总利润中。
*   如果**否**，那就说明今天价格下跌了，你不可能在昨天买今天卖来赚钱，所以今天什么也不做（或者说，利润增加0）。

遍历完整个数组，累加的利润就是最终答案。思考一下为什么这个简单的逻辑是正确的。

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        profit  = 0
        for i in range(len(prices)-1):
            if prices[i+1] > prices[i]:
                profit += prices[i+1] - prices[i]
        return profit
```



当然可以。动态规划（Dynamic Programming, DP）提供了一种更具结构化、更通用的方法来解决这类问题。虽然对于这道特定的题目，贪心算法更简单，但理解 DP 解法对于解决更复杂的股票问题（比如有冷冻期、有手续费等）至关重要。

DP 的核心思想是**通过定义状态，并找出状态之间的转移关系，来系统地求解问题**。

---

### 动态规划解法详解

#### 第1步：定义状态

在任何一天结束时，我们只可能有两种状态：
1.  **持有股票** (Holding a stock)
2.  **不持有股票** (Not holding a stock / cash in hand)

我们的目标是计算在每一天结束时，处于这两种状态下分别能获得的最大利润。

所以，我们定义两个 DP 数组（或者说一个二维数组）：
*   `dp[i][0]`：表示在第 `i` 天结束时，**不持有**股票的情况下，获得的最大利润。
*   `dp[i][1]`：表示在第 `i` 天结束时，**持有**股票的情况下，获得的最大利润。

(这里的 `i` 是从 0 开始的索引，代表第 `i+1` 天)

#### 第2步：找出状态转移方程

现在，我们需要思考如何从第 `i-1` 天的状态，推导出第 `i` 天的状态。

**对于 `dp[i][0]` (第 `i` 天不持有股票):**
要达到这个状态，有两种可能：
1.  **昨天就不持有股票**：你在第 `i-1` 天结束时就不持有股票 (`dp[i-1][0]`)，今天你选择什么都不做 (rest)。
2.  **昨天持有股票，今天卖掉了**：你在第 `i-1` 天结束时持有股票 (`dp[i-1][1]`)，今天你以 `prices[i]` 的价格把它卖了，从而获利。

我们要取这两种可能中的最大值，所以：
`dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])`

**对于 `dp[i][1]` (第 `i` 天持有股票):**
要达到这个状态，也有两种可能：
1.  **昨天就持有股票**：你在第 `i-1` 天结束时就持有股票 (`dp[i-1][1]`)，今天你选择什么都不做 (hold)。
2.  **昨天不持有股票，今天买入了**：你在第 `i-1` 天结束时没有股票 (`dp[i-1][0]`)，今天你以 `prices[i]` 的价格买入了一股。因为是花钱买入，所以利润要减去成本。

同样，我们要取这两种可能中的最大值：
`dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])`

#### 第3步：确定初始状态（Base Case）

我们需要为第 0 天（第一天）设置初始值。
*   `dp[0][0]`：第一天结束时，不持有股票。我们什么都没做，所以利润是 **0**。
*   `dp[0][1]`：第一天结束时，持有股票。这意味着我们在第一天就以 `prices[0]` 的价格买入了。所以利润（或者说资产净值）是 **-prices**。

#### 第4步：确定最终结果

遍历完所有天数后，我们要求的最大利润肯定是在最后一天结束时，并且我们手上没有股票（因为持有股票意味着一部分资金还没有变现为最终利润）。

所以，最终结果就是 `dp[n-1][0]` (n 是天数)。

---

### 代码实现

#### 版本1：使用 DP 数组 (O(n) 空间复杂度)

```python
from typing import List

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0:
            return 0

        # 创建 DP table
        dp = [[0] * 2 for _ in range(n)]

        # 初始化第一天的状态
        dp[0][0] = 0
        dp[0][1] = -prices[0]

        # 从第二天开始遍历，应用状态转移方程
        for i in range(1, n):
            # 今天不持有 = max(昨天不持有, 昨天持有+今天卖了)
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
            
            # 今天持有 = max(昨天持有, 昨天不持有-今天买了)
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])

        # 最后一天不持有股票的状态就是最大利润
        return dp[n-1][0]

```

#### 版本2：空间优化 (O(1) 空间复杂度)

观察状态转移方程可以发现，计算第 `i` 天的状态，我们**只需要**第 `i-1` 天的信息。所以我们不需要一个完整的 DP 数组，只需要两个变量来记录前一天的状态即可。

```python
from typing import List

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:
            return 0

        # 初始化第一天的状态
        # dp_i_0 代表不持有股票的最大利润 (cash)
        # dp_i_1 代表持有股票的最大利润 (hold)
        cash = 0
        hold = -prices[0]

        # 从第二天开始遍历
        for i in range(1, len(prices)):
            # 暂存 cash，因为计算新的 hold 时需要用到旧的 cash
            prev_cash = cash 
            
            # 更新不持有股票的状态
            cash = max(cash, hold + prices[i])
            
            # 更新持有股票的状态
            hold = max(hold, prev_cash - prices[i])

        # 最终结果一定是手上没有股票的时候利润最大
        return cash
```

### 总结对比

| 特性         | 贪心算法 (Greedy)                                  | 动态规划 (DP)                                  |
| :----------- | :------------------------------------------------- | :--------------------------------------------- |
| **核心思想** | 在每一步都做局部最优选择（只要涨就卖）。           | 通过定义状态和状态转移，系统地构建全局最优解。 |
| **逻辑**     | `profit += max(0, prices[i] - prices[i-1])`        | `dp[i][0] = max(...)`, `dp[i][1] = max(...)`   |
| **直观性**   | 非常直观，易于理解。                               | 更加抽象，但结构化，通用性强。                 |
| **适用性**   | 适用于本题，但不适用于有手续费、冷冻期等复杂变种。 | 是解决所有股票系列问题的通用框架。             |

对于这道题，动态规划有点“杀鸡用牛刀”的感觉，但它为你解决更复杂的问题打下了坚实的基础。