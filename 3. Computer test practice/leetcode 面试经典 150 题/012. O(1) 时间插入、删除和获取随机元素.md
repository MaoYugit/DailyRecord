# [380. O(1) 时间插入、删除和获取随机元素](https://leetcode.cn/problems/insert-delete-getrandom-o1/)

实现`RandomizedSet` 类：

- `RandomizedSet()` 初始化 `RandomizedSet` 对象
- `bool insert(int val)` 当元素 `val` 不存在时，向集合中插入该项，并返回 `true` ；否则，返回 `false` 。
- `bool remove(int val)` 当元素 `val` 存在时，从集合中移除该项，并返回 `true` ；否则，返回 `false` 。
- `int getRandom()` 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 **相同的概率** 被返回。

你必须实现类的所有函数，并满足每个函数的 **平均** 时间复杂度为 `O(1)` 。

 

**示例：**

```
输入
["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]
[[], [1], [2], [2], [], [1], [2], []]
输出
[null, true, false, true, 2, true, false, 2]

解释
RandomizedSet randomizedSet = new RandomizedSet();
randomizedSet.insert(1); // 向集合中插入 1 。返回 true 表示 1 被成功地插入。
randomizedSet.remove(2); // 返回 false ，表示集合中不存在 2 。
randomizedSet.insert(2); // 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。
randomizedSet.getRandom(); // getRandom 应随机返回 1 或 2 。
randomizedSet.remove(1); // 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。
randomizedSet.insert(2); // 2 已在集合中，所以返回 false 。
randomizedSet.getRandom(); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。
```

 

**提示：**

- `-231 <= val <= 231 - 1`
- 最多调用 `insert`、`remove` 和 `getRandom` 函数 `2 * ``105` 次
- 在调用 `getRandom` 方法时，数据结构中 **至少存在一个** 元素。



### 题解：

看起来好麻烦，好难，不敢看了。这题我肯定不会写。仔细看一眼题目，题目都看不懂。Gemini启动！

好的，别怕！这道题看起来确实有点唬人，特别是“O(1) 时间复杂度”这个要求。但别担心，我们一步一步把它拆解开，你会发现它其实是一个非常巧妙的设计，理解了之后就会觉得豁然开朗。

这道题的核心难点在于，我们需要一种数据结构，它既能像哈希表（在 Python 中是字典 `dict`）那样快速插入、删除和查找，又能像数组那样根据下标快速随机访问。

*   **哈希表 (Dictionary)**: 插入、删除、查找一个元素的平均时间复杂度都是 O(1)。但它没法“随机”获取一个元素，因为它内部不是连续存储的。
*   **数组 (List)**: 可以通过下标 `array[i]` 在 O(1) 的时间内获取元素，所以实现 `getRandom` 非常简单。但是，删除一个元素（非末尾元素）的平均时间复杂度是 O(n)，因为需要移动之后的所有元素来填补空位。

怎么办呢？我们可以把这两种结构结合起来，取长补短！

### 核心思路：哈希表 + 动态数组

我们将使用一个动态数组（在 Python 中就是列表 `list`）来存储集合中的元素，再用一个哈希表（字典 `dict`）来记录每个元素在数组中的索引位置。

*   `self.nums`: 一个列表，用来存放我们插入的数字。
*   `self.val_to_index`: 一个字典，键 (key) 是插入的数字，值 (value) 是这个数字在 `self.nums` 列表中的索引。

这样，我们就能：
*   通过字典，O(1) 判断一个元素是否存在。
*   通过列表，O(1) 根据索引获取一个元素，从而实现 `getRandom`。

现在，我们来看看每个操作如何实现 O(1) 复杂度。

---

### 各个函数的实现方法

#### 1. `insert(val)`: 插入元素

这个操作比较简单：
1.  先用字典 `val_to_index` 检查 `val` 是否已经存在。如果存在，直接返回 `False`。
2.  如果不存在：
    *   将 `val` 添加到列表 `self.nums` 的末尾。
    *   在字典 `val_to_index` 中记录 `val` 的新位置，也就是当前列表的长度减 1 (`len(self.nums) - 1`)。
    *   返回 `True`。

由于列表的 `append` 操作是 O(1)，字典的插入也是 O(1)，所以整个 `insert` 操作就是 O(1) 的。

#### 2. `getRandom()`: 随机获取元素

这个操作更简单：
1.  `self.nums` 列表里存储了所有元素。
2.  我们只需要从 `0` 到 `len(self.nums) - 1` 这个范围内随机生成一个索引 `i`。
3.  返回 `self.nums[i]` 即可。

Python 的 `random.choice()` 函数可以直接帮我们完成这件事，它的时间复杂度也是 O(1)。

#### 3. `remove(val)`: 删除元素（最巧妙的部分！）

这是这道题最关键、最巧妙的地方。如果直接从列表中删除 `val`，会导致 O(n) 的时间复杂度。如何做到 O(1) 呢？

**核心技巧：用列表最后一个元素覆盖要删除的元素，然后删除最后一个元素。**

步骤如下：
1.  先用字典 `val_to_index` 检查 `val` 是否存在。如果不存在，直接返回 `False`。
2.  如果存在：
    *   从字典中获取 `val` 的索引，记为 `index`。
    *   获取列表中最后一个元素，记为 `last_val`。
    *   **关键一步**：将 `last_val` 放到 `index` 的位置上，即 `self.nums[index] = last_val`。
    *   **同步更新字典**：`last_val` 的位置变了，所以要在字典中更新它的索引为 `index`，即 `self.val_to_index[last_val] = index`。
    *   现在，原来要删除的 `val` 已经被覆盖掉了，我们可以安全地删除列表的最后一个元素了。执行 `self.nums.pop()`。
    *   最后，从字典中删除 `val`，即 `del self.val_to_index[val]`。
    *   返回 `True`。

通过这个“移花接木”的操作，我们把删除任意位置元素的问题，转化为了删除列表最后一个元素的问题。列表的 `pop()` 操作是 O(1)，字典的查找和删除也是 O(1)，所以整个 `remove` 操作的平均时间复杂度也是 O(1)！

---

### Python 代码实现

下面是完整的 Python 代码，加上了详细的注释，希望能帮助你彻底理解。

```python
import random

class RandomizedSet:

    def __init__(self):
        """
        初始化数据结构。
        self.nums: 一个列表，用于存储元素，实现 O(1) 的随机访问。
        self.val_to_index: 一个字典，用于存储每个元素及其在列表中的索引，实现 O(1) 的插入、删除和查找。
        """
        self.nums = []
        self.val_to_index = {}

    def insert(self, val: int) -> bool:
        """
        当 val 不存在时，插入一个元素。
        """
        # 如果 val 已经存在，直接返回 False
        if val in self.val_to_index:
            return False
        
        # 将 val 的索引记录在字典中，索引就是当前列表的长度
        self.val_to_index[val] = len(self.nums)
        # 将 val 添加到列表末尾
        self.nums.append(val)
        return True

    def remove(self, val: int) -> bool:
        """
        当 val 存在时，移除该元素。
        """
        # 如果 val 不存在，直接返回 False
        if val not in self.val_to_index:
            return False
        
        # 获取要删除元素的索引
        index = self.val_to_index[val]
        # 获取列表最后一个元素的值
        last_val = self.nums[-1]
        
        # --- 这是最核心的步骤 ---
        # 1. 将最后一个元素移动到要删除元素的位置
        self.nums[index] = last_val
        # 2. 更新最后一个元素的索引信息
        self.val_to_index[last_val] = index
        
        # 3. 从列表中移除最后一个元素（现在它是重复的）
        self.nums.pop()
        # 4. 从字典中删除 val
        del self.val_to_index[val]
        
        return True

    def getRandom(self) -> int:
        """
        从集合中随机获取一个元素。
        """
        # random.choice 可以从一个非空序列中随机返回一个元素
        return random.choice(self.nums)


# 示例用法:
# obj = RandomizedSet()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.getRandom()
```

### 总结一下

你看，通过 **数组 + 哈希表** 的组合，我们巧妙地解决了所有问题：

| 操作        | 使用的数据结构 | 如何实现 O(1)                                             |
| :---------- | :------------- | :-------------------------------------------------------- |
| `insert`    | 字典 + 列表    | 字典判断存在性，列表 `append` 添加。                      |
| `remove`    | 字典 + 列表    | 用列表最后一个元素覆盖要删除的元素，再 `pop()` 最后一个。 |
| `getRandom` | 列表           | 直接从列表中随机选择一个元素。                            |

这道题是一个非常经典的面试题，因为它考察了你对不同数据结构特性的理解以及组合运用它们来解决问题的能力。现在再看这道题，是不是感觉清晰多了？
