# [125. 验证回文串](https://leetcode.cn/problems/valid-palindrome/)

如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 **回文串** 。

字母和数字都属于字母数字字符。

给你一个字符串 `s`，如果它是 **回文串** ，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

```
输入: s = "A man, a plan, a canal: Panama"
输出：true
解释："amanaplanacanalpanama" 是回文串。
```

**示例 2：**

```
输入：s = "race a car"
输出：false
解释："raceacar" 不是回文串。
```

**示例 3：**

```
输入：s = " "
输出：true
解释：在移除非字母数字字符之后，s 是一个空字符串 "" 。
由于空字符串正着反着读都一样，所以是回文串。
```

 

**提示：**

- `1 <= s.length <= 2 * 105`
- `s` 仅由可打印的 ASCII 字符组成



### 题解：

这题一看就很容易的啦！直接去除所有非字母字符，然后正反一对比不就可以了。

**错啦！**

**反思：**想当然认为回文字符串只有字母，但是题中要求有字母和数字！

代码：

```python
class Solution:
    def isPalindrome(self, s: str) -> bool:
        new_s = ""
        reverse_s = ""
        for i in s:
            if i.isalpha() or i.isdecimal():
                new_s += i.lower()
        if len(new_s) == 1:
            return True
        for j in new_s:
            reverse_s = j + reverse_s
        return reverse_s == new_s
```



但是这个代码也太丑陋了吧！有没有什么好的办法呢？

**Gemini！启动！**

好的，Gemini 已启动！

你提供的解法思路完全正确，并且成功地解决了问题，这非常棒！自己动手实现字符串反转也展现了你对基本操作的理解。

不过，正如你所感觉到的，这段代码确实有很大的优化空间，可以<strong>让它变得更简洁、更高效，也更符合 Python 的风格 (Pythonic)</strong>。

接下来，我们来分析并提供几种更优雅的解决方案。

### 你的代码可优化点分析

1.  **过滤条件**：`i.isalpha() or i.isdecimal()` 是对的，但 Python 提供了一个更方便的方法 `isalnum()`，它可以同时检查一个字符是否为**字母或数字**。
2.  **字符串拼接**：在循环中使用 `new_s += i.lower()` 来构建新字符串，在 Python 中效率不高。因为字符串是不可变对象，每次 `+=` 操作都会创建一个新的字符串对象并进行一次拷贝。当字符串很长时，这会造成不必要的性能开销。
3.  **字符串反转**：手动循环创建 `reverse_s` 也是可以的，但 Python 提供了极其简洁的**切片**语法 `[::-1]` 来完成反转，这是所有 Python 开发者都应掌握的技巧。
4.  **特殊情况处理**：`if len(new_s) == 1: return True` 这行代码其实是多余的。因为一个长度为 1 的字符串，它和它的反转字符串一定是相等的，后续的比较逻辑 `reverse_s == new_s` 已经包含了这种情况。

---

### 方案一：列表推导式 + 字符串切片 (简洁直观)

这是最能体现 Python 简洁之美的解法。我们可以用一行代码完成“过滤”和“转小写”这两步，然后用切片来判断。

**思路：**
1.  使用列表推导式或生成器表达式，遍历原始字符串 `s`。
2.  在遍历时，使用 `c.isalnum()` 作为条件进行过滤，只保留字母和数字。
3.  将过滤后的字符 `c` 转换为小写 `c.lower()`。
4.  使用 `''.join()` 方法将所有处理过的字符重新组合成一个新字符串。
5.  比较新字符串 `sgood` 和它的反转 `sgood[::-1]` 是否相等。

**代码：**

```python
class Solution:
    def isPalindrome(self, s: str) -> bool:
        # 使用生成器表达式和 join 方法构建一个只包含字母和数字的小写字符串
        # 这种方式比在循环里用 '+' 拼接字符串效率高得多
        filtered_chars = (c.lower() for c in s if c.isalnum())
        sgood = "".join(filtered_chars)
        
        # 使用切片 [::-1] 直接得到反转后的字符串，并进行比较
        return sgood == sgood[::-1]
```
这个版本清晰、高效，并且充分利用了 Python 的语言特性，是面试中非常受欢迎的写法。

---

### 方案二：双指针 (最高效)

这个方法在**空间复杂度**上最优，因为它不需要创建任何新的字符串来存储过滤后的结果，而是直接在原始字符串上进行操作。

**思路：**
1.  初始化两个指针，`left` 指向字符串的开头，`right` 指向字符串的结尾。
2.  将两个指针向中间移动，直到它们相遇。
3.  在移动过程中：
    *   如果 `left` 指向的字符不是字母或数字，就跳过它（`left += 1`）。
    *   如果 `right` 指向的字符不是字母或数字，也跳过它（`right -= 1`）。
    *   如果两个指针都指向了字母或数字，就比较它们（忽略大小写）。如果不相等，直接返回 `False`。
    *   如果相等，则将两个指针同时向中间移动（`left += 1`, `right -= 1`）。
4.  如果循环正常结束（即 `left` 和 `right` 指针相遇或交错），说明所有字符都匹配，返回 `True`。

**代码：**

```python
class Solution:
    def isPalindrome(self, s: str) -> bool:
        left, right = 0, len(s) - 1
        
        while left < right:
            # 从左边找到一个字母或数字
            while left < right and not s[left].isalnum():
                left += 1
            
            # 从右边找到一个字母或数字
            while left < right and not s[right].isalnum():
                right -= 1
            
            # 比较两个字符（忽略大小写）
            if s[left].lower() != s[right].lower():
                return False
            
            # 指针向中间移动
            left += 1
            right -= 1
            
        return True
```

### 总结对比

| 特性           | 你的原始方案              | 方案一 (切片法)           | 方案二 (双指针法)         |
| :------------- | :------------------------ | :------------------------ | :------------------------ |
| **时间复杂度** | O(N)                      | O(N)                      | O(N)                      |
| **空间复杂度** | O(N) (创建了两个新字符串) | O(N) (创建了一个新字符串) | **O(1)** (未使用额外空间) |
| **代码简洁度** | 一般                      | **非常高**                | 较高                      |
| **执行效率**   | 一般                      | 较好                      | **最好**                  |

**给你的建议：**

*   **面试时**：方案一（切片法）通常已经足够好了，它代码简短，易于理解，能快速写出来。方案二（双指针法）则能展示你对算法优化和空间复杂度的深入理解，是更优的解法。
*   **学习上**：两种方法都非常值得掌握！它们代表了解决此类问题的两种不同但都非常有效的思路。

你已经走在正确的路上了，继续保持这种思考和优化的习惯，你的编程能力会越来越强！
