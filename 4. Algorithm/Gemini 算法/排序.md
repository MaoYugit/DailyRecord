### 常见排序算法比较

| 算法名称                  |                           原理简介                           | 时间复杂度 (平均) | 时间复杂度 (最坏) | 时间复杂度 (最好) | 空间复杂度 | 稳定性 |
| :------------------------ | :----------------------------------------------------------: | :---------------- | :---------------- | :---------------- | :--------- | :----- |
| **比较类排序**            |                                                              |                   |                   |                   |            |        |
| 冒泡排序 (Bubble Sort)    | 重复地遍历待排序的序列，依次比较两个相邻的元素，如果顺序错误就交换。 | O(n²)             | O(n²)             | O(n)              | O(1)       | 稳定   |
| 选择排序 (Selection Sort) | 首先在未排序序列中找到最小（或最大）元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小（或最大）元素，然后放到已排序序列的末尾。 | O(n²)             | O(n²)             | O(n²)             | O(1)       | 不稳定 |
| 插入排序 (Insertion Sort) | 通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 | O(n²)             | O(n²)             | O(n)              | O(1)       | 稳定   |
| 希尔排序 (Shell Sort)     | 插入排序的一种更高效的改进版本，通过比较相距一定间隔的元素来进行排序，并逐渐减小间隔。 | O(n log n)        | O(n²)             | O(n log n)        | O(1)       | 不稳定 |
| 归并排序 (Merge Sort)     | 采用分治策略，将序列递归地分成两半，直到每个子序列只有一个元素，然后再将这些有序的子序列合并成一个大的有序序列。 | O(n log n)        | O(n log n)        | O(n log n)        | O(n)       | 稳定   |
| 快速排序 (Quick Sort)     | 采用分治策略，选择一个“基准”元素，将序列分成两部分，一部分的所有元素都比基准小，另一部分的所有元素都比基准大，然后对这两部分递归地进行排序。 | O(n log n)        | O(n²)             | O(n log n)        | O(log n)   | 不稳定 |
| 堆排序 (Heap Sort)        | 利用堆这种数据结构所设计的排序算法，将待排序的序列构造成一个大顶堆（或小顶堆），然后将堆顶元素与末尾元素交换，接着调整堆，重复此过程。 | O(n log n)        | O(n log n)        | O(n log n)        | O(1)       | 不稳定 |
| **非比较类排序**          |                                                              |                   |                   |                   |            |        |
| 计数排序 (Counting Sort)  | 核心在于将输入的数据值转化为键存储在额外开辟的数组空间中，适用于数据范围不大的情况。 | O(n + k)          | O(n + k)          | O(n + k)          | O(k)       | 稳定   |
| 桶排序 (Bucket Sort)      |      将数组分到有限数量的桶里，然后对每个桶再分别排序。      | O(n + k)          | O(n²)             | O(n + k)          | O(n + k)   | 稳定   |
| 基数排序 (Radix Sort)     |    将整数按位数切割成不同的数字，然后按每个位数分别比较。    | O(n * k)          | O(n * k)          | O(n * k)          | O(n + k)   | 稳定   |

**术语解释:**

*   **n:** 数据规模，表示待排序的数据量大小。
*   **k:** "桶"的个数，在某些特定的排序算法中（如基数排序、桶排序等），表示分割成的独立的排序区间或类别的数量。
*   **稳定性:** 如果 A 原本在 B 前面，而 A=B，排序之后 A 仍然在 B 的前面，则称该排序算法是稳定的。
*   **时间复杂度:** 定性描述一个算法执行所耗费的时间。
*   **空间复杂度:** 定性描述一个算法执行所需内存的大小。



------



### 1. 冒泡排序 (Bubble Sort)

冒泡排序是一种简单直观的排序算法。 它得名于排序过程中，较小的元素会像“气泡”一样慢慢“浮”到数列的顶端。 因为其简洁性，冒泡排序通常被用作向编程初学者介绍算法概念的入门示例。

#### 工作原理

冒泡排序的核心思想是：重复地遍历待排序的序列，依次比较两个相邻的元素，如果它们的顺序错误（例如，在升序排列中，前一个元素大于后一个元素），就把它们交换过来。 每一轮遍历都会将当前未排序部分中的最大（或最小）元素“冒泡”到序列的末尾。 这个过程会重复进行，直到没有任何一对数字需要比较为止。

**排序步骤（以升序为例）：**

1.  **比较相邻元素**：从序列的第一个元素开始，比较它和下一个元素的大小。
2.  **交换位置**：如果第一个元素比第二个元素大，就交换它们的位置。
3.  **向后移动**：继续向后对每一对相邻的元素进行同样的操作，直到序列的最后一对。这一轮结束后，最大的元素就会被放置在序列的末尾。
4.  **重复过程**：针对除了最后一个元素之外的所有元素，重复以上的步骤。
5.  **持续进行**：持续每一轮对越来越少的元素重复上述步骤，直到整个序列排序完成。

#### 图解示例

假设我们有一个待排序的序列：

**第一轮:**
*   ( **5, 1**, 4, 2, 8 ) → ( **1, 5**, 4, 2, 8 )  (5 > 1, 交换)
*   ( 1, **5, 4**, 2, 8 ) → ( 1, **4, 5**, 2, 8 )  (5 > 4, 交换)
*   ( 1, 4, **5, 2**, 8 ) → ( 1, 4, **2, 5**, 8 )  (5 > 2, 交换)
*   ( 1, 4, 2, **5, 8** ) → ( 1, 4, 2, **5, 8** )  (5 < 8, 不交换)
*   *第一轮结束后，最大的数 8 “冒泡”到了最后。序列变为：*

**第二轮:**
*   ( **1, 4**, 2, 5, 8 ) → ( **1, 4**, 2, 5, 8 )
*   ( 1, **4, 2**, 5, 8 ) → ( 1, **2, 4**, 5, 8 )
*   ( 1, 2, **4, 5**, 8 ) → ( 1, 2, **4, 5**, 8 )
*   *第二轮结束后，第二大的数 5 “冒泡”到了倒数第二位。序列变为：*

**后续轮次** 会继续这个过程，直到整个序列有序。

#### Python 代码实现

下面是一个基础的冒泡排序 Python 实现：

```python
def bubble_sort(arr):
    n = len(arr)
    # 外层循环控制遍历的轮数
    for i in range(n):
        # 内层循环用于比较和交换相邻元素
        # 每一轮都会将最大的元素放到末尾，所以内层循环的范围可以逐渐缩小
        for j in range(0, n - i - 1):
            # 如果前一个元素大于后一个元素，则交换它们
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

# 示例
my_list = [5, 1, 4, 2, 8]
sorted_list = bubble_sort(my_list)
print("排序后的列表:", sorted_list)
# 输出: 排序后的列表: [1, 2, 4, 5, 8]
```

**代码解析:**

*   `bubble_sort(arr)` 函数接受一个列表 `arr` 作为参数。
*   `n` 是列表的长度。
*   外层循环 `for i in range(n)` 控制总共需要进行 `n` 轮遍历。
*   内层循环 `for j in range(0, n - i - 1)` 负责在每一轮中进行相邻元素的比较和交换。 `n - i - 1` 是因为每经过一轮，末尾的 `i` 个元素就已经是有序的了，无需再进行比较。
*   `if arr[j] > arr[j + 1]:` 是比较的核心，如果想实现降序排序，只需将 `>` 改为 `<`。
*   `arr[j], arr[j + 1] = arr[j + 1], arr[j]` 是 Python 中一种简洁的交换两个变量值的方式。

#### 算法分析

*   **时间复杂度**:
    *   **最坏情况**: O(n²)，当待排序序列是完全逆序的时候。
    *   **最好情况**: O(n)，当待排序序列已经是有序的时候，可以通过一个标志位进行优化，如果在一轮遍历中没有发生任何交换，说明序列已经有序，可以提前结束循环。
    *   **平均情况**: O(n²)。
*   **空间复杂度**: O(1)，因为冒泡排序是原地排序，只需要常数级的额外空间。
*   **稳定性**: 冒泡排序是 **稳定** 的排序算法。因为只有当前面的元素大于后面的元素时才会交换，相等的元素不会改变它们的相对位置。



------

 Timsort 算法