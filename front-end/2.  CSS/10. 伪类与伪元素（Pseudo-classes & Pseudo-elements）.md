### **第 10 课：伪类与伪元素（Pseudo-classes & Pseudo-elements）**

在前面的课程中，我们的逻辑是“有什么样的 HTML 标签，就给它什么样的样式”。但伪类和伪元素打破了这个规则。它们允许你**选中并样式化那些不存在于 HTML 标签中的东西**——比如一个元素的特定状态（第一个子元素、鼠标悬停时），甚至是在元素内容之前或之后生成全新的可见内容。

掌握了它们，你就能在保持 HTML 结构整洁的同时，创造出极其丰富和精巧的视觉效果。

#### **核心思想：扩展 CSS 的选择能力**

伪类和伪元素的核心都是**扩展选择器的能力**，让你能选中一些普通选择器无法触及的目标。

**如何区分它们？一个简单的法则：**
*   **伪类 (Pseudo-classes)**: 以**单个冒号 `:`** 开头。它选中了**已经存在的元素**，但这个元素正处于某种**特殊状态**。它像是在问：“这个元素是不是第一个？”，“鼠标是不是在它上面？”
*   **伪元素 (Pseudo-elements)**: 以**双冒号 `::`** 开头（为了兼容旧浏览器，单冒号也行，但双冒号是现代标准）。它会**创造一个不存在于 DOM 中的新元素**，并将其作为选中元素的子元素来添加样式。它像是在说：“在这个元素前面加点东西”，“给这段文字的第一行加点样式”。

---

### **深度剖析 1：伪类 (Pseudo-classes) —— 选中特殊状态的元素**

伪类可以分为几大家族：

#### **a. 动态与用户行为伪类 (Dynamic & User Action)**
这些是你最熟悉的，用于响应用户交互。
*   `:hover`: 鼠标指针悬停在元素上时。
*   `:focus`: 元素获得焦点时（通常用于表单输入框、链接、按钮）。
*   `:active`: 元素被激活时（比如鼠标按下的那一刻）。
*   `:visited`: 只对 `<a>` 标签有效，表示链接已经被访问过。

#### **b. 结构性伪类 (Structural)**
这是最强大的一族，它们根据元素在 DOM 树中的位置和关系来选中元素。
*   `:first-child` / `:last-child`: 选中作为其父元素的第一个/最后一个子元素的那个元素。
*   `:only-child`: 选中作为其父元素唯一子元素的那个元素。
*   `:nth-child(n)`: **神器。** 选中其父元素的第 n 个子元素。
    *   `n` 可以是数字: `:nth-child(3)` (第3个)
    *   `n` 可以是关键字: `:nth-child(odd)` (奇数), `:nth-child(even)` (偶数)
    *   `n` 可以是公式:
        *   `:nth-child(2n)`: 所有偶数 (2, 4, 6...)
        *   `:nth-child(2n+1)`: 所有奇数 (1, 3, 5...)
        *   `:nth-child(n+4)`: 从第 4 个开始的所有元素
        *   `:nth-child(-n+3)`: 前 3 个元素
*   `:nth-of-type(n)`: 与 `:nth-child(n)` 类似，但它只计算**同类型**的兄弟元素。
    *   **区别**：`p:nth-child(1)` 的意思是“如果一个元素的第一个孩子刚好是 p 标签，就选中它”。而 `p:nth-of-type(1)` 的意思是“选中这个容器里的第一个 p 标签，无论它是不是第一个孩子”。
*   `:first-of-type` / `:last-of-type` / `:only-of-type`: 同理。

#### **c. 逻辑性伪类 (Logical)**
它们可以组合其他选择器，创造出更强大的逻辑。
*   `:not(selector)`: **反选伪类**。选中所有不匹配 `selector` 的元素。
    *   `input:not([type="checkbox"])`: 选中所有不是复选框的 input。
    *   `a:not(.external-link)`: 选中所有不带 `.external-link` 类的链接。
*   `:is(selector1, selector2, ...)`: **匹配列表中的任意一个**。主要用于简化复杂的选择器。
    *   旧写法: `.header a:hover, .footer a:hover`
    *   新写法: `:is(.header, .footer) a:hover`
*   `:where(selector1, selector2, ...)`: 和 `:is()` 功能完全一样，但它的**优先级（Specificity）永远是 0**！这在编写可被轻松覆盖的基础库样式时非常有用。
*   `:has(selector)`: **父选择器（革命性）**！选中一个元素，条件是它**包含**匹配 `selector` 的后代。
    *   `div:has(p)`: 选中所有内部含有 `<p>` 标签的 `<div>`。
    *   `a:has(> img)`: 选中所有直接子元素是 `<img>` 的 `<a>` 标签。

---

### **深度剖析 2：伪元素 (Pseudo-elements) —— 创造不存在的元素**

#### **a. `::before` 和 `::after` —— 最强大的伪元素**
这两个伪元素会在选中元素的**内容（content）**之前或之后，插入一个生成的、行内（`inline`）级别的“幽灵”元素。

**使用它们的必要条件**：你必须在 CSS 中为其提供 `content` 属性，即使内容是空的（`content: '';`）。

**高级应用：**
1.  **装饰性内容**:
    ```css
    a.external-link::after {
      content: ' ↗'; /* 在外部链接后自动添加一个箭头 */
    }
    blockquote::before {
      content: '“'; /* 在引用块前添加引号 */
      font-size: 3em;
    }
    ```
2.  **清除浮动 (`The Clearfix Hack`)**: 这是它们最经典的应用之一。
    
    ```css
    .clearfix::after {
      content: "";
      display: block;
      clear: both;
    }
    ```    在一个浮动元素的父容器上应用 `.clearfix` 类，就可以在不增加空 `div` 的情况下，闭合浮动，让父容器恢复正确的高度。
3.  **自定义列表项标记**:
    ```css
    ul { list-style: none; }
    li::before {
      content: '✓ ';
      color: green;
    }
    ```
4.  **创建图形和覆盖层**: 因为 `::before` 和 `::after` 可以被绝对定位，所以它们非常适合用来创建纯 CSS 图形或覆盖层。
    ```css
    .tooltip-container { position: relative; }
    .tooltip-container:hover::before {
      content: 'This is a tooltip';
      position: absolute;
      bottom: 100%; /* 定位到元素上方 */
      left: 50%;
      transform: translateX(-50%);
      /* ... 其他 tooltip 样式 ... */
    }
    ```

#### **b. 其他实用伪元素**
*   `::first-line`: 选中块级元素的第一行文本。
*   `::first-letter`: 选中块级元素的第一个字母（常用于创建首字下沉效果）。
*   `::selection`: 选中用户用鼠标高亮选择的文本部分。
*   `::placeholder`: 选中表单输入框中的占位符文本。
*   `::marker`: 选中列表项（`<li>`）的标记（比如小圆点或数字）。

---

### **面试焦点**

**面试官问：“`::before`/`::after` 和 `::first-letter` 的区别是什么？”**

> **你的回答**：“最核心的区别在于它们的作用对象和能力。`::first-letter` 是一个**文本伪元素**，它只能选中一个已经存在的块级元素中的第一个字母，并对其应用文本相关的样式（如 `font-size`, `color`, `float`）。而 `::before` 和 `::after` 是**内容生成伪元素**，它们会**创造一个全新的、不存在于 DOM 中的盒模型**。这个新创建的“伪”元素可以拥有自己的 `width`, `height`, `background`, `position` 等所有盒模型属性，因此它的能力远比 `::first-letter` 强大，可以用来做装饰、清除浮动、创建图形等各种复杂的效果。”

**面试官问：“`:nth-child` 和 `:nth-of-type` 的区别是什么？”**

> **你的回答**：“它们都是结构性伪类，但计数的**上下文**不同。
>
> *   `:nth-child(n)` 在计数时，会把**所有类型的兄弟元素**都算进去。它选择的逻辑是‘找到第 n 个孩子，然后检查它是否匹配我指定的选择器’。
> *   `:nth-of-type(n)` 在计数时，只会计算**指定类型的兄弟元素**。它的选择逻辑是‘在所有兄弟元素中，找到第 n 个我这种类型的元素’。
>
> 举个例子，如果一个 `div` 里有 `<h1>`, `<p>`, `<p>`，那么 `p:nth-child(2)` 会选中第一个 `<p>`，因为它是 `div` 的第 2 个孩子。而 `p:nth-of-type(2)` 会选中第二个 `<p>`，因为它在所有 `<p>` 标签中排第二。当你不确定兄弟元素的具体类型和顺序时，`:nth-of-type` 通常是更安全、更可靠的选择。”

---

### **实战任务**

我们来创建一个非常时髦的、带自定义样式的引用块（`Blockquote`）。

**HTML 结构:**
```html
<blockquote>
  <p>The ability to simplify means to eliminate the unnecessary so that the necessary may speak.</p>
  <footer>— Hans Hofmann</footer>
</blockquote>
```

**你的任务：**
1.  **基础样式**: 给 `<blockquote>` 一些基础样式，比如背景色、边框、内边距和字体样式。
2.  **创建巨大的装饰性引号**:
    *   使用 `::before` 伪元素，在 `<blockquote>` 的内容**之前**生成一个巨大的左引号 `“`。
    *   将这个伪元素**绝对定位**到 `<blockquote>` 的左上角（你可能需要给 `<blockquote>` 设置 `position: relative`）。
    *   给它设置一个非常大的 `font-size` 和一个较低的 `opacity`，让它看起来像一个精致的背景装饰。
3.  **为列表中的特定项添加样式**:
    *   假设页面上有很多 `<blockquote>`，现在你需要**只为奇数位置的 `<blockquote>`** 添加一个不同的背景色或边框颜色。请使用 `:nth-of-type` 来实现。
4.  **(挑战)**: 我们不希望引用块里的 `<footer>` 元素也应用 `<blockquote>` 的主字体样式（比如斜体）。请使用 `:not()` 伪类，为 `<blockquote>` 里的**所有直接子元素，除了 `<footer>` 之外**，设置一个特定的样式（比如 `font-style: italic;`）。

这个任务将让你综合运用 `::before` 的绝对定位装饰技巧，以及 `:nth-of-type` 和 `:not()` 这两个强大的结构性/逻辑性伪类。
