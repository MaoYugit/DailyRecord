# [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置在下标 0。

每个元素 `nums[i]` 表示从索引 `i` 向后跳转的最大长度。换句话说，如果你在索引 `i` 处，你可以跳转到任意 `(i + j)` 处：

- `0 <= j <= nums[i]` 且
- `i + j < n`

返回到达 `n - 1` 的最小跳跃次数。测试用例保证可以到达 `n - 1`。

 

**示例 1:**

```bash
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

**示例 2:**

```bash
输入: nums = [2,3,0,1,4]
输出: 2
```





### 题解：

这题一看就知道蛮简单！因为我刚刚做完跳跃游戏第一题。但是好像有点不对劲！

我目前的思路是：记录下每个能到达的点，然后进行处理。我们先从前往后推理：如果我们每一次都跳到离当前位置最远的可达点，是不是就是最优解？好像不是：假设当前可以跳到倒数第五个，但是倒数第五个需要一步一步跳到最后一个，这样总共就需要五步到达终点，如果我们最开始只跳到第一个，而第一个刚好可以一步跳到重点，那我们只需要两步就行了。从后往前推，如果是按照相同的思路的话，结果是一样的，因为本质上我们到达最后一个点，把那一边看作最后一个点都是一样的。

那到底该怎么办？

潜意识里还是觉得应该从后往前来推导。我们慢慢来：

**倒数第一个**：已经到终点了，所以需要的步数为0

**倒数第二个**：如果可以到达终点的话，所需要的步数为1

倒数第三个：如果可以到达终点的话，分为几种情况：如果自己本身可以到达终点，那么需要的步数是1，如果本身不可以到达的话，那需要借助倒数第二个，如果倒数第二个可以到达的话，那就是2步；

**总结一下**：如果可以直接到达，那就是一步；如果不可以直接到达，那就筛选出前面可以到达的点中可以用最短步数到达的点，加上1就是最终需要花费的步数。

看起来这个思路是可以的，只需要记录每个点到达需要的最短步数就好了。但是该怎么用代码实现呢？感觉用字典存储相关信息会比较便捷，但是我不太会，不过熟能生巧，这一个代码就用字典存储吧。

```python

```





