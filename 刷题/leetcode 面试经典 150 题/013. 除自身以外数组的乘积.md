# [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积 。

题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。

请 **不要使用除法，**且在 `O(n)` 时间复杂度内完成此题。

 

**示例 1:**

```
输入: nums = [1,2,3,4]
输出: [24,12,8,6]
```

**示例 2:**

```
输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
```

 

**提示：**

- `2 <= nums.length <= 105`
- `-30 <= nums[i] <= 30`
- 输入 **保证** 数组 `answer[i]` 在 **32 位** 整数范围内

 

**进阶：**你可以在 `O(1)` 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 **不被视为** 额外空间。）



### 题解：

中等题，一眼暴力解法，试试看。先把整个数组的乘积算出来`answer_all`，然后每一个`answer`元素等于`answer_all / answer[i]`(你说不用除法就不用除法吗？我偏要用！)

```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        answer = []
        answer_all = 1
        for i in range(len(nums)):
            answer_all *= nums[i]
        for j in range(len(nums)):
            answer.append(answer_all / nums[j] )
        return answer 
```

好好好，报错了。因为有的元素可能是0。不能除以0。那就可以转换成有0和没0的情况。没有0直接上面的算法就可以了，有一个0，那有0的位置是其余地方的乘积，其余地方都是0；有两个或两个以上0，则整个`answer`都是0.

```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        answer = []
        answer_all = 1
        count = 0
        zero_list = []
        for i in range(len(nums)): 
            if nums[i] == 0:
                count += 1
                zero_list.append(i)
        if count == 0:
            for i in range(len(nums)):
                answer_all *= nums[i]
            for j in range(len(nums)):
                answer.append(int(answer_all / nums[j]) )
        if count >= 2:
            for i in range(len(nums)):
                answer.append(0)
        if count == 1:
            nums[zero_list[0]] = 1
            for i in range(len(nums)):
                answer_all *= nums[i]
            for i in range(len(nums)):
                if i != zero_list[0]:
                    answer.append(0)
                else:
                    answer.append(answer_all)

        return answer 
```

过啦！不过好像过得并不光彩。代码很长，判断很多，并且不符合题目的意思，人家都说了不能用除法，这样会扣分，甚至不给分！

但是还有什么其他方法吗？

**Gemini！启动！**

哈哈哈，你做得非常好！能够自己思考出处理 0 的各种情况，并用除法写出一个能通过的版本，这本身就很厉害了。你的代码逻辑清晰地覆盖了：没有0，一个0，以及多个0的情况。

不过，就像你自己说的，这个解法违反了题目中“**不要使用除法**”的核心要求，而且代码因为分支判断显得有些复杂。在面试中，面试官肯定会追问：“如果不让你用除法，该怎么做？”

这道题的精髓，就在于一种非常巧妙的、不使用除法的 O(n) 解法。

### 核心思想：左右乘积列表

让我们换个角度思考 `answer[i]` 的构成。`answer[i]` 是除了 `nums[i]` 之外所有元素的乘积，这可以被拆解为两部分：

1.  `nums[i]` **左边**所有元素的乘积。
2.  `nums[i]` **右边**所有元素的乘积。

那么，`answer[i] = (i 左侧所有元素的乘积) * (i 右侧所有元素的乘积)`。

我们可以通过两次遍历来计算这两部分的乘积。

---

### 方法一：使用两个辅助数组 (O(n) 空间复杂度)

这是最容易理解的思路。我们创建两个数组，一个存左侧乘积，一个存右侧乘积。

1.  **创建左侧乘积数组 `L`**:
    *   `L[i]` 表示 `nums` 数组中索引 `i` 左侧所有元素的乘积。
    *   `L[0]` 应该是 1，因为索引 0 左边没有元素。
    *   然后我们从左到右遍历 `nums` 来构建 `L`：`L[i] = L[i-1] * nums[i-1]`。

2.  **创建右侧乘积数组 `R`**:
    *   `R[i]` 表示 `nums` 数组中索引 `i` 右侧所有元素的乘积。
    *   `R[n-1]` (最后一个元素) 应该是 1，因为它右边没有元素。
    *   然后我们从右到左遍历 `nums` 来构建 `R`：`R[i] = R[i+1] * nums[i+1]`。

3.  **计算最终结果**:
    *   最后，我们遍历一次，将 `L` 和 `R` 对应位置的数相乘即可：`answer[i] = L[i] * R[i]`。

**用 `nums = [1, 2, 3, 4]` 举个例子:**

*   **第一次遍历（从左到右，计算 `L`）**:
    *   `L[0] = 1`
    *   `L[1] = nums[0] = 1`
    *   `L[2] = nums[0] * nums[1] = 1 * 2 = 2`
    *   `L[3] = nums[0] * nums[1] * nums[2] = 1 * 2 * 3 = 6`
    *   所以 `L = [1, 1, 2, 6]`

*   **第二次遍历（从右到左，计算 `R`）**:
    *   `R[3] = 1`
    *   `R[2] = nums[3] = 4`
    *   `R[1] = nums[3] * nums[2] = 4 * 3 = 12`
    *   `R[0] = nums[3] * nums[2] * nums[1] = 4 * 3 * 2 = 24`
    *   所以 `R = [24, 12, 4, 1]`

*   **第三次遍历（合并结果）**:
    *   `answer[0] = L[0] * R[0] = 1 * 24 = 24`
    *   `answer[1] = L[1] * R[1] = 1 * 12 = 12`
    *   `answer[2] = L[2] * R[2] = 2 * 4 = 8`
    *   `answer[3] = L[3] * R[3] = 6 * 1 = 6`
    *   最终得到 `answer = [24, 12, 8, 6]`，正确！

这个方法完全没有用除法，并且每个步骤都是一次 O(n) 的遍历，总时间复杂度是 O(n)。但它使用了两个额外的数组，空间复杂度是 O(n)。

```python
from typing import List

class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        
        # 1. 初始化 L, R 和 answer 数组
        L = [0] * n  # 存储左侧乘积
        R = [0] * n  # 存储右侧乘积
        answer = [0] * n
        
        # 2. 计算左侧乘积数组 L
        # L[0] 的左边没有元素，所以乘积为 1
        L[0] = 1
        for i in range(1, n):
            # L[i] 等于它左边一个位置的左侧乘积 L[i-1] 乘以 nums[i-1]
            L[i] = L[i-1] * nums[i-1]
            
        # 3. 计算右侧乘积数组 R
        # R[n-1] 的右边没有元素，所以乘积为 1
        R[n-1] = 1
        # 注意这里的遍历范围，从倒数第二个元素开始，直到第一个元素
        for i in range(n - 2, -1, -1):
            # R[i] 等于它右边一个位置的右侧乘积 R[i+1] 乘以 nums[i+1]
            R[i] = R[i+1] * nums[i+1]
            
        # 4. 计算最终结果
        # answer[i] 是左侧乘积和右侧乘积的积
        for i in range(n):
            answer[i] = L[i] * R[i]
            
        return answer

# 示例:
# nums = [1, 2, 3, 4]
# 第一次循环后: L = [1, 1, 2, 6]
# 第二次循环后: R = [24, 12, 4, 1]
# 第三次循环后: answer = [1*24, 1*12, 2*4, 6*1] = [24, 12, 8, 6]
```



---

### 方法二：空间复杂度优化 (O(1) 额外空间)

这正是题目“进阶”部分的要求。我们能不能不用额外的 `L` 和 `R` 数组呢？
答案是可以的！我们可以直接在输出数组 `answer` 上进行操作。

1.  **第一遍（从左到右）：**
    *   我们先让 `answer` 数组扮演上面 `L` 数组的角色。
    *   初始化 `answer[0] = 1`。
    *   然后从左到右遍历，计算出每个位置的左侧乘积，并存入 `answer` 中。`answer[i] = answer[i-1] * nums[i-1]`。
    *   这次遍历结束后，`answer` 数组里存的就是所有左侧乘积。

2.  **第二遍（从右到左）：**
    *   我们需要一个变量 `R` 来动态记录右侧乘积。初始化 `R = 1`。
    *   然后从右到左遍历数组（从 `n-1` 到 `0`）。
    *   对于每个位置 `i`，`answer[i]` 当前存的是左侧乘积，我们再乘上右侧乘积 `R`，就得到了最终结果。即 `answer[i] = answer[i] * R`。
    *   更新 `R`，为下一个位置（左边一个）做准备。更新方式为 `R = R * nums[i]`。

**还是用 `nums = [1, 2, 3, 4]` 举个例子:**

*   **初始化**:
    *   `n = 4`
    *   `answer = [0, 0, 0, 0]` (假设)

*   **第一次遍历（从左到右，计算左侧乘积）**:
    *   `answer[0] = 1`
    *   `i = 1`: `answer[1] = answer[0] * nums[0] = 1 * 1 = 1`
    *   `i = 2`: `answer[2] = answer[1] * nums[1] = 1 * 2 = 2`
    *   `i = 3`: `answer[3] = answer[2] * nums[2] = 2 * 3 = 6`
    *   此时，`answer = [1, 1, 2, 6]` (这正是我们之前算的 `L` 数组)

*   **第二次遍历（从右到左，乘以右侧乘积）**:
    *   初始化右侧乘积变量 `R = 1`
    *   `i = 3`: `answer[3] = answer[3] * R = 6 * 1 = 6`。然后更新 `R = R * nums[3] = 1 * 4 = 4`。
    *   `i = 2`: `answer[2] = answer[2] * R = 2 * 4 = 8`。然后更新 `R = R * nums[2] = 4 * 3 = 12`。
    *   `i = 1`: `answer[1] = answer[1] * R = 1 * 12 = 12`。然后更新 `R = R * nums[1] = 12 * 2 = 24`。
    *   `i = 0`: `answer[0] = answer[0] * R = 1 * 24 = 24`。然后更新 `R = R * nums[0] = 24 * 1 = 24`。

*   循环结束，最终 `answer = [24, 12, 8, 6]`。完美！

### Python 代码实现 (O(1) 额外空间)

```python
from typing import List

class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        # 题目说了输出数组不被视为额外空间，所以我们可以直接用它
        answer = [0] * n
        
        # 第一步：计算前缀乘积
        # answer[i] 先存储 nums[i] 左侧所有元素的乘积
        # 对于第一个元素，其左侧没有元素，所以是 1
        answer[0] = 1
        for i in range(1, n):
            answer[i] = answer[i-1] * nums[i-1]
            
        # 第二步：计算后缀乘积并与前缀乘积相乘
        # R 用来存储右侧所有元素的乘积，初始为 1
        R = 1
        # 从右向左遍历
        for i in range(n - 1, -1, -1):
            # 对于索引 i，answer[i] 已经包含了其左侧的乘积
            # 我们再乘以其右侧的乘积 R
            answer[i] = answer[i] * R
            # 更新 R，为下一个元素（左边那个）做准备
            R *= nums[i]
            
        return answer

```

这个解法不仅满足了“**不用除法**”和“**O(n)时间复杂度**”的要求，还通过巧妙的两次遍历满足了“**O(1)额外空间复杂度**”的进阶要求，是一个非常漂亮且经典的算法。现在是不是觉得它比处理各种0的情况要优雅多了？

大佬不愧是大佬啊！如雷贯耳，如有神助，如痴如醉，如芒在背， 如听仙乐耳暂明啊
