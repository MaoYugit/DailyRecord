# [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**示例 2：**

```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```

 

**提示：**

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 105`



### 题解：

这题一看就知道，不容易吧。我目前的思路是从后往前依次看前一个数字可不可以到达最后面的那个，但是思路不清晰。理一下：

**倒数第二个：**只要大于0就可以到达最后一个；

**倒数第三个:**有两种情况，**如果**倒数第一个大于0，那么倒数第三个也大于0就好了，**否则**就应该大于1（因为要跳两次才能跳到最后一个）；

**倒数第四个:**也有两种情况：如果倒数第三个能到达，那么只要大于o就可以了，如果倒数第三个不能到达，那么就要大于距离前一个能到达的距离就好了。	

那么我们一直这样循环到最后一个不久可以得到最后一个可不可以到达重点了。

总结一下就是：如果当前能跳到下一个能到达的地方，那当前就能到达。

但是怎么用代码实现呢？

我们可以用`can`来记录最近一个能到达终点的下标然后依次替换`can`，看起来很容易实现。

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        # 最后一个已经在终点了，所以肯定能到
        can = len(nums) -1
        for i in range(len(nums)-2, -1, -1):
            if nums[i] >= can - i:
                can = i
        return True if can == 0 else False
```

过啦！妈的我真的是一个天才。