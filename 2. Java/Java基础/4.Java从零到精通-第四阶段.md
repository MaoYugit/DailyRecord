### **第四阶段：Java生态与实战 (The Ecosystem & Real World)**



<div >
  <span>
    <a href="./3.Java从零到精通-第三阶段.md">
      ← 上一篇：第三阶段
    </a>
  </span>
 </div>



### **第14章：项目管理工具 (Maven)**

#### **14.1 为什么需要Maven？（我们遇到了什么新问题？）**

到目前为止，我们写的代码都是“自给自足”的。但真实的项目，就像造汽车，我们不可能从头制造每一个螺丝钉和轮胎，而是会去采购别人已经造好的、高质量的零件。

在Java世界里，这些“零件”就是**库 (Library)**，通常以 **JAR (Java Archive) 文件**的形式存在。比如，你想处理JSON数据，你不需要自己写一个复杂的解析器，而是可以直接使用Google开发的`Gson`库。

这时，你会遇到三个巨大的问题：

1.  **依赖地狱 (Dependency Hell):** 你想用`Gson.jar`。但`Gson.jar`可能又依赖于另一个`Log.jar`。你手动下载了`Gson.jar`和`Log.jar`，却发现它们和你项目里已有的另一个库版本冲突了。当项目变大，依赖关系错综复杂时，手动管理这些JAR包会成为一场噩梦。
2.  **项目结构不统一:** 你把JAR包放在`lib`文件夹，你的同事可能放在`libs`文件夹。你把源码放在`src`，他放在`source`。这导致项目交接和协作变得异常困难。
3.  **构建过程不一致:** 你在IDEA里点一下按钮就能运行，但你的同事可能用的是另一个编辑器。如何保证项目在任何环境下都能以同一种标准化的方式被编译、测试、打包？

**Maven** 就是为了解决以上所有问题而生的！

#### **14.2 Maven是什么？**

**Maven** 是一个强大的**项目管理和构建自动化工具**。它为你做了三件核心大事：

1.  **依赖管理 (Dependency Management):**
    *   你只需要在一个名为 `pom.xml` 的配置文件中，像写购物清单一样，声明你需要哪些“零件”（库）。
    *   Maven会自动从一个中央仓库（像一个巨大的网上超市）下载你需要的库，以及这些库所依赖的所有其他库，并帮你管理好版本冲突问题。

2.  **标准化项目结构 (Standardized Project Structure):**
    *   Maven规定了一套所有人都遵循的目录结构。只要你用Maven，你的项目结构就和全世界所有用Maven的Java项目一样，清爽、标准。
    *   `src/main/java`: 存放你的主程序源代码 (.java文件)。
    *   `src/main/resources`: 存放主程序需要的配置文件 (.properties, .xml等)。
    *   `src/test/java`: 存放你的测试代码。

3.  **构建生命周期 (Build Lifecycle):**
    *   Maven定义了一套标准化的项目构建流程，如：`清理(clean)` -> `编译(compile)` -> `测试(test)` -> `打包(package)` -> `安装(install)`。
    *   你只需要执行简单的命令（如 `mvn package`），Maven就会自动按顺序完成所有步骤，最终生成一个可运行的JAR包或WAR包。

#### **14.3 【手把手教学】创建并使用你的第一个Maven项目**

**第一步：在IntelliJ IDEA中创建一个Maven项目**

1.  打开IDEA，选择 **File -> New -> Project...**。
2.  在左侧面板选择 **Maven**。
3.  确保顶部的 **Project SDK** 已经选择了你安装的JDK。
4.  **不要**勾选 "Create from archetype"。
5.  点击 **Next**。
6.  给你的项目命名，例如 `my-maven-app`。
7.  展开 **Artifact Coordinates**，这是Maven项目的“身份证”：
    *   **GroupId:** 通常是你的公司或组织的域名倒写。对个人学习，可以写 `com.my-learning`。
    *   **ArtifactId:** 就是你刚刚填写的项目名 `my-maven-app`。
    *   **Version:** 版本号，默认 `1.0-SNAPSHOT` 即可（`SNAPSHOT`意为快照版，非稳定版）。
8.  点击 **Finish**。

IDEA会为你生成一个项目。花一分钟观察它的结构，是不是和我上面说的标准结构一模一样？并且，你会看到一个核心文件：**`pom.xml`**。

**第二步：认识 `pom.xml` 并添加依赖**

`pom.xml` (Project Object Model) 是Maven的灵魂。我们来给项目添加一个处理JSON的`Gson`库。

1. 打开`pom.xml`文件，它现在看起来很简单。

2. 我们需要一个地方存放我们的“购物清单”。在`</version>`标签下面，添加一个新的`<dependencies>`标签：

   ```xml
   <dependencies>
       <!-- 我们将在这里添加所有依赖 -->
   </dependencies>
   ```

3. **去哪里找依赖信息呢？** 访问全球最大的Maven仓库网站：[**MVNRepository.com**](https://mvnrepository.com/)。

4. 在搜索框输入 `gson`，点击搜索。通常第一个就是Google的官方库。

5. 点击进入，选择一个较新的稳定版本（比如 `2.10.1`）。

6. 网站会直接为你生成好XML代码片段。**复制**它。

   ```xml
   <!-- https://mvnrepository.com/artifact/com.google.code.gson/gson -->
   <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
       <version>2.10.1</version>
   </dependency>
   ```

7. 将这段代码**粘贴**到`pom.xml`的`<dependencies>`标签内部。

8. **神奇的时刻！** 当你保存`pom.xml`文件后，注意看IDEA的右下角，可能会弹出一个提示，或者在编辑器右上角出现一个带刷新图标的'M'。**点击它（或者选择 "Load Maven Changes"）**。

   

   你会看到IDEA开始在后台下载文件。下载完成后，展开左侧项目视图的 **External Libraries**，你会惊喜地发现 `gson-2.10.1.jar` 已经被**自动下载并配置好**了！你从此告别了手动管理JAR包的时代。

**第三步：在代码中使用新添加的库**

1. 在 `src/main/java` 下，创建一个包（例如 `com.mylearning.app`），然后在包里创建一个 `Main.java` 类。

2. 我们来写一段代码，使用`Gson`库将一个Java对象转换成JSON字符串。

   ```java
   package com.mylearning.app;
   
   import com.google.gson.Gson; // 看！我们可以直接导入 com.google.gson 包了
   
   // 先创建一个简单的学生类用于测试
   class Student {
       private String name;
       private int age;
   
       public Student(String name, int age) {
           this.name = name;
           this.age = age;
       }
       // 为了方便打印，可以不写get/set
   }
   
   public class Main {
       public static void main(String[] args) {
           System.out.println("Hello Maven!");
   
           // 1. 创建一个Gson对象 (这个类来自我们下载的库)
           Gson gson = new Gson();
   
           // 2. 创建一个我们自己的Java对象
           Student student = new Student("Tom", 18);
   
           // 3. 使用gson的功能，将Java对象转为JSON字符串
           String jsonString = gson.toJson(student);
   
           // 4. 打印结果
           System.out.println("Java对象: " + student);
           System.out.println("转换后的JSON字符串: " + jsonString);
       }
   }
   ```

3. 运行`Main.java`，你会看到控制台成功打印出JSON字符串 `{"name":"Tom","age":18}`。这证明我们已经成功地集成了外部库！

#### **14.4 Maven生命周期与IDEA集成**

IDEA的右侧边栏通常有一个 **Maven** 工具窗口。点开它，你会看到你的项目名，下面有 **Lifecycle** 和 **Plugins**。

*   展开 **Lifecycle**，你会看到我们之前提到的标准流程：`clean`, `validate`, `compile`, `test`, `package`, `verify`, `install`, `deploy`。
*   **试着双击 `package`**。Maven会自动执行`package`之前的所有步骤（编译、测试等），然后在项目根目录下生成一个 `target` 文件夹，里面就包含了你项目最终的产出物——`my-maven-app-1.0-SNAPSHOT.jar`。这个JAR包就可以分发给别人运行了。

#### **14.5 本章小结与作业**

*   **小结：** 我们理解了在真实项目中进行**依赖管理**和**标准化构建**的重要性。学习了**Maven**作为项目管理工具的核心功能：通过`pom.xml`管理依赖、统一项目结构、自动化构建。并亲手创建了一个Maven项目，成功地从中央仓库添加了`Gson`库，并在代码中使用了它。你已经迈出了从“写代码”到“做工程”的第一步！

*   **作业（巩固你的工程化能力！）：**

    1.  **添加并使用新依赖：**
        *   在今天的`my-maven-app`项目中，再次访问 [MVNRepository.com](https://mvnrepository.com/)。
        *   搜索一个非常有用的工具库 `Apache Commons Lang3`。
        *   找到它的Maven依赖信息，并将其添加到你的`pom.xml`中。
        *   在`Main.java`中，编写新的代码，使用`Commons Lang3`库中的`StringUtils`类。例如，使用 `StringUtils.isBlank(" ")` 来判断一个字符串是否为空白，或者使用 `StringUtils.reverse("abc")` 来反转一个字符串。
        *   运行代码，验证你是否成功集成了这个新库。

    2.  **探索Maven构建：**
        *   在IDEA的Maven工具窗口中，先双击运行 `clean`。观察一下 `target` 文件夹是不是被删除了。
        *   再双击运行 `package`。观察一下 `target` 文件夹是不是又被重新生成了，并且包含了最终的`.jar`文件。
        *   这个练习能让你对Maven的自动化构建流程有更直观的感受。

完成这个练习，你对Maven的“三板斧”——管理依赖、标准结构、自动构建——就有了扎实的理解。下一章，我们将学习另一个所有工程师都必须掌握的神级工具：**版本控制工具 Git**，它将教会你如何管理代码的每一个历史版本，以及如何与他人高效协作。

好的，我们继续！

你已经学会了如何使用Maven来管理项目的“零件”（依赖库）和“蓝图”（项目结构）。现在，我们要学习如何管理项目本身最重要的资产——**源代码的演变历史**。

想象一下，你正在写一个大项目：

*   今天你加了一个新功能，运行得很好。
*   明天你为了优化代码，大改了一通，结果引入了一个隐藏的bug，程序怎么也跑不起来了。你心急如焚，想恢复到昨天那个“好的”版本，却发现已经记不清改了哪些地方……
*   又或者，你想和一个同学共同开发这个项目。你写你的，他写他的，最后怎么把你们俩的代码安全地合并在一起，而不会互相覆盖？

**Git** 就是解决这些问题的终极神器。它是目前全球最流行、最强大的**分布式版本控制系统 (Distributed Version Control System)**。掌握Git，是成为一名现代软件工程师的**必备技能**。

---

### **第四阶段：Java生态与实-战 (The Ecosystem & Real World)**

### **第15章：版本控制工具 (Git)**

#### **15.1 Git是什么？它解决了什么核心问题？**

*   **核心思想：** Git就像一个拥有超能力的“存档管理器”。它能帮你：
    1.  **记录快照 (Snapshots):** 每当你觉得代码达到一个稳定状态时，可以拍一张“快照”（这在Git里叫一次**提交 (Commit)**）。
    2.  **时光穿梭 (Checkout):** 你可以随时在这些历史快照之间自由穿梭，轻松回到项目的任何一个历史版本。
    3.  **分支管理 (Branching):** 你可以创建一条“平行时空”的开发线（**分支 (Branch)**），在新功能分支上随心所欲地实验，而完全不影响主线上稳定的代码。开发完成后，再把分支安全地**合并 (Merge)**回主线。
    4.  **团队协作 (Collaboration):** Git通过远程仓库（如 **GitHub**, **Gitee**）让多人协作变得极其简单高效。

#### **15.2 安装和配置Git**

1.  **安装Git:**
    *   访问 [Git官网](https://git-scm.com/downloads) 下载适合你操作系统的安装包。
    *   安装过程基本上一路“下一步”即可。

2.  **验证安装:**
    *   打开命令行工具（Windows是 `cmd` 或 `PowerShell`，Mac是 `Terminal`）。
    *   输入 `git --version`，如果看到版本号，说明安装成功。

3.  **首次配置 (非常重要！):**
    *   在命令行中设置你的用户名和邮箱。这会作为你每一次提交的“签名”。
    *   `git config --global user.name "Your Name"`
    *   `git config --global user.email "your.email@example.com"`

#### **15.3 【手把手教学】Git核心工作流**

我们将完全在IntelliJ IDEA中通过图形化界面来操作Git，这对于新手非常友好。

**第一步：让你的项目“被Git管理”**

1. 打开你上一章创建的 `my-maven-app` Maven项目。

2. 在IDEA顶部菜单栏，选择 **VCS -> Enable Version Control Integration...**。

3. 在弹出的窗口中，选择 **Git**，然后点击 **OK**。

   

   你会发现，项目中的文件名都变成了**红色**。这表示这些文件已经被Git“注意到”了，但它们还没有被正式地加入到版本控制中。同时，IDEA底部会出现一个新的 **Git** 工具窗口。

**第二步：工作区、暂存区、本地仓库 (核心概念)**

Git有三个重要的区域：

*   **工作区 (Working Directory):** 就是你在电脑上能看到的项目文件夹。
*   **暂存区 (Staging Area / Index):** 一个临时的缓冲区。你把想提交的文件先“寄存”在这里。
*   **本地仓库 (Local Repository):** 真正存放所有历史快照（Commits）的地方。它是一个隐藏的 `.git` 文件夹，就在你的项目根目录下。

**流程是：** 在**工作区**修改代码 -> 将修改**添加 (add)**到**暂存区** -> 将暂存区的内容**提交 (commit)**到**本地仓库**。

**第三步：你的第一次提交 (Commit)**

1. **添加文件到暂存区 (Add):**

   *   打开底部的 **Git** 工具窗口（或者按 `Alt + 9` / `Cmd + 9`）。
   *   你会看到一个 "Unversioned Files" 列表。
   *   右键点击这些文件或整个列表，选择 **Add to VCS**。
   *   添加后，文件名会变成**绿色**，表示它们已经被放入了暂存区，准备被提交。

2. **提交文件到本地仓库 (Commit):**

   *   点击IDEA左上角的一个**绿色的对勾✔**图标（或者按 `Ctrl + K` / `Cmd + K`）。这会打开 **Commit** 窗口。
   *   在左侧，你会看到所有暂存区里的文件（默认全选）。
   *   在 **Commit Message** 文本框里，输入本次提交的描述信息。这是**极其重要**的！好的提交信息能让你快速了解这次改动的内容。比如，我们写：`Initial commit: Create a Maven project with Gson dependency.`
   *   点击右下角的 **Commit** 按钮。

   

   **恭喜！** 你已经为你的项目创建了第一个历史快照。现在所有文件名都变回了正常的颜色。打开 **Git** 工具窗口，选择 **Log** 标签页，你就能看到你刚刚的提交记录。

**第四步：修改、暂存、再提交**

1. **修改文件:**

   *   打开 `Main.java`，添加一行新的打印语句 `System.out.println("This is my first modification!");`。
   *   你会发现，被修改过的文件名变成了**蓝色**。

2. **查看差异 (Diff):**

   *   在 **Commit** 窗口中，点击蓝色的 `Main.java` 文件名。IDEA会左右分栏显示出文件的修改前和修改后，让你一目了然。

3. **提交修改:**

   *   再次点击绿色的对勾✔打开Commit窗口。
   *   输入提交信息，例如：`Feat: Add a new print statement in Main class` (`Feat`是`Feature`的缩写，一种常见的提交信息规范)。
   *   点击 **Commit**。

   现在，去 **Git -> Log** 窗口看看，你是不是有了两条提交记录？你可以点击不同的记录，在右侧查看那次提交都修改了哪些文件。

**第五步：分支 (Branch) - 在平行时空工作**

主分支通常叫做 `master` 或 `main`，存放的是最稳定、可发布的代码。当我们要开发一个新功能时，最好创建一个新分支。

1. **创建并切换到新分支:**

   *   点击IDEA右下角当前的分支名（比如 `main`）。
   *   在弹出的菜单中，选择 **+ New Branch**。
   *   输入新分支的名字，例如 `feature/add-user-class`，然后点击 **Create**。
   *   你会看到右下角的分支名已经变成了你新创建的分支。

2. **在新分支上开发:**

   * 在`com.mylearning.app`包下，创建一个新的 `User.java` 类。

     ```java
     public class User {
         private String username;
     }
     ```

   * 像之前一样，**Add** 和 **Commit** 这个新文件。提交信息可以是：`Feat: Add User class`。

   现在，这个 `User.java` 文件只存在于 `feature/add-user-class` 这个分支上。

3. **切换回主分支:**

   *   再次点击右下角的分支名。
   *   在列表中选择 `main`，然后选择 **Checkout**。
   *   **神奇的事情发生了！** 你会发现项目里的 `User.java` 文件**消失了**！因为主分支的历史上还没有这个文件。

4. **合并分支 (Merge):**

   *   确保你当前在 `main` 分支上。
   *   点击右下角的分支名，选择 `feature/add-user-class` 分支，然后选择 **Merge into Current**。

   

   *   `User.java` 文件又重新出现在了 `main` 分支的项目中！同时，`feature`分支上的那次提交记录也被合并到了`main`分支的日志里。
   *   现在这个`feature`分支已经完成了它的使命，可以删除了（在分支列表中右键选择Delete）。

#### **15.4 本章小结与作业**

* **小结：** 我们理解了**版本控制**对于软件开发的重要性。学习了Git的**核心工作流**：`add` -> `commit`。掌握了在IDEA中进行**提交(commit)**、**查看历史(log)**、**创建分支(branch)**、**切换分支(checkout)**和**合并分支(merge)**这些最基本也是最重要的操作。你现在已经具备了独立管理个人项目代码历史的能力。

* **作业（像工程师一样管理你的代码！）：**

  1. **gitignore文件:**

     * 你会发现项目中有一个 `.idea` 文件夹和一个 `target` 文件夹。这些都是IDEA或Maven自动生成的，我们**不应该**把它们提交到版本库里。

     * 在项目根目录下创建一个名为 `.gitignore` 的文件。

     * 在文件里写入以下内容：

       ```
       # IDEA files
       .idea/
       
       # Maven build output
       target/
       ```

     * 你会发现这些文件夹在IDEA里会变成被忽略的颜色，并且不会再出现在Commit窗口的待提交列表里。把这个 `.gitignore` 文件本身 **add** 和 **commit** 掉。

  2. **分支与合并练习：**

     *   创建一个名为 `refactor/improve-student` 的新分支。
     *   切换到这个分支。
     *   给 `Student.java` 类添加 `getter` 和 `setter` 方法，并使用**封装**（将字段设为`private`）。
     *   **Commit** 这次修改，提交信息为 `Refactor: Encapsulate fields in Student class`。
     *   切换回 `main` 分支。
     *   将 `refactor/improve-student` 分支合并进来。
     *   验证 `main` 分支上的 `Student.java` 是否已经更新了。

  3. **撤销修改（探索）：**

     *   在 `main` 分支上，随意修改 `Main.java` 的内容，但**不要提交**。
     *   在 **Git -> Log** 窗口中，右键点击最新的那次提交，选择 **Rollback...** (或者在 Commit 窗口中右键文件选择 Rollback)。看看会发生什么？（你的修改会被撤销，恢复到上次提交的状态）。这个功能是你的“后悔药”。

完成这些练习，你对Git的日常使用就会非常熟练了。下一章，我们将学习如何进行**单元测试**，这是保证你代码质量的最后一道防线。

好的，我们继续！

你已经学会了使用Maven管理项目依赖，使用Git管理代码版本。这都是从“工程”的宏观角度来保障项目。现在，我们要把视角拉回到微观的“代码”层面，学习一种能确保你写的每一小段代码都按预期工作的强大技术——**单元测试 (Unit Testing)**。

---

### **第四阶段：Java生态与实战 (The Ecosystem & Real World)**

### **第16章：单元测试 (JUnit)**

#### **16.1 什么是单元测试？我们为什么需要它？**

想象一下，你写了一个很核心的计算方法，比如 `calculateTotalPrice()`。你怎么确定它在各种情况下（商品打折、有优惠券、数量为零等）都是正确的？

*   **原始做法：** 在`main`方法里写一堆`System.out.println()`，然后手动传入各种参数，再用肉眼去比对输出结果是否正确。
    *   **缺点：** 效率低下、不可重复、容易遗漏测试场景，而且这些测试代码会污染你的主程序。当你修改了核心方法后，你得把这些`println`再测一遍，非常痛苦。

*   **单元测试的做法：**
    *   **单元 (Unit):** 指的是你程序中**最小的可测试单元**，通常是一个**方法 (Method)**。
    *   **单元测试：** 就是编写一段**专门的代码**，来自动地、可重复地验证你的某个“单元”（方法）是否在给定的输入下，产生了预期的输出。

**单元测试的核心好处：**

1.  **保证代码质量：** 它是你代码正确性的第一道防线。
2.  **提供信心：** 当你未来需要修改或重构旧代码时，只要单元测试能全部通过，你就有信心相信自己没有破坏原有的功能。这被称为**回归测试 (Regression Testing)**。
3.  **驱动设计：** 好的代码一定是易于测试的。如果一个方法很难写单元测试，通常说明这个方法的设计本身就有问题（比如功能太复杂、依赖太强）。
4.  **充当文档：** 清晰的测试用例本身就是一份“活的”代码使用说明书。

**JUnit** 是Java世界中最流行、应用最广泛的单元测试框架。Maven项目天然就集成了对JUnit的支持。

#### **16.2 【手把手教学】编写你的第一个JUnit测试**

**第一步：准备被测试的类**

首先，我们需要一个“单元”来测试。让我们创建一个简单的计算器类。

1. 在 `my-maven-app` 项目的 `src/main/java/com/mylearning/app` 包下，创建一个新类 `Calculator.java`。

   ```java
   package com.mylearning.app;
   
   public class Calculator {
   
       public int add(int a, int b) {
           return a + b;
       }
   
       public int subtract(int a, int b) {
           return a - b;
       }
   
       public int divide(int a, int b) {
           if (b == 0) {
               // 对于除零的异常情况，我们抛出一个异常
               throw new IllegalArgumentException("Divisor cannot be zero");
           }
           return a / b;
       }
   }
   ```

**第二步：创建测试类**

JUnit的测试代码有自己专属的存放位置：`src/test/java`。

1. 在`Calculator.java`的代码编辑器中，将光标放在类名 `Calculator` 上。

2. 按下 `Alt + Enter` (Windows/Linux) 或 `Option + Return` (Mac)，在弹出的菜单中选择 **Create Test**。

3. 在弹出的窗口中：

   *   **Testing library:** 确保选择了 **JUnit 5**。
   *   **Class name:** IDEA会自动为你生成 `CalculatorTest`。
   *   **Destination package:** 会自动对应到 `src/test/java` 下的同名包。
   *   **勾选你想要测试的方法**，比如 `add`, `subtract`, `divide`。
   *   点击 **OK**。

   

4. IDEA会提示 "JUnit 5 library not found in the module"。点击 **Fix**。IDEA会自动在你的 `pom.xml` 中添加JUnit的依赖！这就是项目管理工具的强大之处。

   ```xml
   <!-- pom.xml 会自动添加类似这样的依赖 -->
   <dependency>
       <groupId>org.junit.jupiter</groupId>
       <artifactId>junit-jupiter-api</artifactId>
       <version>5.8.1</version> <!-- 版本可能不同 -->
       <scope>test</scope> <!-- scope为test表示这个依赖只在测试时需要 -->
   </dependency>
   ```

5. 现在，IDEA为你生成了一个测试类的骨架 `src/test/java/com/mylearning/app/CalculatorTest.java`。

**第三步：编写测试用例**

打开 `CalculatorTest.java`，我们来填充具体的测试逻辑。

*   **`@Test` 注解:** 告诉JUnit，这个方法是一个独立的测试用例。
*   **断言 (Assertions):** 这是单元测试的核心。我们用断言来判断“实际结果”是否“等于预期结果”。JUnit 5 的断言都来自 `Assertions` 类。

```java
package com.mylearning.app;

import org.junit.jupiter.api.Test; // 导入Test注解
import static org.junit.jupiter.api.Assertions.*; // 静态导入所有断言方法，方便使用

class CalculatorTest {

    // 创建一个被测试的对象
    private final Calculator calculator = new Calculator();

    @Test // 这是一个测试用例
    void testAdd() {
        // 1. 准备数据 (Arrange)
        int a = 5;
        int b = 3;
        int expectedResult = 8; // 预期结果

        // 2. 执行被测试的方法 (Act)
        int actualResult = calculator.add(a, b); // 实际结果

        // 3. 断言 (Assert) - 判断实际结果是否符合预期
        // assertEquals(预期结果, 实际结果, "如果测试失败，显示的提示信息");
        assertEquals(expectedResult, actualResult, "5 + 3 应该等于 8");
    }

    @Test
    void testSubtract() {
        // 我们可以把三步合在一起写
        assertEquals(2, calculator.subtract(5, 3));
        assertEquals(-2, calculator.subtract(3, 5));
        assertEquals(0, calculator.subtract(5, 5));
    }

    @Test
    void testDivide_Success() {
        // 测试正常情况
        assertEquals(2, calculator.divide(6, 3));
    }

    @Test
    void testDivide_ByZero() {
        // 我们期望当除数为0时，程序会抛出 IllegalArgumentException 异常
        // 如果异常被正确抛出，则测试通过。如果没有抛出，则测试失败。
        assertThrows(IllegalArgumentException.class, () -> {
            // 把会抛出异常的代码放在一个Lambda表达式里
            calculator.divide(1, 0);
        });
    }
}
```

**第四步：运行测试**

运行JUnit测试非常简单：

*   **运行所有测试:** 在 `CalculatorTest.java` 文件名上右键，选择 **Run 'CalculatorTest'**。
*   **运行单个测试:** 点击方法名左侧的**绿色三角箭头 ▶️**。

运行后，IDEA底部会打开 **Run** 工具窗口，用**绿色**的进度条和对勾告诉你测试通过，用**红色**告诉你测试失败。

*   **模拟一次失败：** 试着把 `testAdd` 方法里的 `expectedResult` 从 `8` 改成 `9`，然后重新运行。看看红色的失败报告长什么样，它会清晰地告诉你“期望是9，但实际是8”。

#### **16.3 更多JUnit常用注解**

除了`@Test`，JUnit还提供了一些有用的注解来控制测试的生命周期：

*   `@BeforeEach`: 在**每个** `@Test` 方法运行**之前**，都会执行一次。通常用于初始化资源。
*   `@AfterEach`: 在**每个** `@Test` 方法运行**之后**，都会执行一次。通常用于清理资源。
*   `@BeforeAll`: 在**所有** `@Test` 方法运行**之前**，只执行**一次**。方法必须是 `static` 的。
*   `@AfterAll`: 在**所有** `@Test` 方法运行**之后**，只执行**一次**。方法必须是 `static` 的。
*   `@Disabled`: 暂时禁用这个测试用例。

```java
class CalculatorTest {
    @BeforeAll
    static void setupAll() {
        System.out.println("所有测试即将开始...");
    }

    @BeforeEach
    void setup() {
        System.out.println("一个测试用例即将开始...");
    }

    @Test
    void myFirstTest() { ... }

    @Test
    @Disabled("这个功能还没做好，暂时不测")
    void mySecondTest() { ... }

    @AfterEach
    void tearDown() {
        System.out.println("一个测试用例结束了。");
    }

    @AfterAll
    static void tearDownAll() {
        System.out.println("所有测试都已结束。");
    }
}
```

#### **16.4 本章小结与作业**

*   **小结：** 我们理解了**单元测试**是保障代码质量和提供重构信心的关键手段。学习了如何使用Java世界的主流测试框架 **JUnit 5**。掌握了在`src/test/java`目录下创建测试类，使用 `@Test` 注解定义测试用例，并利用 **`Assertions` (断言)** 来验证代码行为的正确性。我们还学会了如何测试异常情况以及如何使用生命周期注解。

*   **作业（为你的代码建立安全网！）：**

    1.  **为上一章的`User`类编写测试：**
        *   回顾上一章Git作业中，你为`Student`类添加了封装。现在，也为 `my-maven-app` 项目中的 `User` 类（如果没有，请创建一个）添加 `username` 属性和对应的 `getter/setter`。
        *   创建一个 `UserTest.java` 测试类。
        *   编写一个测试用例 `testSetAndGetUsername()`。在这个用例中，创建一个`User`对象，调用`setUsername("testuser")`，然后调用`getUsername()`，并**断言**其返回值是否等于`"testuser"`。

    2.  **为第9章的作业编写测试：**
        *   回顾第9章的作业 "安全手机号显示" (`PhoneMasker`)。
        *   将 `PhoneMasker` 类和它的 `mask()` 方法拷贝到你现在的Maven项目中。
        *   创建一个 `PhoneMaskerTest.java` 测试类。
        *   编写**多个**测试用例来覆盖不同情况：
            *   `testMask_NormalNumber()`: 测试一个正常的11位手机号，断言结果是否为 `138****5678` 这样的格式。
            *   `testMask_InvalidLength()`: 思考一下，如果传入的手机号不是11位（比如10位或12位），你的`mask`方法会怎样？是会报错还是返回奇怪的结果？为这种情况编写一个测试，明确你期望的行为（比如，可以断言它会抛出`IllegalArgumentException`异常）。
            *   `testMask_NullInput()`: 测试当传入 `null` 时，你的方法是否能正确处理（比如也抛出异常）。

完成这些练习，你将养成一个专业开发者的重要习惯——为你写的每一段核心代码都配上相应的单元测试。

下一章，我们将进入Java Web开发的后台核心——**数据库连接 (JDBC)**，学习如何让你的Java程序与数据库进行交互。



好的，我们继续！

至此，你的Java程序已经非常强大了：它有良好的项目结构（Maven），清晰的版本历史（Git），并且代码质量有单元测试（JUnit）来保障。但它仍然有一个“致命”的缺陷：所有的数据都还只是在内存和本地文件中流转。

一个真正的企业级应用，其核心数据（如用户信息、商品列表、订单记录）都存储在专业的**数据库**中。如何让我们的Java程序去连接、操作数据库？这就是我们这一章要解决的问题。

---

### **第四阶段：Java生态与实战 (The Ecosystem & Real World)**

### **第17章：数据库连接 (JDBC)**

#### **17.1 什么是JDBC？**

想象一下，世界上有各种各样的数据库：MySQL, PostgreSQL, Oracle, SQL Server... 它们的底层实现和通信协议各不相同。如果Java为每一种数据库都提供一套独立的API，那程序员就得为每一种数据库都学习一套全新的代码，这太可怕了。

为了解决这个问题，Sun公司（Java的创造者）定义了一套**标准**，这套标准就是 **JDBC (Java Database Connectivity)**。

*   **JDBC是一套Java API规范**，它定义了Java程序应该如何与**任何**数据库进行交互。它只是一套**接口（规范）**，不包含具体的实现。
*   **数据库驱动 (Driver):** 各个数据库厂商（如MySQL、Oracle）则根据这套JDBC规范，提供了自己数据库的**具体实现**，这个实现就是一个JAR包，我们称之为**数据库驱动**。

**比喻：**

*   **JDBC API:** 就像USB接口标准。它规定了插头的形状、针脚的功能。
*   **数据库驱动:** 就像各个厂商生产的U盘、鼠标。它们都遵循USB标准，所以都能插到你的电脑上使用。
*   **你的Java程序:** 就像你的电脑。你只需要按照USB标准去写代码，就能操作任何符合标准的设备，而不需要关心这个U盘内部的芯片是怎么工作的。

**JDBC工作流程：** 你的Java程序 -> 调用JDBC标准接口 -> JDBC驱动 -> 对应的数据库。

#### **17.2 【手把手教学】前的准备工作**

要进行JDBC编程，你需要：

1.  **一个数据库:** 我们选择最流行、免费开源的 **MySQL**。
2.  **一个数据库管理工具:** 我们选择 **DBeaver** 或 **Navicat**，它们是图形化界面，方便我们查看数据和执行SQL。
3.  **MySQL的JDBC驱动:** 一个JAR包。

**步骤一：安装MySQL**

*   这是一个相对独立的过程，你可以搜索“MySQL 8.0 安装教程”来完成。在安装过程中，请务必**记下你设置的`root`用户密码**。
*   对于初学者，也可以使用**Docker**来快速启动一个MySQL容器，这能避免很多环境配置问题。

**步骤二：安装DBeaver**

*   访问 [DBeaver官网](https://dbeaver.io/download/)，下载并安装社区版（免费）。
*   安装后，新建一个到你本地MySQL的连接，输入用户名`root`和你设置的密码，测试连接成功即可。

**步骤三：在数据库中创建表**

* 在DBeaver中，连接上你的MySQL，执行以下SQL语句来创建一个数据库和一张用户表，并插入几条测试数据。

  ```sql
  -- 创建一个名为 'learning' 的数据库
  CREATE DATABASE IF NOT EXISTS learning;
  
  -- 切换到 'learning' 数据库
  USE learning;
  
  -- 创建一张名为 'users' 的表
  CREATE TABLE users (
      id INT PRIMARY KEY AUTO_INCREMENT,
      username VARCHAR(50) NOT NULL,
      email VARCHAR(100) UNIQUE,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  );
  
  -- 插入一些测试数据
  INSERT INTO users (username, email) VALUES
  ('Alice', 'alice@example.com'),
  ('Bob', 'bob@example.com'),
  ('Charlie', 'charlie@example.com');
  ```

#### **17.3 【手把手教学】JDBC核心编程六步走**

现在，我们回到 `my-maven-app` 项目，用代码来操作刚才创建的`users`表。

**第一步：在`pom.xml`中添加MySQL驱动依赖**

1. 访问 [MVNRepository.com](https://mvnrepository.com/)，搜索 `mysql-connector-java`。

2. 选择一个较新的版本（如`8.0.x`），复制其Maven依赖信息。

3. 将依赖添加到`pom.xml`的`<dependencies>`区域，并加载Maven变更。

   ```xml
   <dependency>
       <groupId>mysql</groupId>
       <artifactId>mysql-connector-java</artifactId>
       <version>8.0.33</version> <!-- 版本可能不同 -->
   </dependency>
   ```

**第二步：编写JDBC代码**

我们将整个流程封装在一个`JdbcPractice.java`类中。JDBC编程有一个非常经典的“六步模板”。

```java
package com.mylearning.app;

import java.sql.*; // 导入所有java.sql包下的类

public class JdbcPractice {

    // --- 数据库连接信息 ---
    // URL格式: jdbc:数据库类型://主机名:端口号/数据库名?参数
    private static final String URL = "jdbc:mysql://localhost:3306/learning?useSSL=false&serverTimezone=UTC";
    private static final String USER = "root";
    private static final String PASSWORD = "你的MySQL密码"; // 替换成你自己的密码

    public static void main(String[] args) {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;

        try {
            // 1. 加载驱动类 (在JDBC 4.0后，这步可以省略，但写上是个好习惯)
            // Class.forName("com.mysql.cj.jdbc.Driver");

            // 2. 获取数据库连接 (Connection)
            System.out.println("正在连接数据库...");
            conn = DriverManager.getConnection(URL, USER, PASSWORD);
            System.out.println("数据库连接成功！");

            // 3. 创建执行SQL语句的对象 (Statement)
            stmt = conn.createStatement();
            String sql = "SELECT id, username, email FROM users";

            // 4. 执行SQL语句，并接收返回的结果集 (ResultSet)
            rs = stmt.executeQuery(sql); // executeQuery用于执行SELECT查询

            // 5. 处理结果集 (ResultSet)
            System.out.println("--- 用户列表 ---");
            while (rs.next()) { // .next() 将光标移动到下一行，如果有数据则返回true
                // 通过列名或列索引(从1开始)获取数据
                int id = rs.getInt("id");
                String username = rs.getString("username");
                String email = rs.getString("email");

                System.out.printf("ID: %d, 用户名: %s, 邮箱: %s\n", id, username, email);
            }

        } catch (SQLException e) {
            System.err.println("数据库操作失败！");
            e.printStackTrace();
        } finally {
            // 6. 释放资源 (非常重要！必须在finally块中进行，且顺序与获取时相反)
            System.out.println("--- 释放资源 ---");
            try {
                if (rs != null) rs.close();
                if (stmt != null) stmt.close();
                if (conn != null) conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}
```

*   **运行代码**，如果一切配置正确，你将在控制台看到从数据库中查询出的三条用户信息。

#### **17.4 防止SQL注入：`PreparedStatement`**

上面使用的`Statement`对象有一个巨大的安全漏洞：**SQL注入**。如果SQL语句是拼接用户输入构成的，恶意用户可能输入SQL片段来破坏你的查询。

**`PreparedStatement`** 是`Statement`的子接口，它通过**预编译**和**参数占位符**的方式，从根本上杜绝了SQL注入。**在实际开发中，必须总是使用`PreparedStatement`！**

**【手把手教学】使用 `PreparedStatement` 进行增、删、改、查**

我们来写一个更完整的 `UserDao` (Data Access Object，数据访问对象) 类，这是企业开发中的常见模式。

```java
// UserDao.java
public class UserDao {
    // ... 连接信息常量 ...

    // --- 查询单个用户 ---
    public void findUserById(int userId) {
        // 使用 try-with-resources 自动关闭资源
        try (Connection conn = DriverManager.getConnection(URL, USER, PASSWORD)) {
            // 使用 ?作为参数占位符
            String sql = "SELECT * FROM users WHERE id = ?";
            
            // 创建 PreparedStatement 对象
            try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
                // 设置参数：第一个问号，值为userId
                pstmt.setInt(1, userId);
                
                // 执行查询
                try (ResultSet rs = pstmt.executeQuery()) {
                    if (rs.next()) {
                        System.out.printf("找到用户: ID: %d, 用户名: %s\n", rs.getInt("id"), rs.getString("username"));
                    } else {
                        System.out.println("未找到ID为 " + userId + " 的用户。");
                    }
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    // --- 插入新用户 ---
    public void addUser(String username, String email) {
        try (Connection conn = DriverManager.getConnection(URL, USER, PASSWORD);
             PreparedStatement pstmt = conn.prepareStatement("INSERT INTO users (username, email) VALUES (?, ?)")) {
            
            pstmt.setString(1, username);
            pstmt.setString(2, email);
            
            // .executeUpdate() 用于执行增、删、改操作，返回受影响的行数
            int rowsAffected = pstmt.executeUpdate();
            
            if (rowsAffected > 0) {
                System.out.println("用户 " + username + " 添加成功！");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    
    // 在 main 方法中测试
    public static void main(String[] args) {
        UserDao dao = new UserDao();
        dao.addUser("David", "david@example.com");
        dao.findUserById(4); // 查找刚刚添加的用户
    }
}
```

*   `PreparedStatement` 不仅更安全，而且由于预编译机制，在多次执行相同结构的SQL时，性能也更好。

#### **17.5 本章小结与作业**

*   **小结：** 我们理解了**JDBC**作为Java数据库连接的**标准规范**，以及**数据库驱动**作为具体实现的作用。我们亲手搭建了MySQL环境，并在Java项目中通过Maven引入了驱动。最重要的是，我们掌握了JDBC编程的**经典六步**，并学会了使用更安全、更高效的 **`PreparedStatement`** 来执行数据库的增删改查操作，并利用`try-with-resources`来优雅地管理资源。

*   **作业（打造你的数据访问层！）：**

    1.  **完善`UserDao`：**
        *   在今天的`UserDao.java`类中，继续添加以下两个方法：
            *   `public void updateUserEmail(int userId, String newEmail)`: 根据用户ID更新其邮箱。
            *   `public void deleteUser(int userId)`: 根据用户ID删除一个用户。
        *   在`main`方法中编写代码来测试你新添加的更新和删除功能。

    2.  **查询所有用户并封装成对象：**
        *   在`com.mylearning.app`包下，创建一个`User.java`实体类，包含`id`, `username`, `email`等属性，并提供`getter/setter`和`toString()`方法。
        *   在`UserDao`中，写一个新方法 `public List<User> findAllUsers()`。
        *   在这个方法里，执行`SELECT * FROM users`查询。
        *   遍历`ResultSet`，在`while`循环中，为每一行数据都创建一个`User`对象，将查询到的`id`, `username`, `email`设置到对象中。
        *   将每个创建好的`User`对象添加到一个`ArrayList<User>`中。
        *   最后，返回这个包含所有用户对象的列表。
        *   在`main`方法中调用此方法，并遍历打印出返回的`List<User>`，验证结果。这个练习是实际项目中最常见的操作模式。

完成这个练习，你就打通了Java程序与后端数据库之间的“任督二脉”。

原生JDBC虽然强大，但也比较繁琐。在下一阶段，我们将学习目前Java世界最流行的框架 **Spring Boot**，它将JDBC等操作简化到了极致，让你能以惊人的速度开发功能完备的Web应用。准备好，迎接真正的企业级开发！

非常好！很高兴我们达成了共识。相信我，学完这一章，你会爱上这种全新的代码风格，并惊叹于Java语言的进化。

准备好，让我们来一次编程思想的“大升级”！

---

### **第四阶段：Java生态与实战 (The Ecosystem & Real World)**

### **第18章：Java 8+ 新特性 (Lambda表达式、Stream API)**

这一章的核心，就是学习如何用一种更简洁、更优雅、更高效的方式来处理数据，特别是集合（List, Set等）中的数据。

#### **18.1 Lambda 表达式 (Lambda Expressions) - 匿名函数的艺术**

**什么是Lambda？**
简单来说，Lambda表达式就是一段可以被传递的、匿名的代码块。它允许你把一个**函数**当作一个**参数**来传递。

**我们为什么需要它？**
看一个例子：假设我们要对一个`List<String>`进行排序。在Java 8之前，我们必须这么写：

```java
List<String> names = Arrays.asList("peter", "anna", "mike");
Collections.sort(names, new Comparator<String>() {
    @Override
    public int compare(String a, String b) {
        return a.compareTo(b);
    }
});
```

看到了吗？为了实现`compare`这一个核心的比较逻辑，我们被迫写了一个完整的、匿名的内部类 (`new Comparator<String>(){...}`)，代码非常臃肿。

**使用Lambda，代码会变成这样：**

```java
List<String> names = Arrays.asList("peter", "anna", "mike");
Collections.sort(names, (String a, String b) -> a.compareTo(b));
```

是不是清爽了无数倍！`->`左边是参数列表，右边是方法体。这就是Lambda的魔力。

**Lambda语法三要素：**

1.  **`(参数列表)`:** `->`左边的部分。
2.  **`->`:** "goes to" 箭头，分隔符。
3.  **`{方法体}`:** `->`右边的部分，是具体的代码实现。

**【手把手教学】Lambda语法的各种“简写”形态**

1.  **标准形式：**
    `(String a, String b) -> { return a.compareTo(b); }`

2.  **类型推断：** 编译器能推断出参数类型，所以可以省略。
    `(a, b) -> { return a.compareTo(b); }`

3.  **方法体只有一行：** 如果方法体只有一行代码，可以省略大括号`{}`和`return`关键字。
    `(a, b) -> a.compareTo(b)`

4.  **参数只有一个：** 如果参数只有一个，可以省略小括号`()`。
    `name -> System.out.println(name)`

**Lambda的前提：函数式接口 (Functional Interface)**
Lambda表达式不是随便什么地方都能用的。它只能用于“**函数式接口**”的场景。

*   **函数式接口：** 就是**有且仅有一个抽象方法**的接口。比如`Runnable`接口（只有一个`run()`方法），`Comparator`接口（只有一个`compare()`方法）。
*   `@FunctionalInterface` 注解：可以加在接口上，如果这个接口不满足函数式接口的定义，编译器会报错。

```java
@FunctionalInterface
interface MyGreeting {
    void sayMessage(String message);
}

// 我们可以用Lambda表达式来创建这个接口的实例
MyGreeting greeting = message -> System.out.println("Hello " + message);
greeting.sayMessage("World"); // 输出 Hello World
```

#### **18.2 Stream API - 流式数据处理的革命**

Stream API是Java 8的另一大“核武器”。它让你能以一种**声明式 (Declarative)**的方式来处理数据集合，就像搭建一条**流水线**。

*   **核心思想：**
    1.  **获取流 (Get a Stream):** 从一个数据源（如List, Set, Array）获取一个Stream。
    2.  **中间操作 (Intermediate Operations):** 对流进行一系列的加工处理（过滤、映射、排序等）。这些操作是**惰性执行**的，它们会返回一个新的Stream，可以形成一个链条。
    3.  **终端操作 (Terminal Operation):** 对流进行最终的计算，得到一个结果（如一个新的List、一个值、或者什么都不返回）。终端操作会触发前面所有中间操作的执行。

**【手把手教学】用Stream API处理一个学生列表**

1. 创建一个`StreamPractice.java`类，并准备一些数据。

   ```java
   // 先定义一个简单的Student类
   class Student {
       private String name;
       private int age;
       private double score;
       // (构造方法, getter, toString... 省略)
   }
   
   public class StreamPractice {
       public static void main(String[] args) {
           List<Student> students = Arrays.asList(
               new Student("Alice", 18, 85.5),
               new Student("Bob", 20, 95.0),
               new Student("Charlie", 18, 70.0),
               new Student("David", 21, 65.5),
               new Student("Eve", 20, 88.0)
           );
           // ...
       }
   }
   ```

2. **实战需求：找出所有年龄大于等于20岁的学生，按分数降序排序，并取出他们的名字，存入一个新的List中。**

* **传统做法 (Java 7):**

  ```java
  List<Student> filteredStudents = new ArrayList<>();
  for (Student s : students) {
      if (s.getAge() >= 20) {
          filteredStudents.add(s);
      }
  }
  Collections.sort(filteredStudents, new Comparator<Student>() {
      @Override
      public int compare(Student o1, Student o2) {
          return Double.compare(o2.getScore(), o1.getScore()); // 降序
      }
  });
  List<String> studentNames = new ArrayList<>();
  for (Student s : filteredStudents) {
      studentNames.add(s.getName());
  }
  System.out.println("传统做法结果: " + studentNames);
  ```

  代码冗长，逻辑分散，还产生了中间集合`filteredStudents`。

* **Stream API做法 (Java 8):**

  ```java
  List<String> studentNames = students.stream() // 1. 获取流
      .filter(s -> s.getAge() >= 20)          // 2. 中间操作：过滤
      .sorted((s1, s2) -> Double.compare(s2.getScore(), s1.getScore())) // 3. 中间操作：排序
      .map(s -> s.getName())                  // 4. 中间操作：映射 (转换)
      .collect(Collectors.toList());          // 5. 终端操作：收集成List
  
  System.out.println("Stream API结果: " + studentNames);
  ```

  是不是像一条清晰的流水线？`[Bob, Eve]`。

**核心Stream操作详解：**

*   `stream()`: 从集合获取流。
*   `filter(Predicate<T> p)`: **过滤**。接收一个返回`boolean`的Lambda，只保留满足条件的元素。
*   `map(Function<T, R> f)`: **映射/转换**。将流中的每个元素T，通过Lambda转换成另一种元素R。比如`Student`对象流 -> `String`名字流。
*   `sorted(Comparator<T> c)`: **排序**。接收一个`Comparator`来定义排序规则。
*   `collect(Collector<T, A, R> c)`: **收集**。最常用的终端操作，将流中的元素收集到集合中，如`Collectors.toList()`, `Collectors.toSet()`。
*   `forEach(Consumer<T> c)`: **遍历**。对流中每个元素执行一个操作，无返回值。
*   `distinct()`: **去重**。
*   `limit(long n)`: **截断**，只取前n个元素。

#### **18.3 方法引用 (Method Reference)**

方法引用是Lambda表达式的一种**终极简写**形式。如果你的Lambda表达式只是在直接调用一个已经存在的方法，那么就可以使用方法引用。

| 类型                        | 示例                  | 等价的Lambda                |
| :-------------------------- | :-------------------- | :-------------------------- |
| **静态方法引用**            | `Math::abs`           | `x -> Math.abs(x)`          |
| **实例方法引用 (特定对象)** | `myPrinter::println`  | `x -> myPrinter.println(x)` |
| **实例方法引用 (任意对象)** | `String::toUpperCase` | `s -> s.toUpperCase()`      |
| **构造方法引用**            | `ArrayList::new`      | `() -> new ArrayList()`     |

**【手把手教学】用方法引用简化Stream代码**
我们之前的排序和映射代码可以进一步简化：

```java
// 使用Comparator.comparing可以更优雅地排序
import static java.util.Comparator.comparingDouble;

List<String> studentNames = students.stream()
    .filter(s -> s.getAge() >= 20)
    // .sorted((s1, s2) -> Double.compare(s2.getScore(), s1.getScore()))
    .sorted(comparingDouble(Student::getScore).reversed()) // 排序简化
    // .map(s -> s.getName())
    .map(Student::getName) // 映射简化: "对于每个Student对象s，调用它的getName方法"
    .collect(Collectors.toList());
```

#### **18.4 本章小结与作业**

*   **小结：** 我们学习了Java 8带来的革命性新特性。**Lambda表达式**让我们能用简洁的语法传递代码块；**Stream API**则提供了一套强大、声明式的“流水线”来处理集合数据，核心操作包括`filter`, `map`, `sorted`, `collect`；**方法引用**作为Lambda的语法糖，让代码更加精炼。掌握这些，你的Java代码将提升到“现代化”的水平。

*   **作业（用现代化的方式解决问题！）：**

    1.  **重构旧作业 - 单词频率统计器：**
        *   回顾第10章的作业“单词频率统计器”。
        *   当时你是用循环和`Map`来解决的。现在，请使用 **Stream API** 来重构它。
        *   **提示：**
            1.  将文本用`split(" ")`分割成一个单词数组。
            2.  使用`Arrays.stream(words)`从数组获取流。
            3.  使用`collect()`终端操作。思考一下，`Collectors`类里有没有一个收集器可以直接帮你分组并计数的？（提示：搜索`Collectors.groupingBy`和`Collectors.counting`）。

    2.  **数据处理流水线：**
        *   给定一个整数列表 `List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 2, 4);`
        *   请使用**一个**Stream流水线操作，完成以下所有要求：
            1.  筛选出所有**偶数**。
            2.  对这些偶数进行**去重**。
            3.  将每个偶数**乘以2**。
            4.  将处理后的结果收集到一个新的`List`中。
        *   最终打印出这个List，结果应该是 `[4, 8, 12, 16, 20]`。

    3.  **方法引用练习：**
        *   创建一个字符串列表 `List<String> words = Arrays.asList("apple", "Banana", "CHERRY");`
        *   使用Stream和**方法引用**，将列表中的所有单词都转换为小写，并打印出来。
        *   **提示：** 使用`forEach`和`String::toLowerCase`。

完成这些练习，你将能熟练地运用Lambda和Stream来编写优雅、高效的数据处理代码。

现在，你已经具备了所有必要的“内功”和“思想”，我们终于可以进入**第五阶段**，学习如何使用业界最顶级的框架**Spring Boot**，将你所有的知识融会贯通，快速构建出一个真正的Web应用！

<div style="display: flex; justify-content: space-around;">
  <span>
    <a href="./3.Java从零到精通-第三阶段.md">
      ← 上一篇：第三阶段
    </a>
  </span>
  <span>
    <a href="./5.Java从零到精通-第五阶段.md">
      下一篇：第五阶段 →
    </a>
  </span>
</div>